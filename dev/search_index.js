var documenterSearchIndex = {"docs":
[{"location":"models/models/#Common-Model-Functions","page":"Common Model Functions","title":"Common Model Functions","text":"","category":"section"},{"location":"models/models/#Abstract-Model-Types","page":"Common Model Functions","title":"Abstract Model Types","text":"","category":"section"},{"location":"models/models/#DiffFusion.Model","page":"Common Model Functions","title":"DiffFusion.Model","text":"abstract type Model end\n\nAn abstract base model type. This type covers component models and hybrid composite models.\n\n\n\n\n\n","category":"type"},{"location":"models/models/#DiffFusion.ComponentModel","page":"Common Model Functions","title":"DiffFusion.ComponentModel","text":"abstract type ComponentModel <: Model end\n\nAn abstract component model type. This type implements the common interface of all component models.\n\n\n\n\n\n","category":"type"},{"location":"models/models/#State-Variable","page":"Common Model Functions","title":"State Variable","text":"","category":"section"},{"location":"models/models/","page":"Common Model Functions","title":"Common Model Functions","text":"A model allows to simulate a stochastic process left(X_tright). For a given t the vector X_t is represented by a ModelState. ","category":"page"},{"location":"models/models/#DiffFusion.ModelState","page":"Common Model Functions","title":"DiffFusion.ModelState","text":"struct ModelState\n    X::AbstractMatrix\n    idx::Dict{String,Int}\nend\n\nA ModelState is a matrix of state variables decorated by a dictionary of alias strings and optional additional parameters.\n\nIt allows to decouple simulation of state variables and usage of state variables.\n\nX is of size (n, p) where n represents the number of state aliases and p represents the number of paths. A matrix with a large number of paths is typically used when calling model functions for payoff evaluation.\n\nA single realisation of risk factors is represented by an (n, 1) matrix. We use (n,1) matrix instead of (n,) vector to avoid size-dependent switches.\n\nidx is a dictionary with n entries. Keys represent state state alias entries and values represent the corresponding positions in X.\n\nparams is a struct or dictionary that holds additional pre-calculated state-independent data which is used in subsequent Theta and Sigma calculations. This aims at avoiding duplicate calculations for state-dependent Theta and Sigma calculations. The params is supposed to be calculated by method simulation_parameters(...).\n\n\n\n\n\n","category":"type"},{"location":"models/models/#DiffFusion.model_state","page":"Common Model Functions","title":"DiffFusion.model_state","text":"model_state(X::AbstractMatrix, idx::Dict{String,Int})\n\nCreate a ModelState object and make sure it is consistent.\n\n\n\n\n\nmodel_state(X::AbstractMatrix, m::Model, params = nothing)\n\nCreate a model state for a given model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.alias_dictionary","page":"Common Model Functions","title":"DiffFusion.alias_dictionary","text":"alias_dictionary(alias_list)\n\nCreate an alias dictionary\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Auxilliary-Methods","page":"Common Model Functions","title":"Auxilliary Methods","text":"","category":"section"},{"location":"models/models/#DiffFusion.alias-Tuple{DiffFusion.Model}","page":"Common Model Functions","title":"DiffFusion.alias","text":"alias(m::Model)\n\nReturn the model's own alias. This is the default implementation.\n\n\n\n\n\n","category":"method"},{"location":"models/models/#DiffFusion.model_alias","page":"Common Model Functions","title":"DiffFusion.model_alias","text":"model_alias(m::Model)\n\nReturn the aliases modelled by a model.\n\nTypically, this coincides with the model's own alias. For composite models this is a list of component model aliases.\n\n\n\n\n\nmodel_alias(m::CompositeModel)\n\nReturn the aliases modelled by a model.\n\nTypical this coincides with the model's own alias. For composite models this is a list of component model aliases.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.state_alias","page":"Common Model Functions","title":"DiffFusion.state_alias","text":"state_alias(m::Model)\n\nReturn a list of state alias strings that represent the model components.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.factor_alias","page":"Common Model Functions","title":"DiffFusion.factor_alias","text":"factor_alias(m::Model)\n\nReturn a list of risk factor alias strings that represent the components of the multi-variate Brownian motion risk factors. \n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.parameter_grid","page":"Common Model Functions","title":"DiffFusion.parameter_grid","text":"parameter_grid(m::Model)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(models::AbstractVector)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::CevAssetModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::LognormalAssetModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::CompositeModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::GaussianHjmModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::MarkovFutureModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Model-Functions-for-Simulation","page":"Common Model Functions","title":"Model Functions for Simulation","text":"","category":"section"},{"location":"models/models/#DiffFusion.Theta","page":"Common Model Functions","title":"DiffFusion.Theta","text":"Theta(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t]. If Theta is state-dependent a state vector X must be supplied. The method returns a vector of length(state_alias).\n\n\n\n\n\nTheta(\n    m::CevAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t].\n\n\n\n\n\nTheta(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t].\n\n\n\n\n\nTheta(\n    m::CoxIngersollRossModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t].\n\n\n\n\n\nTheta(\n    m::SimpleModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t].\n\n\n\n\n\nTheta(\n    m::DiagonalModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::ModelState,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t].\n\n\n\n\n\nTheta(\n    m::GaussianHjmModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t]. If Theta is state-dependent a state vector X must be supplied. The method returns a vector of length(state_alias).\n\n\n\n\n\nTheta(\n    m::MarkovFutureModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t]. If Theta is state-dependent a state vector X must be supplied. The method returns a vector of length(state_alias).\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.H_T","page":"Common Model Functions","title":"DiffFusion.H_T","text":"H_T(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t]. If H is state-dependent a state vector X must be supplied. We use the transposed of H to\n\nallow for efficient sparse CSC matrix insertion and\nallow for efficient multiplication X' * H' = (H * X)'.\n\nThe state vector X may effectively be a subset of all states. To accommodate this, we use a dedicated list of state aliases state_alias_H for the result matrix. The method returns a (sparse) matrix of size (length(state_alias_H), length(state_alias)).\n\n\n\n\n\nH_T(\n    m::CevAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::CoxIngersollRossModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\nThere is no benefit in allowing HT to be state-dependent. If HT would need to be state-dependent then it should be incorporated into Theta.\n\n\n\n\n\nH_T(\n    m::SimpleModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::DiagonalModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::GaussianHjmModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::MarkovFutureModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.Sigma_T","page":"Common Model Functions","title":"DiffFusion.Sigma_T","text":"Sigma_T(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\nThe state vector is required if Sigma(u) depends on X_s.\n\nThe result of an evaluation of Sigma_T(...)(u) is a matrix of size (length(state_alias), length(factor_alias_Sigma)).\n\nThe Brownian motion relevant for a model may effectively be a subset of all Brownian motions. To accommodate this, we use a dedicated list of factor aliases factor_alias_Sigma for the size of the result matrix of a function evaluation.\n\nThe transposed '_T' is convention to simplify notation for covariance calculation.\n\n\n\n\n\nSigma_T(\n    m::CevAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\n\n\n\n\nSigma_T(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\n\n\n\n\nSigma_T(\n    m::CoxIngersollRossModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\n\n\n\n\nSigma_T(\n    m::SimpleModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\n\n\n\n\nSigma_T(\n    m::DiagonalModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::ModelState,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\n\n\n\n\nSigma_T(\n    m::GaussianHjmModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\n\n\n\n\nSigma_T(\n    m::MarkovFutureModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.state_dependent_Theta","page":"Common Model Functions","title":"DiffFusion.state_dependent_Theta","text":"state_dependent_Theta(m::Model)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::CevAssetModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::LognormalAssetModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::CompositeModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::GaussianHjmModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::MarkovFutureModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.state_dependent_H","page":"Common Model Functions","title":"DiffFusion.state_dependent_H","text":"state_dependent_H(m::Model)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::CevAssetModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::LognormalAssetModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::CompositeModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::GaussianHjmModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::MarkovFutureModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.state_dependent_Sigma","page":"Common Model Functions","title":"DiffFusion.state_dependent_Sigma","text":"state_dependent_Sigma(m::Model)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::CevAssetModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::LognormalAssetModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::CompositeModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::GaussianHjmModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::MarkovFutureModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.state_alias_H","page":"Common Model Functions","title":"DiffFusion.state_alias_H","text":"state_alias_H(m::Model)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::CevAssetModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::LognormalAssetModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::CompositeModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::GaussianHjmModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::MarkovFutureModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.factor_alias_Sigma","page":"Common Model Functions","title":"DiffFusion.factor_alias_Sigma","text":"factor_alias_Sigma(m::Model)\n\nReturn a list of factor alias strings required for (Sigma(u)' Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::CevAssetModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::LognormalAssetModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::CompositeModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::GaussianHjmModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::MarkovFutureModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.covariance","page":"Common Model Functions","title":"DiffFusion.covariance","text":"covariance(\n    m::Model,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nCalculate the covariance matrix over a time interval.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.volatility_and_correlation","page":"Common Model Functions","title":"DiffFusion.volatility_and_correlation","text":"volatility_and_correlation(\n    m::Model,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    vol_eps::ModelValue = 1.0e-8,  # avoid division by zero\n    )\n\nCalculate the volatility vector and correlation matrix over a time interval.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.simulation_parameters","page":"Common Model Functions","title":"DiffFusion.simulation_parameters","text":"simulation_parameters(\n    m::Model,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\n\n\n\n\nsimulation_parameters(\n    m::CevAssetModel,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\n\n\n\n\nsimulation_parameters(\n    m::GaussianHjmModel,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\nFor LognormalAssetModel there are no valuations that should be cached.\n\n\n\n\n\nsimulation_parameters(\n    m::CevAssetModel,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\n\n\n\n\nsimulation_parameters(\n    m::DiagonalModel,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\n\n\n\n\nsimulation_parameters(\n    m::GaussianHjmModel,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\nFor GaussianHjmModel there are no valuations that should be cached.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#DiffFusion.diagonal_volatility","page":"Common Model Functions","title":"DiffFusion.diagonal_volatility","text":"diagonal_volatility(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the path-dependent volatilities for a given model.\n\nX is supposed to hold a state matrix of size (n, p). Here, n is length(state_alias(m)) and p is the number of paths.\n\nThe method returns a matrix of size (n, p).\n\n\n\n\n\ndiagonal_volatility(\n    m::CevAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the path-dependent volatilities for CevAssetModel.\n\nX is supposed to hold a state matrix of size (n, p). Here, n is length(state_alias(m)) and p is the number of paths.\n\nThe method returns a matrix of size (n, p).\n\n\n\n\n\ndiagonal_volatility(\n    m::CoxIngersollRossModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the path-dependent volatilities for CoxIngersollRossModel.\n\nX is supposed to hold a state matrix of size (n, p). Here, n is length(state_alias(m)) and p is the number of paths.\n\nThe method returns a matrix of size (n, p).\n\n\n\n\n\ndiagonal_volatility(\n    m::DiagonalModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the path-dependent volatilities for a given model.\n\nX is supposed to hold a state matrix of size (n, p). Here, n is length(state_alias(m)) and p is the number of paths.\n\nThe method returns a matrix of size (n, p).\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#Interest-Rates-Models","page":"Interest Rates Models","title":"Interest Rates Models","text":"","category":"section"},{"location":"models/rates_models/#Model-Types","page":"Interest Rates Models","title":"Model Types","text":"","category":"section"},{"location":"models/rates_models/#DiffFusion.SeparableHjmModel","page":"Interest Rates Models","title":"DiffFusion.SeparableHjmModel","text":"abstract type SeparableHjmModel <: ComponentModel end\n\nAn abstract type for separable HJM models.\n\nThis type covers common functions for Gaussian and Quasi-Gaussian models.\n\nThe SeparableHjmModel is supposed to hold a constant vector-valued ParameterTermstructure for mean reversion chi and benchmark rate times delta.\n\n\n\n\n\n","category":"type"},{"location":"models/rates_models/#DiffFusion.GaussianHjmModel","page":"Interest Rates Models","title":"DiffFusion.GaussianHjmModel","text":"struct GaussianHjmModel <: SeparableHjmModel\n    alias::String\n    delta::ParameterTermstructure\n    chi::ParameterTermstructure\n    sigma_T::GaussianHjmModelVolatility\n    y::AbstractArray\n    state_alias::AbstractVector\n    factor_alias::AbstractVector\n    correlation_holder::Union{CorrelationHolder, Nothing}\n    quanto_model::Union{AssetModel, Nothing}\n    scaling_type::BenchmarkTimesScaling\nend\n\nA Gaussian HJM model with piece-wise constant benchmark rate volatility and constant mean reversion.\n\n\n\n\n\n","category":"type"},{"location":"models/rates_models/#DiffFusion.gaussian_hjm_model","page":"Interest Rates Models","title":"DiffFusion.gaussian_hjm_model","text":"gaussian_hjm_model(\n    alias::String,\n    delta::ParameterTermstructure,\n    chi::ParameterTermstructure,\n    sigma_f::BackwardFlatVolatility,\n    correlation_holder::Union{CorrelationHolder, Nothing},\n    quanto_model::Union{AssetModel, Nothing},\n    scaling_type::BenchmarkTimesScaling = ForwardRateScaling,\n    )\n\nCreate a Gausian HJM model.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#Model-Functions-for-Simulation","page":"Interest Rates Models","title":"Model Functions for Simulation","text":"","category":"section"},{"location":"models/rates_models/#DiffFusion.func_y","page":"Interest Rates Models","title":"DiffFusion.func_y","text":"func_y(\n    y0::AbstractMatrix,\n    chi::AbstractVector,\n    sigmaT::AbstractMatrix,\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nCalculate variance/auxiliary state variable y(t) given y(s)=y_0.\n\nIn this function we assume that sigma is constant over the time interval (st).\n\n\n\n\n\nfunc_y(m::GaussianHjmModel, t::ModelTime)\n\nCalculate variance/auxiliary state variable y(t).\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.chi_hjm","page":"Interest Rates Models","title":"DiffFusion.chi_hjm","text":"chi_hjm(m::SeparableHjmModel)\n\nReturn vector of constant mean reversion rates.\n\n\n\n\n\nchi_hjm(m::MarkovFutureModel)\n\nReturn vector of constant mean reversion rates.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.benchmark_times","page":"Interest Rates Models","title":"DiffFusion.benchmark_times","text":"benchmark_times(m::SeparableHjmModel)\n\nReturn vector of reference/benchmark times\n\n\n\n\n\nbenchmark_times(m::MarkovFutureModel)\n\nReturn vector of reference/benchmark times\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.H_hjm","page":"Interest Rates Models","title":"DiffFusion.H_hjm","text":"H_hjm(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nDiagonal entries of H(st).\n\n\n\n\n\nH_hjm(m::SeparableHjmModel, s::ModelTime, t::ModelTime)\n\nDiagonal entries of H(st).\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.G_hjm","page":"Interest Rates Models","title":"DiffFusion.G_hjm","text":"G_hjm(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nVector function G(st).\n\n\n\n\n\nG_hjm(m::SeparableHjmModel, s::ModelTime, t::ModelTime)\n\nVector function G(st).\n\n\n\n\n\nG_hjm(chi::AbstractVector, s::ModelTime, T::AbstractVector)\n\nVector function G(st) as matrix of size (d,k) where k = length(T)\n\n\n\n\n\nG_hjm(m::SeparableHjmModel, s::ModelTime, T::AbstractVector)\n\nVector function G(st).\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.BenchmarkTimesScaling","page":"Interest Rates Models","title":"DiffFusion.BenchmarkTimesScaling","text":"@enum(\n    BenchmarkTimesScaling,\n    ForwardRateScaling,\n    ZeroRateScaling,\n    DiagonalScaling,\n)\n\nSpecify scaling methods to be used for state variable x volatility function.\n\nForwardRateScaling (default) uses forward rates as benchmark rates. For refrence, see Andersen/Piterbarg, Interest Rate Modeling, 2010, Prop. 13.3.2.\n\nZeroRateScaling uses continous compounded zero rates as benchmark rates. See https://ssrn.com/abstract=4638188 for details.\n\nDiagonalScaling uses identity matrix (i.e. no scaling).\n\n\n\n\n\n","category":"type"},{"location":"models/rates_models/#DiffFusion.benchmark_times_scaling","page":"Interest Rates Models","title":"DiffFusion.benchmark_times_scaling","text":"benchmark_times_scaling(\n    chi::AbstractVector,\n    delta::AbstractVector,\n    scaling_type::BenchmarkTimesScaling = ForwardRate::BenchmarkTimesScaling\n    )\n\nCalculate volatility scaling matrix depending on the scaling type.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.benchmark_times_scaling_forward_rate","page":"Interest Rates Models","title":"DiffFusion.benchmark_times_scaling_forward_rate","text":"benchmark_times_scaling_forward_rate(chi::AbstractVector, delta::AbstractVector)\n\nBenchmark times volatility scaling matrix H H^f^-1 = H^f H^-1^-1.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.benchmark_times_scaling_zero_rate","page":"Interest Rates Models","title":"DiffFusion.benchmark_times_scaling_zero_rate","text":"benchmark_times_scaling_zero_rate(chi::AbstractVector, delta::AbstractVector)\n\nBenchmark times volatility scaling matrix based on zero rates.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.func_Theta_x","page":"Interest Rates Models","title":"DiffFusion.func_Theta_x","text":"func_Theta_x(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for state variable x.\n\nIn this function we assume for the interval (st) that     - variance y(s) is known,     - volatility σ is state-independent and     - quanto adjustment alpha is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.func_Theta_x_integrate_y","page":"Interest Rates Models","title":"DiffFusion.func_Theta_x_integrate_y","text":"func_Theta_x_integrate_y(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for state variable x.\n\nAvoidance of explicit σ^top σ dependence may help with integrating over jumps in piece-wise constant volatility. \n\nIn this function we assume for the interval (st) that     - variance y is state-independent,     - volatility σ is state-independent and     - quanto adjustment α is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.func_Theta_s","page":"Interest Rates Models","title":"DiffFusion.func_Theta_s","text":"func_Theta_s(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for integrated state variable s.\n\nIn this function we assume for the interval (st) that     - variance y state-independent,     - volatility σ is state-independent and     - quanto adjustment α is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.func_Theta","page":"Interest Rates Models","title":"DiffFusion.func_Theta","text":"func_Theta(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for component model state variable X.\n\nIn this function we assume for the interval (st) that     - variance y state-independent,     - volatility σ is state-independent and     - quanto adjustment α is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.func_H_T","page":"Interest Rates Models","title":"DiffFusion.func_H_T","text":"func_H_T(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nCalculate H function for component model.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.func_H_T_dense","page":"Interest Rates Models","title":"DiffFusion.func_H_T_dense","text":"func_H_T_dense(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nAlternative H function implementation for debugging.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.func_Sigma_T","page":"Interest Rates Models","title":"DiffFusion.func_Sigma_T","text":"func_Sigma_T(\n    chi::AbstractVector,\n    sigmaT::Function,\n    s::ModelTime,\n    t::ModelTime\n    )\n\nCalculate Σ(u)^top function for component model.\n\nIn this function we assume for the interval (st) that     - volatility σ is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#Model-Functions-for-Payoff-Evaluation","page":"Interest Rates Models","title":"Model Functions for Payoff Evaluation","text":"","category":"section"},{"location":"models/rates_models/#DiffFusion.log_bank_account","page":"Interest Rates Models","title":"DiffFusion.log_bank_account","text":"log_bank_account(m::Model, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the integral over sum of state variables s(t) from interest rate model.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_bank_account(m::CompositeModel, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the integral over sum of state variables s(t) from interest rate model.\n\n\n\n\n\nlog_bank_account(m::GaussianHjmModel, model_alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the integral over sum of state variables s(t) from interest rate model.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.log_zero_bond","page":"Interest Rates Models","title":"DiffFusion.log_zero_bond","text":"log_zero_bond(m::Model, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the zero bond term [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_zero_bond(m::CompositeModel, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the zero bond term [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\n\n\n\n\nlog_zero_bond(m::GaussianHjmModel, model_alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the zero bond term [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.log_zero_bonds","page":"Interest Rates Models","title":"DiffFusion.log_zero_bonds","text":"log_zero_bonds(m::Model, alias::String, t::ModelTime, T::AbstractVector, X::ModelState)\n\nCalculate the zero bond terms [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\n\n\n\n\nlog_zero_bonds(m::CompositeModel, alias::String, t::ModelTime, T::AbstractVector, X::ModelState)\n\nCalculate the zero bond terms [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\n\n\n\n\nlog_zero_bonds(m::GaussianHjmModel, model_alias::String, t::ModelTime, T::AbstractVector, X::ModelState)\n\nCalculate the zero bond terms [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.log_compounding_factor","page":"Interest Rates Models","title":"DiffFusion.log_compounding_factor","text":"log_compounding_factor(\n    m::Model,\n    model_alias::String,\n    t::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the forward compounding factor term [G(t,T2) - G(t,T1)]' x(t) + 0.5 * [G(t,T2)' y(t) G(t,T2) - G(t,T1)' y(t) G(t,T1)].\n\nThis is used for Libor forward rate calculation.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_compounding_factor(\n    m::CompositeModel,\n    alias::String,\n    t::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the forward compounding factor term [G(t,T2) - G(t,T1)]' x(t) + 0.5 * [G(t,T2)' y(t) G(t,T2) - G(t,T1)' y(t) G(t,T1)].\n\nThis is used for Libor forward rate calculation.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_compounding_factor(\n    m::GaussianHjmModel,\n    model_alias::String,\n    t::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the forward compounding factor term [G(t,T2) - G(t,T1)]' x(t) + 0.5 * [G(t,T2)' y(t) G(t,T2) - G(t,T1)' y(t) G(t,T1)].\n\nThis is used for Libor forward rate calculation.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.forward_rate_variance","page":"Interest Rates Models","title":"DiffFusion.forward_rate_variance","text":"forward_rate_variance(\n    m::Model,\n    alias::String,\n    t::ModelTime,\n    T::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    )\n\nCalculate the lognormal variance for a compounding factor of a forward-looking or backward-looking forward rate.\n\n\n\n\n\nforward_rate_variance(\n    m::CompositeModel,\n    alias::String,\n    t::ModelTime,\n    T::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    )\n\nCalculate the lognormal variance for a compounding factor of a forward-looking or backward-looking forward rate.\n\n\n\n\n\nforward_rate_variance(\n    m::GaussianHjmModel,\n    t::ModelTime,\n    T::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    )\n\nCalculate the lognormal variance for a compounding factor of a forward-looking or backward-looking forward rate.\n\nTime t is the observation time, T is the rate fixing time or option exercise time, T0 is the rate period start time, and T1 is the rate period end time.\n\nIf t ≤ T0 then we calculate the variance for a forward-looking rate. If t = T1 then we calculate the variance for a backward-looking rate.\n\n\n\n\n\nforward_rate_variance(\n    m::GaussianHjmModel,\n    alias::String,\n    t::ModelTime,\n    T::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    )\n\nCalculate the lognormal variance for a compounding factor of a forward-looking or backward-looking forward rate.\n\nThis function implements the Model interface function.\n\n\n\n\n\nforward_rate_variance(\np::AbstractPath,\nt::ModelTime,\nT::ModelTime,\nT0::ModelTime,\nT1::ModelTime,\nkey::String,\n)\n\nCalculate the lognormal variance for a compounding factor of a forward-looking or backward-looking forward rate.\n\n\n\n\n\nforward_rate_variance(\np::Path,\nt::ModelTime,\nT::ModelTime,\nT0::ModelTime,\nT1::ModelTime,\nkey::String,\n)\n\nCalculate the lognormal variance for a compounding factor of a forward-looking or backward-looking forward rate.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.swap_rate_variance","page":"Interest Rates Models","title":"DiffFusion.swap_rate_variance","text":"swap_rate_variance(\n    m::Model,\n    alias::String,\n    yts::YieldTermstructure,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    X::ModelState,\n    )\n\nCalculate the normal model variance of a swap rate via Gaussian swap rate approximation.\n\n\n\n\n\nswap_rate_variance(\n    m::CompositeModel,\n    alias::String,\n    yts::YieldTermstructure,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    X::ModelState,\n    )\n\nCalculate the normal model variance of a swap rate via Gaussian swap rate approximation.\n\n\n\n\n\nswap_rate_variance(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    SX::ModelState,\n    )\n\nCalculate the normal model variance of a swap rate via Gaussian swap rate approximation.\n\nObservation time is t, Option expiry time is T.\n\nSee method swap_rate_gradient for details on further input parameters.\n\n\n\n\n\nswap_rate_variance(\n    m::GaussianHjmModel,\n    alias::String,\n    yts::YieldTermstructure,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    X::ModelState,\n    )\n\nCalculate the normal model variance of a swap rate via Gaussian swap rate approximation.\n\nThis function is implements the Model interface function.\n\nSee method swap_rate_gradient for details on further input parameters.\n\n\n\n\n\nswap_rate_variance(\n    p::AbstractPath,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    key::String,\n    )\n\nCalculate the normal model variance of a swap rate via Gaussian swap rate approximation.\n\n\n\n\n\nswap_rate_variance(\n    p::Path,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    key::String,\n    )\n\nCalculate the normal model variance of a swap rate via Gaussian swap rate approximation.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#Swap-Rate-Volatility-Calculation","page":"Interest Rates Models","title":"Swap Rate Volatility Calculation","text":"","category":"section"},{"location":"models/rates_models/#DiffFusion.GaussianHjmModelVolatility","page":"Interest Rates Models","title":"DiffFusion.GaussianHjmModelVolatility","text":"struct GaussianHjmModelVolatility\n    scaling_matrix::AbstractMatrix\n    sigma_f::BackwardFlatVolatility\n    DfT::AbstractMatrix\nend\n\nA dedicated matrix-valued volatility term structure for Gaussian HJM Models.\n\n\n\n\n\n","category":"type"},{"location":"models/rates_models/#DiffFusion.swap_rate_gradient","page":"Interest Rates Models","title":"DiffFusion.swap_rate_gradient","text":"swap_rate_gradient(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    t::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    SX::ModelState,\n    )\n\nThe gradient dS/dx in a Gaussian HJM model.\n\nReturns a matrix of size (p, d). Here, p is the number of paths in SX and d is the number of factors of the GHJM model, i.e., d = length(factor_alias(m)).\n\nObservation time is t. The swap rate is specified by swap_times and yf_weights. swap_times[begin] is the start time of the first (floating rate) coupon period. swap_times[k] for k>begin represent the pay times of the fixed leg coupons. yf_weights are the year fractions of the fixed leg coupons.\n\nThe swap rate is constructed assuming single-curve setting without tenor basis. yts is the initial (discounting) yield curve.\n\nThe swap rate gradient depends on the simulated model state at t. The model state is encoded in SX.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.swap_rate_instantaneous_covariance","page":"Interest Rates Models","title":"DiffFusion.swap_rate_instantaneous_covariance","text":"swap_rate_instantaneous_covariance(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    t::ModelTime,\n    swap_times_1::AbstractVector,\n    yf_weights_1::AbstractVector,\n    swap_times_2::AbstractVector,\n    yf_weights_2::AbstractVector,\n    SX::ModelState,\n    )\n\nCalculate the instantaneous covariance of two swap rates.\n\nSee method swap_rate_gradient for details on the input parameters.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.swap_rate_volatility²","page":"Interest Rates Models","title":"DiffFusion.swap_rate_volatility²","text":"swap_rate_volatility²(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    t::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    SX::ModelState,\n    )\n\nCalculate the square of swap rate volatility (or instantaneous variance).\n\nSee method swap_rate_gradient for details on the input parameters.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.swap_rate_covariance","page":"Interest Rates Models","title":"DiffFusion.swap_rate_covariance","text":"swap_rate_covariance(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times_1::AbstractVector,\n    yf_weights_1::AbstractVector,\n    swap_times_2::AbstractVector,\n    yf_weights_2::AbstractVector,\n    SX::ModelState,\n    )\n\nCalculate the covariance of two swap rates over the time intervall (t,T).\n\nSee method swap_rate_gradient for details on the input parameters.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.swap_rate_correlation","page":"Interest Rates Models","title":"DiffFusion.swap_rate_correlation","text":"swap_rate_correlation(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times_1::AbstractVector,\n    yf_weights_1::AbstractVector,\n    swap_times_2::AbstractVector,\n    yf_weights_2::AbstractVector,\n    SX::ModelState,\n    )\n\nCalculate the correlation of two swap rates via Gaussian swap rate approximation over the time intervall (t,T).\n\nSee method swap_rate_gradient for details on further input parameters.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#DiffFusion.model_implied_volatilties","page":"Interest Rates Models","title":"DiffFusion.model_implied_volatilties","text":"model_implied_volatilties(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    option_times::AbstractVector,\n    swap_times::AbstractMatrix,\n    swap_weights::AbstractMatrix,\n    SX::Union{ModelState, Nothing} = nothing\n    )\n\nCalculate model-implied swap rate volatilities in Gaussian HJM model.\n\noption_times are the option expiry times.\n\nswap_times is a matrix of vectors. Each element represents swap times as specified in swap_rate_gradient.\n\nswap_weights is a matrix of vectors. Each element represents year fraction weights as specified in swap_rate_gradient.\n\nSee method swap_rate_gradient for details on further input parameters.\n\n\n\n\n\nmodel_implied_volatilties(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    option_times::AbstractVector,\n    swap_times::AbstractVector,\n    swap_weights::AbstractVector,\n    SX::Union{ModelState, Nothing} = nothing\n    )\n\nCalculate model-implied swap rate volatilities in Gaussian HJM model.\n\noption_times are the option expiry times.\n\nswap_times is a vector of vectors. Each element represents time offsets that are added to option_times in order to form swap_times as specified in swap_rate_gradient.\n\nswap_weights is a vector of vectors. Each element represents year fraction weights as specified in swap_rate_gradient. swap_weights are assumed equal per expiry time.\n\nSee method swap_rate_gradient for details on further input parameters.\n\n\n\n\n\nmodel_implied_volatilties(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    option_times::AbstractVector,\n    swap_maturities::AbstractVector,\n    SX::Union{ModelState, Nothing} = nothing\n    )\n\nCalculate model-implied swap rate volatilities in Gaussian HJM model.\n\noption_times are the option expiry times.\n\nswap_maturities is a list of swap tenors. Swap times and year fraction weights are calculated from swap_maturities assuming an annual schedule.\n\nSee method swap_rate_gradient for details on further input parameters.\n\n\n\n\n\nmodel_implied_volatilties(\n    ast_model::LognormalAssetModel,\n    dom_model::Union{GaussianHjmModel, Nothing},\n    for_model::Union{GaussianHjmModel, Nothing},\n    ch::CorrelationHolder,\n    option_times::AbstractVector,\n    )\n\nCalculate model-implied volatilities in hybrid asset model.\n\n\n\n\n\n","category":"function"},{"location":"models/rates_models/#Model-Calibration","page":"Interest Rates Models","title":"Model Calibration","text":"","category":"section"},{"location":"models/rates_models/#DiffFusion.gaussian_hjm_model-Tuple{String, Union{Nothing, DiffFusion.CorrelationHolder}, AbstractVector, AbstractVector, AbstractMatrix, DiffFusion.YieldTermstructure}","page":"Interest Rates Models","title":"DiffFusion.gaussian_hjm_model","text":"gaussian_hjm_model(\n    alias::String,\n    ch::Union{CorrelationHolder, Nothing},\n    option_times::AbstractVector,\n    swap_maturities::AbstractVector,\n    swap_rate_volatilities::AbstractMatrix,\n    yts::YieldTermstructure;\n    max_iter::Integer = 5,\n    volatility_regularisation::ModelValue = 0.0,\n    scaling_type::BenchmarkTimesScaling = _default_benchmark_time_scaling,\n    )\n\nCalibrate a model with flat volatilities and mean reversion to strips of co-initial normal volatilities.\n\n\n\n\n\n","category":"method"},{"location":"models/rates_models/#DiffFusion.gaussian_hjm_model-Tuple{String, DiffFusion.ParameterTermstructure, DiffFusion.ParameterTermstructure, Union{Nothing, DiffFusion.CorrelationHolder}, AbstractVector, AbstractVector, AbstractMatrix, DiffFusion.YieldTermstructure}","page":"Interest Rates Models","title":"DiffFusion.gaussian_hjm_model","text":"gaussian_hjm_model(\n    alias::String,\n    delta::ParameterTermstructure,\n    chi::ParameterTermstructure,\n    ch::Union{CorrelationHolder, Nothing},\n    option_times::AbstractVector,\n    swap_maturities::AbstractVector,\n    swap_rate_volatilities::AbstractMatrix,\n    yts::YieldTermstructure;\n    max_iter::Integer = 5,\n    volatility_regularisation::ModelValue = 0.0,\n    scaling_type::BenchmarkTimesScaling = _default_benchmark_time_scaling,\n    )\n\nCalibrate a model with piece-wise constant volatilities to strips of co-initial normal volatilities.\n\nMean reversion (and correlations) are exogeneously specified.\n\n\n\n\n\n","category":"method"},{"location":"examples/examples/#Example-Models-and-Portfolios","page":"Example Models and Portfolios","title":"Example Models and Portfolios","text":"","category":"section"},{"location":"examples/examples/","page":"Example Models and Portfolios","title":"Example Models and Portfolios","text":"We add example models, term structures, pricing context and product configurations in an Examples sub-module. The examples are encoded as YAML files. They should help users to easily set up simulations for ad-hoc testing and analysis.","category":"page"},{"location":"examples/examples/","page":"Example Models and Portfolios","title":"Example Models and Portfolios","text":"In this section we document data and functions to work with the product and model examples.","category":"page"},{"location":"examples/examples/#DiffFusion.Examples._yaml_path","page":"Example Models and Portfolios","title":"DiffFusion.Examples._yaml_path","text":"const _yaml_path = @__DIR__\n\nThe path of example CSV files.\n\n\n\n\n\n","category":"constant"},{"location":"examples/examples/#DiffFusion.Examples._csv_path","page":"Example Models and Portfolios","title":"DiffFusion.Examples._csv_path","text":"const _csv_path = @__DIR__\n\nThe path of example CSV files.\n\n\n\n\n\n","category":"constant"},{"location":"examples/examples/#DiffFusion.Examples.examples","page":"Example Models and Portfolios","title":"DiffFusion.Examples.examples","text":"A list of example models and instrument specifications.\n\n\n\n\n\n","category":"constant"},{"location":"examples/examples/#DiffFusion.Examples.load","page":"Example Models and Portfolios","title":"DiffFusion.Examples.load","text":"load(name::String)\n\nReturn a list of dictionaries representing a DiffFusion example.\n\nExample details can be modified by changing the dictionary entries.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.build","page":"Example Models and Portfolios","title":"DiffFusion.Examples.build","text":"build(dict_list::Vector{OrderedDict{String, Any}})\n\nReturn a dictionary of objects and configurations representing a DiffFusion example.\n\nThe resulting dictionary is supposed to be queried and amended by methods operating on examples.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.get_object","page":"Example Models and Portfolios","title":"DiffFusion.Examples.get_object","text":"Return the first object of a given type from an example dictionary.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#Model-Setup","page":"Example Models and Portfolios","title":"Model Setup","text":"","category":"section"},{"location":"examples/examples/#DiffFusion.Examples.model","page":"Example Models and Portfolios","title":"DiffFusion.Examples.model","text":"model(example::OrderedDict{String,Any})\n\nReturn the hybrid model of an example.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.correlation_holder","page":"Example Models and Portfolios","title":"DiffFusion.Examples.correlation_holder","text":"correlation_holder(example::OrderedDict{String,Any})\n\nReturn the correlation holder of an example.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.context","page":"Example Models and Portfolios","title":"DiffFusion.Examples.context","text":"context(example::OrderedDict{String,Any})\n\nReturn the context of a given example.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.term_structures","page":"Example Models and Portfolios","title":"DiffFusion.Examples.term_structures","text":"term_structures(example::OrderedDict{String,Any})\n\nReturn a dictionary of term structures for an example.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.simulation!","page":"Example Models and Portfolios","title":"DiffFusion.Examples.simulation!","text":"simulation!(example::OrderedDict{String,Any})\n\nReturn a Monte Carlo simulation for a given example.\n\nIf no simulation exists it is created.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.path!","page":"Example Models and Portfolios","title":"DiffFusion.Examples.path!","text":"path!(example::OrderedDict{String,Any})\n\nReturn a Monte Carlo path for a given example.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#Product-Setup","page":"Example Models and Portfolios","title":"Product Setup","text":"","category":"section"},{"location":"examples/examples/#DiffFusion.Examples.fixed_rate_leg","page":"Example Models and Portfolios","title":"DiffFusion.Examples.fixed_rate_leg","text":"fixed_rate_leg(\n    alias::String,\n    effective_time::ModelTime,\n    maturity_time::ModelTime,\n    coupons_per_year::Int,\n    fixed_rate::ModelValue,\n    notional::ModelValue,\n    discount_curve_key::String,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a fixed rate cash flow leg.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.simple_rate_leg","page":"Example Models and Portfolios","title":"DiffFusion.Examples.simple_rate_leg","text":"simple_rate_leg(\n    alias::String,\n    effective_time::ModelTime,\n    maturity_time::ModelTime,\n    coupons_per_year::Int,\n    forward_curve_key::String,\n    fixing_key::Union{String, Nothing},\n    spread_rate::Union{ModelValue, Nothing},\n    notional::ModelValue,\n    discount_curve_key::String,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a Libor cash flow leg.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.compounded_rate_leg","page":"Example Models and Portfolios","title":"DiffFusion.Examples.compounded_rate_leg","text":"compounded_rate_leg(\n    alias::String,\n    effective_time::ModelTime,\n    maturity_time::ModelTime,\n    coupons_per_year::Int,\n    forward_curve_key::String,\n    fixing_key::Union{String, Nothing},\n    spread_rate::Union{ModelValue, Nothing},\n    notional::ModelValue,\n    discount_curve_key::String,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a RFR compounded leg.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.random_swap","page":"Example Models and Portfolios","title":"DiffFusion.Examples.random_swap","text":"random_swap(example::OrderedDict{String,Any}, type_key::Union{String,Nothing} = nothing)\n\nSample a random swap.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.random_swaption","page":"Example Models and Portfolios","title":"DiffFusion.Examples.random_swaption","text":"random_swaption(\n    example::OrderedDict{String,Any},\n    type_key::Union{String,Nothing} = nothing,\n    )\n\nSample a random European swaption.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.random_bermudan","page":"Example Models and Portfolios","title":"DiffFusion.Examples.random_bermudan","text":"random_bermudan(\n    example::OrderedDict{String,Any},\n    type_key::Union{String,Nothing} = nothing,\n    )\n\nSample a random Bermudan swaption.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.portfolio!","page":"Example Models and Portfolios","title":"DiffFusion.Examples.portfolio!","text":"portfolio!(\n    example::OrderedDict{String,Any},\n    n_swaps::Int = 10,\n    n_swaptions::Int = 0,\n    )\n\nCreate a portfolio of swaps and swaptions and store it in the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.display_portfolio","page":"Example Models and Portfolios","title":"DiffFusion.Examples.display_portfolio","text":"Print portfolio in terminal.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#DiffFusion.Examples.scenarios!","page":"Example Models and Portfolios","title":"DiffFusion.Examples.scenarios!","text":"scenarios!(example::OrderedDict{String,Any})\n\nCreate the exposure scenarios for the portfolio.\n\n\n\n\n\n","category":"function"},{"location":"models/cross_asset_models/#Cross-Asset-Hybrid-Models","page":"Cross Asset Hybrid Models","title":"Cross Asset Hybrid Models","text":"","category":"section"},{"location":"models/cross_asset_models/#Cross-Asset-Hybrid-Model-Types","page":"Cross Asset Hybrid Models","title":"Cross Asset Hybrid Model Types","text":"","category":"section"},{"location":"models/cross_asset_models/#DiffFusion.CompositeModel","page":"Cross Asset Hybrid Models","title":"DiffFusion.CompositeModel","text":"abstract type CompositeModel <: Model\n\nA CompositeModel represents a collection of (coupled) component models.\n\nCompositeModels are supposed to hold the following elements\n\nalias::String\nmodels::Tuple\nstate_alias\nfactor_alias\nmodel_dict::Dict{String,Int}\n\nFor concrete types, see SimpleModel and DiagonalModel.\n\n\n\n\n\n","category":"type"},{"location":"models/cross_asset_models/#DiffFusion.SimpleModel","page":"Cross Asset Hybrid Models","title":"DiffFusion.SimpleModel","text":"struct SimpleModel <: Model\n    alias::String\n    models::Tuple\n    state_alias\n    factor_alias\n    model_dict::Dict{String,Int}\nend\n\nA SimpleModel represents a collection of (coupled) state-independent component models.\n\nIt is supposed to be used with a simple_simulation() method.\n\n\n\n\n\n","category":"type"},{"location":"models/cross_asset_models/#DiffFusion.simple_model","page":"Cross Asset Hybrid Models","title":"DiffFusion.simple_model","text":"simple_model(alias::String, models::AbstractVector)\n\nCreate a SimpleModel.\n\n\n\n\n\n","category":"function"},{"location":"models/cross_asset_models/#DiffFusion.DiagonalModel","page":"Cross Asset Hybrid Models","title":"DiffFusion.DiagonalModel","text":"DiagonalModel represents a collection of (coupled) component models. For the component models we assume that the models are either state-independent models or diagonal models in the sense that the correlation matrix is state-independent.\n\nFor state-independent models we avoid repeated Theta and Sigma calculation.\n\nThe model is used as a hybrid model for simulation and payoff evaluation.\n\n\n\n\n\n","category":"type"},{"location":"models/cross_asset_models/#DiffFusion.diagonal_model","page":"Cross Asset Hybrid Models","title":"DiffFusion.diagonal_model","text":"diagonal_model(alias::String, models::AbstractVector)\n\nCreate a DiagonalModel.\n\n\n\n\n\n","category":"function"},{"location":"payoffs/payoffs/#Payoffs","page":"Payoffs","title":"Payoffs","text":"","category":"section"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"In this section we document the payoff scripting framework.","category":"page"},{"location":"payoffs/payoffs/#Interface","page":"Payoffs","title":"Interface","text":"","category":"section"},{"location":"payoffs/payoffs/#DiffFusion.Payoff","page":"Payoffs","title":"DiffFusion.Payoff","text":"abstract type Payoff end\n\nA Payoff is a random variable X in our stochastic model.\n\nIt represents a market object that can be evaluated in conjunction with a given path.\n\nWe are interested in realisations of a payoff at a given path, i.e. X(omega). Moreover, for risk-neutral valuation we are also interested in discounted payoffs at a given path.\n\nWe implement a Payoff as a root of a computational graph. The nodes of the computational graph are itself Payoff objects which represent mathematical operations or use the path omega to determine its realisations.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Leaf","page":"Payoffs","title":"DiffFusion.Leaf","text":"abstract type Leaf <: Payoff end\n\nA Leaf is a particular Payoff which has no outgoing links to other Payoff objects. A Leaf typically uses the path to determine its realisations.\n\nWe assume that a Leaf has a field obs_time.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.UnaryNode","page":"Payoffs","title":"DiffFusion.UnaryNode","text":"abstract type UnaryNode <: Payoff end\n\nA UnaryNode is a particular Payoff which has exactly one outgoing link to another Payoff object.\n\nWe assume that the reference to the outgoing Payoff object is a field denoted x.\n\nA UnaryNode is typically a decorator of the linked Payoff.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.BinaryNode","page":"Payoffs","title":"DiffFusion.BinaryNode","text":"abstract type BinaryNode <: Payoff end\n\nA BinaryNode is a particular Payoff which has exactly two outgoing links to other Payoff objects.\n\nWe assume that the references to the outgoing Payoff objects are fields denoted x and y.\n\nA BinaryNode is typically a mathematical operation.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.obs_time-Tuple{DiffFusion.Payoff}","page":"Payoffs","title":"DiffFusion.obs_time","text":"obs_time(p::Payoff)\n\nA Payoff is typically observed at a particular time. In that sense, a Payoff is an F_t-measurable random variable.\n\nThe observation time represents the time, after which the payoff is known.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/payoffs/#DiffFusion.obs_times-Tuple{DiffFusion.Payoff}","page":"Payoffs","title":"DiffFusion.obs_times","text":"obs_times(p::Payoff)\n\nA payoff is typically linked to other payoffs and forms a DAG. This function returns all observation times associated with a given payoff.\n\nThis functionality is required to determine relevant simulation grid points.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/payoffs/#DiffFusion.at-Tuple{DiffFusion.Payoff, DiffFusion.AbstractPath}","page":"Payoffs","title":"DiffFusion.at","text":"at(p::Payoff, path::AbstractPath)\n\nEvaluate a Payoff at a given path, X(omega).\n\nDepending on the functionality associated with the path, this function typically returns a vector of realisations.\n\nThis function is invoked when using call operator on a Payoff,\n\n(p::Payoff)(path::AbstractPath) = at(p::Payoff, path::AbstractPath)\n\n\n\n\n\n","category":"method"},{"location":"payoffs/payoffs/#Basic-Payoffs","page":"Payoffs","title":"Basic Payoffs","text":"","category":"section"},{"location":"payoffs/payoffs/#DiffFusion.Fixed","page":"Payoffs","title":"DiffFusion.Fixed","text":"struct Fixed <: Leaf\n    value::ModelValue\nend\n\nA deterministic quantity.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.ScalarValue","page":"Payoffs","title":"DiffFusion.ScalarValue","text":"struct ScalarValue <: Leaf\n    value::ModelValue\nend\n\nA scalar deterministic quantity.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Pay","page":"Payoffs","title":"DiffFusion.Pay","text":"struct Pay <: UnaryNode\n    x::Payoff\n    obs_time::ModelTime\n    test_times::Bool\nend\n\nA Pay payoff allows the user to modify the observation time of a given payoff. This is relevant for discounting.\n\nTypically, we use Pay to specify the pay time for a payoff.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Cache","page":"Payoffs","title":"DiffFusion.Cache","text":"mutable struct Cache <: UnaryNode\n    x::Payoff\n    path::Union{AbstractPath, Nothing}\n    value::Union{AbstractVector, Nothing}\nend\n\nA Cache payoff aims at avoiding repeated calculations of the same payoff.\n\nIf a Payoff object is referenced by several parent Payoff objects then each call of at() of the parent object triggers a call of at() of the child object that all return the same value(s).\n\nA Cache payoff checks whether the payoff was already evaluated and if yes then returns a cached value.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#Mathematical-Operations","page":"Payoffs","title":"Mathematical Operations","text":"","category":"section"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"The following payoffs are created by operator overloading of +, -, *, / and logical operators.","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Add","page":"Payoffs","title":"DiffFusion.Add","text":"struct Add <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nAddition of payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Sub","page":"Payoffs","title":"DiffFusion.Sub","text":"struct Sub <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nSubtraction of payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Mul","page":"Payoffs","title":"DiffFusion.Mul","text":"struct Mul <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nMultiplication of payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Div","page":"Payoffs","title":"DiffFusion.Div","text":"struct Div <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nDivision of payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Logical","page":"Payoffs","title":"DiffFusion.Logical","text":"struct Logical <: BinaryNode\n    x::Payoff\n    y::Payoff\n    op::String\nend\n\nLogical operations\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#Mathematical-Functions","page":"Payoffs","title":"Mathematical Functions","text":"","category":"section"},{"location":"payoffs/payoffs/#DiffFusion.Exp","page":"Payoffs","title":"DiffFusion.Exp","text":"struct Exp <: UnaryNode\n    x::Payoff\nend\n\nFunction exp() applied to payoff.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Log","page":"Payoffs","title":"DiffFusion.Log","text":"struct Log <: UnaryNode\n    x::Payoff\nend\n\nFunction log() applied to payoff.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Max","page":"Payoffs","title":"DiffFusion.Max","text":"struct Max <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nPath-wise maximum\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#DiffFusion.Min","page":"Payoffs","title":"DiffFusion.Min","text":"struct Min <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nPath-wise minimum\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#Common-Payoff-Methods-Overview","page":"Payoffs","title":"Common Payoff Methods Overview","text":"","category":"section"},{"location":"payoffs/payoffs/#DiffFusion.obs_time","page":"Payoffs","title":"DiffFusion.obs_time","text":"obs_time(p::Payoff)\n\nA Payoff is typically observed at a particular time. In that sense, a Payoff is an F_t-measurable random variable.\n\nThe observation time represents the time, after which the payoff is known.\n\n\n\n\n\nobs_time(p::Leaf)\n\nReturn the observation time for a Leaf object.\n\n\n\n\n\nobs_time(p::UnaryNode)\n\nReturn the observation time of the linked payoff.\n\n\n\n\n\nobs_time(p::BinaryNode)\n\nDerive the observation time from linked payoffs.\n\n\n\n\n\nobs_time(p::Fixed)\n\nObservation time for Fixed payoffs is zero because they are deterministic.\n\n\n\n\n\nobs_time(p::ScalarValue)\n\nObservation time for ScalarValue payoffs is zero because they are deterministic.\n\n\n\n\n\nobs_time(p::Pay)\n\nReturn decorating observation time.\n\n\n\n\n\nobs_time(p::CompoundedRate)\n\nCalculate observation time for CompoundedRate payoff.\n\n\n\n\n\nobs_time(p::Optionlet)\n\nReturn Optionlet observation time.\n\n\n\n\n\nobs_time(p::Swaption)\n\nReturn Swaption observation time.\n\n\n\n\n\nobs_time(p::AmcPayoff)\n\nReturn the AMC payoff observation time\n\n\n\n\n\nobs_time(p::VanillaAssetOption)\n\nReturn VanillaAssetOption observation time.\n\n\n\n\n\nobs_time(p::BarrierAssetOption)\n\nReturn BarrierAssetOption observation time.\n\n\n\n\n\n","category":"function"},{"location":"payoffs/payoffs/#DiffFusion.obs_times","page":"Payoffs","title":"DiffFusion.obs_times","text":"obs_times(p::Payoff)\n\nA payoff is typically linked to other payoffs and forms a DAG. This function returns all observation times associated with a given payoff.\n\nThis functionality is required to determine relevant simulation grid points.\n\n\n\n\n\nobs_times(p::Leaf)\n\nDerive the set of observation times from the single observation time of the Leaf object.\n\n\n\n\n\nobs_times(p::UnaryNode)\n\nReturn all observation times of the linked payoff.\n\n\n\n\n\nobs_times(p::BinaryNode)\n\nDerive all observation times from linked payoff.\n\n\n\n\n\nobs_times(p::Pay)\n\nReturn all observation times of the linked payoff.\n\n\n\n\n\nobs_times(p::CompoundedRate)\n\nCalculate all observation times (i.e. event times) for CompoundedRate payoff.\n\n\n\n\n\nobs_times(p::Optionlet)\n\nReturn all Optionlet observation times. \n\n\n\n\n\nobs_times(p::Swaption)\n\nReturn all Swaption observation times.\n\n\n\n\n\nobs_times(p::AmcPayoff)\n\nReturn observation times of all referenced payoffs.\n\n\n\n\n\nobs_times(p::VanillaAssetOption)\n\nReturn all VanillaAssetOption observation times. \n\n\n\n\n\nobs_times(p::BarrierAssetOption)\n\nReturn all BarrierAssetOption observation times. \n\n\n\n\n\n","category":"function"},{"location":"payoffs/payoffs/#DiffFusion.at","page":"Payoffs","title":"DiffFusion.at","text":"at(p::Payoff, path::AbstractPath)\n\nEvaluate a Payoff at a given path, X(omega).\n\nDepending on the functionality associated with the path, this function typically returns a vector of realisations.\n\nThis function is invoked when using call operator on a Payoff,\n\n(p::Payoff)(path::AbstractPath) = at(p::Payoff, path::AbstractPath)\n\n\n\n\n\nat(p::Numeraire, path::AbstractPath)\n\nDerive the numeraire price at a given path.\n\n\n\n\n\nat(p::BankAccount, path::AbstractPath)\n\nDerive the bank account price at a given path.\n\n\n\n\n\nat(p::ZeroBond, path::AbstractPath)\n\nDerive the zero bond price at a given path.\n\n\n\n\n\nat(p::Asset, path::AbstractPath)\n\nDerive the asset price at a given path.\n\n\n\n\n\nat(p::ForwardAsset, path::AbstractPath)\n\nDerive the asset price at a given path.\n\n\n\n\n\nat(p::Fixing, path::AbstractPath)\n\nDerive the fixing value at a given path.\n\n\n\n\n\nat(p::Fixed, path::AbstractPath)\n\nReturn the deterministic value broadcasted to the length of the path.\n\n\n\n\n\nat(p::ScalarValue, path::AbstractPath)\n\nReturn the deterministic scalar value.\n\nThis aims at avoiding some unnecessary allocations.\n\n\n\n\n\nat(p::AssetConvexityAdjustment, path::AbstractPath)\n\nDerive the YoY payoff convexity adjustment at a given path.\n\n\n\n\n\nat(p::ForwardIndex, path::AbstractPath)\n\nDerive forward index value at a given path.\n\n\n\n\n\nat(p::IndexConvexityAdjustment, path::AbstractPath)\n\nDerive the YoY payoff convexity adjustment at a given path.\n\n\n\n\n\nat(p::FutureIndex, path::AbstractPath)\n\nDerive forward index value at a given path.\n\n\n\n\n\nat(p::Pay, path::AbstractPath)\n\nDerive payoff of the child payoff.\n\n\n\n\n\nat(p::Cache, path::AbstractPath)\n\nDerive payoff of the child payoff only if not yet calculated.\n\n\n\n\n\nat(p::Exp, path::AbstractPath)\n\nEvaluate exp-function.\n\n\n\n\n\nat(p::Log, path::AbstractPath)\n\nEvaluate log-function.\n\n\n\n\n\nAddition.\n\n\n\n\n\nSubtraction.\n\n\n\n\n\nMultiplication.\n\n\n\n\n\nDivision.\n\n\n\n\n\nMaximum\n\n\n\n\n\nMinimum\n\n\n\n\n\nLogical\n\n\n\n\n\nat(p::LiborRate, path::AbstractPath)\n\nDerive the forward Libor rate at a given path.\n\n\n\n\n\nat(p::CompoundedRate, path::AbstractPath)\n\nDerive the compounded backward looking rate at a given path.\n\n\n\n\n\nat(p::Optionlet, path::AbstractPath)\n\nEvaluate a Optionlet at a given path, X(omega).\n\n\n\n\n\nat(p::Swaption, path::AbstractPath)\n\nEvaluate a Swaption at a given path, X(omega).\n\n\n\n\n\nat(links::AmcPayoffLinks, regr::AmcPayoffRegression, path::AbstractPath)\n\nCalculate the common components of AMC payoffs for a given valuation path.\n\n\n\n\n\nat(p::AmcMax, path::AbstractPath)\n\nEvaluate an AmcMax payoff at a given path.\n\n\n\n\n\nat(p::AmcMin, path::AbstractPath)\n\nEvaluate an AmcMin payoff at a given path.\n\n\n\n\n\nat(p::AmcOne, path::AbstractPath)\n\nEvaluate an AmcOne payoff at a given path.\n\n\n\n\n\nat(p::AmcSum, path::AbstractPath)\n\nEvaluate an AmcSum payoff at a given path.\n\n\n\n\n\nat(p::VanillaAssetOption, path::AbstractPath)\n\nEvaluate a VanillaAssetOption at a given path, X(omega).\n\n\n\n\n\nat(p::BarrierAssetOption, path::AbstractPath)\n\nEvaluate a BarrierAssetOption at a given path, X(omega).\n\n\n\n\n\n","category":"function"},{"location":"payoffs/payoffs/#Base.string","page":"Payoffs","title":"Base.string","text":"string(p::Numeraire)\n\nFormatted (and shortened) output for Numeraire payoff.\n\n\n\n\n\nstring(p::BankAccount)\n\nFormatted (and shortened) output for BankAccount payoff.\n\n\n\n\n\nstring(p::ZeroBond)\n\nFormatted (and shortened) output for ZeroBond payoff.\n\n\n\n\n\nstring(p::Asset)\n\nFormatted (and shortened) output for Asset payoff.\n\n\n\n\n\nstring(p::ForwardAsset)\n\nFormatted (and shortened) output for ForwardAsset payoff.\n\n\n\n\n\nstring(p::Fixing)\n\nFormatted (and shortened) output for Fixing payoff.\n\n\n\n\n\nstring(p::Fixed)\n\nFormatted (and shortened) output for deterministic payoff.\n\n\n\n\n\nstring(p::ScalarValue)\n\nFormatted (and shortened) output for deterministic payoff.\n\n\n\n\n\nstring(p::AssetConvexityAdjustment)\n\nFormatted (and shortened) output for AssetConvexityAdjustment payoff.\n\n\n\n\n\nstring(p::ForwardIndex)\n\nFormatted (and shortened) output for ForwardIndex payoff.\n\n\n\n\n\nstring(p::IndexConvexityAdjustment)\n\nFormatted (and shortened) output for IndexConvexityAdjustment payoff.\n\n\n\n\n\nstring(p::FutureIndex)\n\nFormatted (and shortened) output for FutureIndex payoff.\n\n\n\n\n\nstring(p::Pay)\n\nFormatted (and shortened) output for Pay payoff.\n\n\n\n\n\nstring(p::Cache)\n\nFormatted (and shortened) output for Cache payoff.\n\n\n\n\n\nstring(p::Exp)\n\nFormatted output for Exp payoff.\n\n\n\n\n\nstring(p::Log)\n\nFormatted output for Log payoff.\n\n\n\n\n\nFormatted addition.\n\n\n\n\n\nFormatted subtraction.\n\n\n\n\n\nFormatted multiplication.\n\n\n\n\n\nFormatted division.\n\n\n\n\n\nFormatted maximum.\n\n\n\n\n\nFormatted minimum.\n\n\n\n\n\nFormatted logical.\n\n\n\n\n\nstring(p::LiborRate)\n\nFormatted (and shortened) output for LiborRate payoff.\n\n\n\n\n\nstring(p::CompoundedRate)\n\nFormatted (and shortened) output for CompoundedRate payoff.\n\n\n\n\n\nstring(p::Optionlet)\n\nFormatted (and shortened) output for Optionlet payoff.\n\n\n\n\n\nstring(p::Swaption)\n\nFormatted (and shortened) output for Swaption payoff.\n\n\n\n\n\nstring(links::AmcPayoffLinks)\n\nFormatted (and shortened) output for AMC payoff links.\n\n\n\n\n\nstring(p::AmcMax)\n\nFormatted (and shortened) output for AmcMax payoff.\n\n\n\n\n\nstring(p::AmcMin)\n\nFormatted (and shortened) output for AmcMin payoff.\n\n\n\n\n\nstring(p::AmcOne)\n\nFormatted (and shortened) output for AmcOne payoff.\n\n\n\n\n\nstring(p::AmcSum)\n\nFormatted (and shortened) output for AmcSum payoff.\n\n\n\n\n\nstring(p::VanillaAssetOption)\n\nFormatted (and shortened) output for VanillaAssetOption payoff.\n\n\n\n\n\nstring(p::VanillaAssetOption)\n\nFormatted (and shortened) output for VanillaAssetOption payoff.\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/#Analytics","page":"Analytics","title":"Analytics","text":"","category":"section"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"In this section we document additional analytic modelling functions.","category":"page"},{"location":"analytics/analytics/#Reference-Rate-Covariance-Calculations","page":"Analytics","title":"Reference Rate Covariance Calculations","text":"","category":"section"},{"location":"analytics/analytics/#DiffFusion.reference_rate_scaling","page":"Analytics","title":"DiffFusion.reference_rate_scaling","text":"reference_rate_scaling(\n    context_key::String,\n    term::ModelTime,\n    mdl::Model,\n    ctx::Context\n    )\n\nReturn the scaling vector of a reference rate.\n\nA reference rate is specified as a stochastic process random variable Y = A' X + b. Here, X reprsents the model state variable, A is the resulting scaling vector and b is a deterministic function (not relevant for this purpose).\n\nReference rates are continuous compounded zero rates and FX rates (or asset prices). Reference rates are identified by a context_key. In addition, zero rates are specified by a positive term. For FX rates we require term equal to zero.\n\nReference rates for other asset classes are to be added.\n\nThe model context ctx is used to identify corresponding model parameters and state variables of the model.\n\n\n\n\n\nreference_rate_scaling(\n    keys_and_terms::AbstractVector,\n    mdl::Model,\n    ctx::Context\n    )\n\nReturn the scaling matrix of a reference rates. The scaling matrix represents a list of scaling vectors represented as matrix.\n\nkeys_and_terms is a list of tuples. For each tuple, the first element represents the context_key of the reference rate. The second element represents the term of the reference rate.\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/#DiffFusion.reference_rate_covariance","page":"Analytics","title":"DiffFusion.reference_rate_covariance","text":"reference_rate_covariance(\n    Y1::AbstractVecOrMat,\n    Y2::AbstractVecOrMat,\n    mdl::Model,\n    ch::CorrelationHolder,\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nCalculate the covariance matrix for two vector or matrices of reference rates.\n\n\n\n\n\nreference_rate_covariance(\n    Y1::Tuple,\n    Y2::Tuple,\n    mdl::Model,\n    ch::CorrelationHolder,\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nCalculate the scalar covariance for two reference rates.\n\nReference rates are encoded as tuples Y1 and Y2. The first element of a tuple is the context_key. The second element of the tuple is the term.\n\n\n\n\n\nreference_rate_covariance(\n    keys_and_terms::AbstractVector,\n    ctx::Context,\n    mdl::Model,\n    ch::CorrelationHolder,\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nCalculate covariance matrix for a list of reference rates.\n\nkeys_and_terms is a list of tuples. For each tuple, the first element represents the context_key of the reference rate. The second element represents the term of the reference rate.\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/#DiffFusion.reference_rate_volatility_and_correlation","page":"Analytics","title":"DiffFusion.reference_rate_volatility_and_correlation","text":"reference_rate_volatility_and_correlation(\n    keys_and_terms::AbstractVector,\n    ctx::Context,\n    mdl::Model,\n    ch::CorrelationHolder,\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nCalculate the volatility vector and correlation matrix for a list of reference rates.\n\nkeys_and_terms is a list of tuples. For each tuple, the first element represents the context_key of the reference rate. The second element represents the term of the reference rate.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/correlations/#Correlations","page":"Correlations","title":"Correlations","text":"","category":"section"},{"location":"termstructures/correlations/#Correlation-Term-Structure-Type","page":"Correlations","title":"Correlation Term Structure Type","text":"","category":"section"},{"location":"termstructures/correlations/#DiffFusion.CorrelationTermstructure","page":"Correlations","title":"DiffFusion.CorrelationTermstructure","text":"abstract type CorrelationTermstructure <: Termstructure end\n\nAn abstract correlation term structure that provides methods to calculate instantaneous correlations.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/correlations/#DiffFusion.CorrelationHolder","page":"Correlations","title":"DiffFusion.CorrelationHolder","text":"struct CorrelationHolder <: CorrelationTermstructure\n    alias::String\n    correlations::Dict{String, ModelValue}\n    sep::String\n    value_type::DataType\nend\n\nA container holding correlation values.\n\nA CorrelationHolder allows to calculate correlation matrices based on String alias keys (identifiers).\n\nvalue_type specifies the type of correlation entries. This ensures that all values are of consistent type. This feature is required for correlation sensitivity calculation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/correlations/#DiffFusion.correlation_holder","page":"Correlations","title":"DiffFusion.correlation_holder","text":"correlation_holder(\n    alias::String,\n    correlations::Dict,\n    sep::String = \"<>\",\n    value_type::DataType = ModelValue,\n    )\n\nCreate a CorrelationHolder object from dictionary.\n\n\n\n\n\ncorrelation_holder(\n    alias::String,\n    sep::String = \"<>\",\n    value_type::DataType = ModelValue,\n    )\n\nCreate an empty CorrelationHolder object.\n\n\n\n\n\ncorrelation_holder(m::AssetModel)\n\nReturn the correlation holder term structure.\n\n\n\n\n\nReturn the model's CorrelationHolder.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/correlations/#Functions","page":"Correlations","title":"Functions","text":"","category":"section"},{"location":"termstructures/correlations/","page":"Correlations","title":"Correlations","text":"Call operator for CorrelationTermstructure is defined as","category":"page"},{"location":"termstructures/correlations/","page":"Correlations","title":"Correlations","text":"(ts::CorrelationTermstructure)(args...) = correlation(ts, args...)","category":"page"},{"location":"termstructures/correlations/#DiffFusion.correlation","page":"Correlations","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, alias1::String, alias2::String)\n\nReturn a scalar instantaneous correlation.\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, aliases::AbstractVector{String})\n\nReturn a symmetric matrix of instantaneous correlations.\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, aliases2::AbstractVector{String})\n\nReturn a matrix of instantaneous correlations, each element of aliases1 versus each element of aliases2. The size of the resulting matrix is (length(aliases1), length(aliases2)).\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, alias1::String, aliases2::AbstractVector{String})\n\nReturn an (1,N) matrix of instantaneous correlations.\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, alias2::String)\n\nReturn an (N, 1) matrix of instantaneous correlations.\n\n\n\n\n\ncorrelation(ch::CorrelationHolder, alias1::String, alias2::String)\n\nReturn a scalar instantaneous correlation.\n\n\n\n\n\ncorrelation(ch::CorrelationHolder, aliases1::AbstractVector{String}, aliases2::AbstractVector{String})\n\nReturn a matrix of instantaneous correlations, each element of aliases1 versus each element  of aliases2. The size of the resulting matrix is (length(aliases1), length(aliases2)).\n\n\n\n\n\ncorrelation(ch::CorrelationHolder, aliases::AbstractVector{String})\n\nReturn a symmetric matrix of instantaneous correlations.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/correlations/#DiffFusion.correlation_key","page":"Correlations","title":"DiffFusion.correlation_key","text":"correlation_key(ch::CorrelationHolder, alias1::String, alias2::String)\n\nDerive the key for correlation dictionary from two aliases.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/correlations/#DiffFusion.set_correlation!","page":"Correlations","title":"DiffFusion.set_correlation!","text":"set_correlation!(\n    ch::CorrelationHolder,\n    alias1::String,\n    alias2::String,\n    value::ModelValue\n    )\n\nInsert a new correlation value into CorrelationHolder. If a correlation already exists it is overwritten.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/correlations/#DiffFusion.get","page":"Correlations","title":"DiffFusion.get","text":"get(ch::CorrelationHolder, alias1::String, alias2::String)\n\nImplement methodology to obtain a scalar correlation from a CorrelationHolder.\n\n\n\n\n\n","category":"function"},{"location":"models/futures_models/#Future-Price-Models","page":"Future Price Models","title":"Future Price Models","text":"","category":"section"},{"location":"models/futures_models/#Future-Price-Model-Types","page":"Future Price Models","title":"Future Price Model Types","text":"","category":"section"},{"location":"models/futures_models/#DiffFusion.MarkovFutureModel","page":"Future Price Models","title":"DiffFusion.MarkovFutureModel","text":"struct MarkovFutureModel <: SeparableHjmModel\n    hjm_model::GaussianHjmModel\nend\n\nA Markov model for Future prices with piece-wise constant benchmark price volatility and constant mean reversion.\n\nWe implement an object adapter for the GaussianHjmModel to re-use implementation for common modelling parts.\n\nThe MarkovFutureModel differs from the GaussianHjmModel essentially only by the drift Theta.\n\nMoreover, we do not require the integrated state variable and want to identify correlations with Future prices instead of forward rates.\n\n\n\n\n\n","category":"type"},{"location":"models/futures_models/#DiffFusion.markov_future_model","page":"Future Price Models","title":"DiffFusion.markov_future_model","text":"markov_future_model(\n    alias::String,\n    delta::ParameterTermstructure,\n    chi::ParameterTermstructure,\n    sigma_f::BackwardFlatVolatility,\n    correlation_holder::Union{CorrelationHolder, Nothing},\n    quanto_model::Union{AssetModel, Nothing},\n    scaling_type::BenchmarkTimesScaling = ForwardRateScaling,\n    )\n\nCreate a Gausian Markov model for Future prices.\n\n\n\n\n\n","category":"function"},{"location":"models/futures_models/#Model-Functions-for-Payoff-Evaluation","page":"Future Price Models","title":"Model Functions for Payoff Evaluation","text":"","category":"section"},{"location":"models/futures_models/#DiffFusion.log_future","page":"Future Price Models","title":"DiffFusion.log_future","text":"log_future(m::Model, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the Future price term h(t,T)'[x(t) + 0.5y(t)(1 - h(t,T))].\n\n\n\n\n\nlog_future(m::CompositeModel, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the Future price term h(t,T)'[x(t) + 0.5y(t)(1 - h(t,T))].\n\n\n\n\n\nlog_future(m::MarkovFutureModel, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the Future price term (h(t,T)'[x(t) + 0.5y(t)(1 - h(t,T))])'.\n\n\n\n\n\n","category":"function"},{"location":"models/asset_models/#Asset-Models-(FX/Equity/Inflation)","page":"Asset Models (FX/Equity/Inflation)","title":"Asset Models (FX/Equity/Inflation)","text":"","category":"section"},{"location":"models/asset_models/#Asset-Model-Types","page":"Asset Models (FX/Equity/Inflation)","title":"Asset Model Types","text":"","category":"section"},{"location":"models/asset_models/#DiffFusion.AssetModel","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.AssetModel","text":"abstract type AssetModel <: ComponentModel end\n\nAn AssetModel aims at modelling spot prices of tradeable assets like FX, shares and indices.\n\nWe implement several additional functions to handle quanto adjustments.\n\n\n\n\n\n","category":"type"},{"location":"models/asset_models/#Lognormal-Model","page":"Asset Models (FX/Equity/Inflation)","title":"Lognormal Model","text":"","category":"section"},{"location":"models/asset_models/#DiffFusion.LognormalAssetModel","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.LognormalAssetModel","text":"struct LognormalAssetModel <: AssetModel\n    alias::String\n    sigma_x::BackwardFlatVolatility\n    state_alias::AbstractVector\n    factor_alias::AbstractVector\n    correlation_holder::CorrelationHolder\n    quanto_model::Union{AssetModel, Nothing}\nend\n\nA LognormalAssetModel is a model for simulating a spot price in a generalised Black-Scholes framework.\n\n\n\n\n\n","category":"type"},{"location":"models/asset_models/#DiffFusion.lognormal_asset_model","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.lognormal_asset_model","text":"lognormal_asset_model(\n    alias::String,\n    sigma_x::BackwardFlatVolatility,\n    ch::CorrelationHolder,\n    quanto_model::Union{AssetModel, Nothing}\n    )\n\nCreate a LognormalAssetModel.\n\n\n\n\n\nlognormal_asset_model(\n    alias::String,\n    dom_model::Union{GaussianHjmModel, Nothing},\n    for_model::Union{GaussianHjmModel, Nothing},\n    ch::Union{CorrelationHolder, Nothing},\n    option_times::AbstractVector,\n    asset_volatilities::AbstractVector,\n    )\n\nCalibrate an asset model to implied lognormal volatilities.\n\n\n\n\n\n","category":"function"},{"location":"models/asset_models/#CEV-Model","page":"Asset Models (FX/Equity/Inflation)","title":"CEV Model","text":"","category":"section"},{"location":"models/asset_models/#DiffFusion.CevAssetModel","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.CevAssetModel","text":"struct CevAssetModel <: AssetModel\n    alias::String\n    sigma_x::BackwardFlatVolatility\n    skew_x::BackwardFlatParameter\n    state_alias::AbstractVector\n    factor_alias::AbstractVector\n    correlation_holder::CorrelationHolder\n    quanto_model::Union{AssetModel, Nothing}\nend\n\nA CevAssetModel is a model for simulating an asset price in a Constant Elasticity of Variance model.\n\n\n\n\n\n","category":"type"},{"location":"models/asset_models/#DiffFusion.cev_asset_model","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.cev_asset_model","text":"cev_asset_model(\n    alias::String,\n    sigma_x::BackwardFlatVolatility,\n    skew_x::BackwardFlatParameter,\n    ch::CorrelationHolder,\n    quanto_model::Union{AssetModel, Nothing}\n    )\n\nCreate a CevAssetModel.\n\n\n\n\n\n","category":"function"},{"location":"models/asset_models/#Model-Functions-for-Payoff-Evaluation","page":"Asset Models (FX/Equity/Inflation)","title":"Model Functions for Payoff Evaluation","text":"","category":"section"},{"location":"models/asset_models/#DiffFusion.log_asset","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.log_asset","text":"log_asset(m::Model, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_asset(m::CevAssetModel, model_alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\n\n\n\n\nlog_asset(m::LognormalAssetModel, model_alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\n\n\n\n\nlog_asset(m::CompositeModel, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\n\n\n\n\n","category":"function"},{"location":"models/asset_models/#DiffFusion.log_asset_convexity_adjustment","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.log_asset_convexity_adjustment","text":"log_asset_convexity_adjustment(\n    m::Model,\n    dom_alias::String,\n    for_alias::String,\n    ast_alias::String,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    )\n\nCalculate the YoY convexity adjustment term for OU models.\n\nReturns a scalar quantity.\n\n\n\n\n\nlog_asset_convexity_adjustment(\n    m::CompositeModel,\n    dom_alias::String,\n    for_alias::String,\n    ast_alias::String,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    )\n\nCalculate the YoY convexity adjustment term for OU models.\n\nReturns a scalar quantity.\n\n\n\n\n\nlog_asset_convexity_adjustment(\n    dom_model::GaussianHjmModel,\n    for_model::GaussianHjmModel,\n    ast_model::LognormalAssetModel,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    )\n\nCalculate convexity adjustment for year-on-year coupons of tradeable assets.\n\n\n\n\n\n","category":"function"},{"location":"models/asset_models/#Additional-Asset-Model-Functions","page":"Asset Models (FX/Equity/Inflation)","title":"Additional Asset Model Functions","text":"","category":"section"},{"location":"models/asset_models/#DiffFusion.asset_volatility","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.asset_volatility","text":"asset_volatility(\n    m::AssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a state-independent volatility function sigma(u) for the interval (s,t).\n\n\n\n\n\nasset_volatility(\n    m::CevAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a state-independent volatility function sigma(u) for the interval (s,t).\n\n\n\n\n\nasset_volatility(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a state-independent volatility function sigma(u) for the interval (s,t).\n\n\n\n\n\n","category":"function"},{"location":"models/asset_models/#DiffFusion.correlation_holder-Tuple{DiffFusion.AssetModel}","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.correlation_holder","text":"correlation_holder(m::AssetModel)\n\nReturn the correlation holder term structure.\n\n\n\n\n\n","category":"method"},{"location":"models/asset_models/#DiffFusion.quanto_drift","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.quanto_drift","text":"quanto_drift(\n    dom_factor_alias::AbstractVector,\n    quanto_model::Nothing,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a zero quanto adjustment function alpha(u).\n\n\n\n\n\nquanto_drift(\n    dom_factor_alias::AbstractVector,\n    quanto_model::AssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a function alpha(u) that allows to calculate the quanto adjustment on the time interval (s,t).\n\n\n\n\n\n","category":"function"},{"location":"models/asset_models/#DiffFusion.asset_variance","page":"Asset Models (FX/Equity/Inflation)","title":"DiffFusion.asset_variance","text":"asset_variance(\n    m::Model,\n    ast_alias::Union{String, Nothing},\n    dom_alias::Union{String, Nothing},\n    for_alias::Union{String, Nothing},\n    t::ModelTime,\n    T::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the lognormal model variance of an asset spot price over the time period [t,T]. If Model is state-dependent then variance calculation takes into account model state X.\n\n\n\n\n\nasset_variance(\n    m::CompositeModel,\n    ast_alias::Union{String, Nothing},\n    dom_alias::Union{String, Nothing},\n    for_alias::Union{String, Nothing},\n    t::ModelTime,\n    T::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the lognormal model variance of an asset spot price over the time period [t,T].\n\n\n\n\n\nasset_variance(\n    ast_model::LognormalAssetModel,\n    dom_model::Union{GaussianHjmModel, Nothing},\n    for_model::Union{GaussianHjmModel, Nothing},\n    ch::CorrelationHolder,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nCalculate lognormal variance in hybrid asset model.\n\nThe method is defined for a LognormalAssetModel. It should also work for other asset models. But then we need to calculate a vector and this requires more testing.\n\n\n\n\n\nasset_variance(\n    p::AbstractPath,\n    t::ModelTime,\n    T::ModelTime,\n    key::String,\n    )\n\nCalculate the lognormal model variance of an asset spot price over the time period [t,T].\n\n\n\n\n\nasset_variance(\n    p::Path,\n    t::ModelTime,\n    T::ModelTime,\n    key::String,\n    )\n\nCalculate the lognormal model variance of an asset spot price over the time period [t,T].\n\n\n\n\n\n","category":"function"},{"location":"payoffs/amc_payoffs/#American-Monte-Carlo","page":"American Monte Carlo","title":"American Monte Carlo","text":"","category":"section"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcPayoff","page":"American Monte Carlo","title":"DiffFusion.AmcPayoff","text":"abstract type AmcPayoff <: Payoff end\n\nAmcPayoff is used to implement common methods for AMC payoffs. Concrete AMC payoffs are assumed to hold a fields links::AmcPayoffLinks and regr::AmcPayoffRegression.\n\nAn AMC payoff is special and does not fit into the structure of unary/binary nodes. Instead, we have several edges to other payoffs with observation times before (x and y) and after (z) its own observation time.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcPayoffLinks","page":"American Monte Carlo","title":"DiffFusion.AmcPayoffLinks","text":"struct AmcPayoffLinks\n    obs_time::ModelTime\n    x::AbstractVector\n    y::AbstractVector\n    z::AbstractVector\n    curve_key::String\nend\n\nAn AmcPayoffLinks object holds common data fields for an American Monte Carlo (AMC) payoff.\n\nHere, obs_time is the observation time of the AMC payoff and x, y, z are related Payoff vectors. The elements of x and y represent random variables with observation times after obs_time. The elements of z represent random variables with observation time (at or) before obs_time. z is the vector of regression variables.\n\nThe parameter curve_key is used to specify a discount curve for numeraire price calculation.\n\nWe calculate X as the sum of discounted payoff values of x and Y as the sum of discounted payoff values of y. Z =  Z_1 Z_2   represent the (undiscounted) values of the regression variables from the payoff vector z.\n\nThen we estimate the trigger variable\n\nT = E X - Y  Z_1 Z_2  \n\nAn actual AMC payoff uses X, Y, and T to calculate its values.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcPayoffRegression","page":"American Monte Carlo","title":"DiffFusion.AmcPayoffRegression","text":"mutable struct AmcPayoffRegression\n    path::Union{AbstractPath, Nothing}\n    make_regression::Union{Function, Nothing}\n    regression::Any\nend\n\nAmcPayoffRegression holds the common data fields to regression and regression calibration for AMC payoffs. These data fields are supposed to be updated subsequent creation of the object. As a consequence, AmcPayoffRegression is declared mutable.\n\nThe element path is a Monte Carlo path. This element is typically linked to a simulation and a context mapping.\n\nmake_regression is a function/functor with signature\n\nmake_regression(C::AbstractMatrix, O::AbstractVector) -> obj.\n\nThis function is typically a lambda for polynomial_regression (or similar) where parameters like maximum polynomial degree are fixed.\n\nThe result of make_regression is stored in the regression field. For the result object regression we assume that a method\n\npredict(regression, C)\n\nis defined. The method predict is supposed to return a prediction for a matrix of controls C. See PolynomialRegression as an example.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcMax","page":"American Monte Carlo","title":"DiffFusion.AmcMax","text":"struct AmcMax <: AmcPayoff\n    links::AmcPayoffLinks\n    regr::AmcPayoffRegression\nend\n\nAn AmcMax payoff is used to model long call rights.\n\nIt calculates the expectation of maximum of (sum of) discounted payoffs x and (sum of) discounted payoffs y. Expectation is calculated conditional on information at obs_time. This is approximated by regression variable payoffs z.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcMax-Tuple{Number, AbstractVector, AbstractVector, AbstractVector, Union{Nothing, DiffFusion.AbstractPath}, Union{Nothing, Function}, String}","page":"American Monte Carlo","title":"DiffFusion.AmcMax","text":"AmcMax(\n    obs_time::ModelTime,\n    x::AbstractVector,\n    y::AbstractVector,\n    z::AbstractVector,\n    path::Union{AbstractPath, Nothing},\n    make_regression::Union{Function, Nothing},\n    curve_key::String,\n    )\n\nCreate an AmcMax payoff.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcMin","page":"American Monte Carlo","title":"DiffFusion.AmcMin","text":"struct AmcMin <: AmcPayoff\n    links::AmcPayoffLinks\n    regr::AmcPayoffRegression\nend\n\nAn AmcMin payoff is used to model short call rights.\n\nIt calculates the expectation of minimum of (sum of) discounted payoffs x and (sum of) discounted payoffs y. Expectation is calculated conditional on information at obs_time. This is approximated by regression variable payoffs z.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcMin-Tuple{Number, AbstractVector, AbstractVector, AbstractVector, Union{Nothing, DiffFusion.AbstractPath}, Union{Nothing, Function}, String}","page":"American Monte Carlo","title":"DiffFusion.AmcMin","text":"AmcMin(\n    obs_time::ModelTime,\n    x::AbstractVector,\n    y::AbstractVector,\n    z::AbstractVector,\n    path::Union{AbstractPath, Nothing},\n    make_regression::Union{Function, Nothing},\n    curve_key::String,\n    )\n\nCreate an AmcMin payoff.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcOne","page":"American Monte Carlo","title":"DiffFusion.AmcOne","text":"struct AmcOne <: AmcPayoff\n    links::AmcPayoffLinks\n    regr::AmcPayoffRegression\nend\n\nAn AmcOne payoff is used to model the indicator variable 1_(X  Y).\n\nIt calculates the expectation of maximum of (sum of) discounted payoffs x and (sum of) discounted payoffs y. Expectation is calculated conditional on information at obs_time. This is approximated by regression variable payoffs z.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcOne-Tuple{Number, AbstractVector, AbstractVector, AbstractVector, Union{Nothing, DiffFusion.AbstractPath}, Union{Nothing, Function}, String}","page":"American Monte Carlo","title":"DiffFusion.AmcOne","text":"AmcOne(\n    obs_time::ModelTime,\n    x::AbstractVector,\n    y::AbstractVector,\n    z::AbstractVector,\n    path::Union{AbstractPath, Nothing},\n    make_regression::Union{Function, Nothing},\n    curve_key::String,\n    )\n\nCreate an AmcOne payoff.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcSum","page":"American Monte Carlo","title":"DiffFusion.AmcSum","text":"struct AmcSum <: AmcPayoff\n    links::AmcPayoffLinks\n    regr::AmcPayoffRegression\nend\n\nAn AmcSum payoff is used to model general conditional expectations\n\nB(t) E X(T)B(T)  Z(t) \n\nAmcSum payoffs are typically used to calculate future model prices in exposure simulation applications. \n\n\n\n\n\n","category":"type"},{"location":"payoffs/amc_payoffs/#DiffFusion.AmcSum-Tuple{Number, AbstractVector, AbstractVector, Union{Nothing, DiffFusion.AbstractPath}, Union{Nothing, Function}, String}","page":"American Monte Carlo","title":"DiffFusion.AmcSum","text":"AmcSum(\n    obs_time::ModelTime,\n    x::AbstractVector,\n    z::AbstractVector,\n    path::Union{AbstractPath, Nothing},\n    make_regression::Union{Function, Nothing},\n    curve_key::String,\n    )\n\nCreate an AmcSum payoff.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/amc_payoffs/#DiffFusion.reset_regression!","page":"American Monte Carlo","title":"DiffFusion.reset_regression!","text":"reset_regression!(\n    p::AmcPayoff,\n    path::Union{AbstractPath, Nothing} = nothing,\n    make_regression::Union{Function, Nothing}  = nothing,\n    )\n\nReset the regression properties for an AMC payoffs.\n\nThis method is used to allow setting and updating AMC regression after payoff creation.\n\n\n\n\n\nreset_regression!(\n    p::UnaryNode,\n    path::Union{AbstractPath, Nothing} = nothing,\n    make_regression::Union{Function, Nothing}  = nothing,\n    )\n\nDelegate resetting the regression properties to child payoff.\n\n\n\n\n\nreset_regression!(\n    p::BinaryNode,\n    path::Union{AbstractPath, Nothing} = nothing,\n    make_regression::Union{Function, Nothing}  = nothing,\n    )\n\nDelegate resetting the regression properties to child payoffs.\n\n\n\n\n\nreset_regression!(\n    p::Union{Leaf, CompoundedRate, Optionlet, Swaption},\n    path::Union{AbstractPath, Nothing} = nothing,\n    make_regression::Union{Function, Nothing}  = nothing,\n    )\n\nIgnore resetting the regression properties for Leaf and similar payoffs.\n\nNote that some rates payoffs and rates options are no Leafs.\n\n\n\n\n\nreset_regression!(\n    p::Payoff,\n    path::Union{AbstractPath, Nothing} = nothing,\n    make_regression::Union{Function, Nothing}  = nothing,\n    )\n\nThrow an error if reset_regression! is not implemented for concrete payoff.\n\n\n\n\n\nreset_regression!(\n    leg::BermudanSwaptionLeg,\n    path::Union{AbstractPath, Nothing} = nothing,\n    make_regression::Union{Function, Nothing}  = nothing,\n    )\n\nReset the regression properties for the AMC payoffs of the BermudanSwaptionLeg.\n\nThis method is used to allow setting and updating AMC regression after leg creation.\n\n\n\n\n\n","category":"function"},{"location":"payoffs/amc_payoffs/#DiffFusion.calibrate_regression","page":"American Monte Carlo","title":"DiffFusion.calibrate_regression","text":"calibrate_regression(links::AmcPayoffLinks, regr::AmcPayoffRegression)\n\nCalibrate the regression for an AMC payoff.\n\n\n\n\n\n","category":"function"},{"location":"payoffs/amc_payoffs/#DiffFusion.has_amc_payoff","page":"American Monte Carlo","title":"DiffFusion.has_amc_payoff","text":"has_amc_payoff(p::AmcPayoff)\n\nDetermine whether a payoff is or contains an AMC payoff.\n\nAMC payoffs require special treatment e.g. for sensitivity calculation.\n\n\n\n\n\nhas_amc_payoff(p::UnaryNode)\n\nDetermine whether a payoff is or contains an AMC payoff.\n\n\n\n\n\nhas_amc_payoff(p::BinaryNode)\n\nDetermine whether a payoff is or contains an AMC payoff.\n\n\n\n\n\nhas_amc_payoff(p::Union{Leaf, CompoundedRate, Optionlet, Swaption})\n\nDetermine whether a payoff is or contains an AMC payoff.\n\n\n\n\n\nhas_amc_payoff(p::Payoff)\n\nDetermine whether a payoff is or contains an AMC payoff.\n\n\n\n\n\nhas_amc_payoff(payoffs::AbstractVector)\n\nDetermine whether any payoff is or contains an AMC payoff.\n\n\n\n\n\n","category":"function"},{"location":"models/credit_models/#Credit-Spread-Models","page":"Credit Spread Models","title":"Credit Spread Models","text":"","category":"section"},{"location":"models/credit_models/#Model-Types","page":"Credit Spread Models","title":"Model Types","text":"","category":"section"},{"location":"models/credit_models/#DiffFusion.CoxIngersollRossModel","page":"Credit Spread Models","title":"DiffFusion.CoxIngersollRossModel","text":"A Cox-Ingersoll-Ross model with constant parameters.\n\n\n\n\n\n","category":"type"},{"location":"models/credit_models/#DiffFusion.cox_ingersoll_ross_model","page":"Credit Spread Models","title":"DiffFusion.cox_ingersoll_ross_model","text":"Create a CoxIngersollRossModel.\n\n\n\n\n\nCreate a CoxIngersollRossModel from parameter vector.\n\n\n\n\n\nCreate a CoxIngersollRossModel from scalar parameters.\n\n\n\n\n\n","category":"function"},{"location":"models/credit_models/#Model-Functions-for-Simulation","page":"Credit Spread Models","title":"Model Functions for Simulation","text":"","category":"section"},{"location":"models/credit_models/#DiffFusion.cir_z0","page":"Credit Spread Models","title":"DiffFusion.cir_z0","text":"Return z0 parameter.\n\n\n\n\n\n","category":"function"},{"location":"models/credit_models/#DiffFusion.cir_chi","page":"Credit Spread Models","title":"DiffFusion.cir_chi","text":"Return chi parameter.\n\n\n\n\n\n","category":"function"},{"location":"models/credit_models/#DiffFusion.cir_theta","page":"Credit Spread Models","title":"DiffFusion.cir_theta","text":"Return theta parameter.\n\n\n\n\n\n","category":"function"},{"location":"models/credit_models/#DiffFusion.cir_sigma","page":"Credit Spread Models","title":"DiffFusion.cir_sigma","text":"Return sigma parameter.\n\n\n\n\n\n","category":"function"},{"location":"models/credit_models/#DiffFusion.cir_moments","page":"Credit Spread Models","title":"DiffFusion.cir_moments","text":"Return first and second moments E[zt | zs] and Var[zt | zs].\n\n\n\n\n\nReturn first and second moments E[zt | zs] and Var[zt | zs].\n\n\n\n\n\n","category":"function"},{"location":"models/credit_models/#DiffFusion.cir_lognormal_approximation","page":"Credit Spread Models","title":"DiffFusion.cir_lognormal_approximation","text":"Calculate lognormal approximation in CIR model.\n\n\n\n\n\nCalculate lognormal approximation in CIR model.\n\n\n\n\n\n","category":"function"},{"location":"models/credit_models/#DiffFusion.func_Theta_Sigma","page":"Credit Spread Models","title":"DiffFusion.func_Theta_Sigma","text":"Calculate deterministic drift and diffusion component.\n\n\n\n\n\n","category":"function"},{"location":"payoffs/rates_payoffs/#Interest-Rates","page":"Interest Rates","title":"Interest Rates","text":"","category":"section"},{"location":"payoffs/rates_payoffs/#Building-Blocks","page":"Interest Rates","title":"Building Blocks","text":"","category":"section"},{"location":"payoffs/rates_payoffs/#DiffFusion.Numeraire","page":"Interest Rates","title":"DiffFusion.Numeraire","text":"struct Numeraire <: Leaf\n    obs_time::ModelTime\n    curve_key::String\nend\n\nThe price of our numeraire asset price N(t) at observation time t.\n\nTypically, this coincides with the bank account price in numeraire (i.e. domestic) currency.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/rates_payoffs/#DiffFusion.BankAccount","page":"Interest Rates","title":"DiffFusion.BankAccount","text":"struct BankAccount <: Leaf\n    obs_time::ModelTime\n    key::String\nend\n\nThe price of a continuous compounded bank account B(t) at observation time t and with unit notional at inception.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/rates_payoffs/#DiffFusion.ZeroBond","page":"Interest Rates","title":"DiffFusion.ZeroBond","text":"struct ZeroBond <: Leaf\n    obs_time::ModelTime\n    maturity_time::ModelTime\n    key::String\nend\n\nThe price of a zero coupon bond P(t,T) with observation time t and bond maturity time T.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/rates_payoffs/#DiffFusion.Fixing","page":"Interest Rates","title":"DiffFusion.Fixing","text":"struct Fixing <: Leaf\n    obs_time::ModelTime\n    key::String\nend\n\nThe value of an index fixing Idx(t) at observation time t.\n\nThe value is obtained from a term structure linked to the path.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/rates_payoffs/#Rates-Payoffs","page":"Interest Rates","title":"Rates Payoffs","text":"","category":"section"},{"location":"payoffs/rates_payoffs/#DiffFusion.LiborRate","page":"Interest Rates","title":"DiffFusion.LiborRate","text":"struct LiborRate <: Leaf\n    obs_time::ModelTime\n    start_time::ModelTime\n    end_time::ModelTime\n    year_fraction::ModelValue\n    key::String\nend\n\nA simple compounded forward Libor rate.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/rates_payoffs/#DiffFusion.LiborRate-Tuple{Number, Number, Number, String}","page":"Interest Rates","title":"DiffFusion.LiborRate","text":"LiborRate(\n   obs_time::ModelTime,\n   start_time::ModelTime,\n   end_time::ModelTime,\n   key::String,\n   )\n\nA simple compounded forward Libor rate with year fraction from model time.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/rates_payoffs/#DiffFusion.CompoundedRate","page":"Interest Rates","title":"DiffFusion.CompoundedRate","text":"struct CompoundedRate <: Payoff\n    obs_time::ModelTime\n    start_time::ModelTime\n    end_time::ModelTime\n    year_fraction::ModelValue\n    fixed_compounding::Union{Payoff, Nothing}\n    key::String\n    fixed_type::DataType  # distinguish from constructors\nend\n\nA continuously compounded backward looking rate.\n\nThis is a proxy for daily compounded RFR coupon rates.\n\nFor obstime less starttime it is equivalent to a Libor rate.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/rates_payoffs/#DiffFusion.CompoundedRate-Tuple{Number, Number, Number, String}","page":"Interest Rates","title":"DiffFusion.CompoundedRate","text":"CompoundedRate(\n    obs_time::ModelTime,\n    start_time::ModelTime,\n    end_time::ModelTime,\n    key::String,\n    fixed_compounding::Union{Payoff, Nothing} = nothing,\n    )\n\nA continuously compounded backward looking rate with year fraction from model time.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/rates_payoffs/#DiffFusion.Optionlet","page":"Interest Rates","title":"DiffFusion.Optionlet","text":"struct Optionlet <: Payoff\n    obs_time::ModelTime\n    expiry_time::ModelTime\n    gearing_factor::Payoff\n    forward_rate::Union{LiborRate, CompoundedRate}\n    strike_rate::Payoff\n    call_put::ModelValue\nend\n\nThe time-t forward price of an option paying [ϕ(R-K)]^+. Rate R is determined at expiry_time. The rate R can be forward-looking or backward-looking.\n\nforward price is calculated as expectation in T-forward measure where T corresponds to the period end time. Conditioning (for time-t price) is on information at obs_time.\n\nThe rate R is written in terms of a compounding factor C and R = [G C - 1]/τ. Here, G is an additional gearing factor to capture past OIS fixings.\n\nThen, option payoff becomes G/τ [ϕ(C - (1 + τK)/G)]^+.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/rates_payoffs/#DiffFusion.Optionlet-2","page":"Interest Rates","title":"DiffFusion.Optionlet","text":"Optionlet(\n    obs_time_::ModelTime,\n    expiry_time::ModelTime,\n    forward_rate::Union{LiborRate, CompoundedRate},\n    strike_rate::Payoff,\n    call_put::ModelValue,\n    gearing_factor::Payoff = ScalarValue(1.0),\n    )\n\nCreate an Optionlet payoff.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/rates_payoffs/#DiffFusion.Swaption","page":"Interest Rates","title":"DiffFusion.Swaption","text":"struct Swaption <: Payoff\n    obs_time::ModelTime\n    expiry_time::ModelTime\n    settlement_time::ModelTime\n    forward_rates::AbstractVector\n    forward_rate_pay_times::AbstractVector\n    fixed_times::AbstractVector\n    fixed_weights::AbstractVector\n    fixed_rate::ModelValue\n    payer_receiver::ModelValue\n    disc_key::String\n    zcb_pay_times::AbstractVector\n    rate_type::DataType  # to distinguish from functions\nend\n\nTime-t forward price of an option paying An⋅[ϕ(S-K)]^+. Swap rate S is determined at expiry_time. Floating rates in S can be forward looking of backward looking rates.\n\nForward price is calculated in T-forward measure where T corresponds to settlement_time. Conditioning (for time-t price) is on information at obs_time.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/rates_payoffs/#DiffFusion.Swaption-Tuple{Number, Number, Number, AbstractVector, AbstractVector, AbstractVector, Number, Number, String}","page":"Interest Rates","title":"DiffFusion.Swaption","text":"Swaption(\n    obs_time_::ModelTime,\n    expiry_time::ModelTime,\n    settlement_time::ModelTime,\n    forward_rates::AbstractVector,\n    fixed_times::AbstractVector,\n    fixed_weights::AbstractVector,\n    fixed_rate::ModelValue,\n    payer_receiver::ModelValue,\n    disc_key::String,\n    )\n\nCreate a Swaption payoff.\n\n\n\n\n\n","category":"method"},{"location":"pricing_configuration/paths/#Simulated-Paths","page":"Simulated Paths","title":"Simulated Paths","text":"","category":"section"},{"location":"pricing_configuration/paths/","page":"Simulated Paths","title":"Simulated Paths","text":"The concept of a path adds a layer of abstraction. On the one-hand side we have models and simulations. These objects are specified by the mathematical details of stochastic processes. On the other hand-side we have payoffs and products. These objects are specified by the business context.","category":"page"},{"location":"pricing_configuration/paths/","page":"Simulated Paths","title":"Simulated Paths","text":"A path is used to link business context and payoff evaluation to models and simulations.","category":"page"},{"location":"pricing_configuration/paths/#Path-Creation","page":"Simulated Paths","title":"Path Creation","text":"","category":"section"},{"location":"pricing_configuration/paths/#DiffFusion.AbstractPath","page":"Simulated Paths","title":"DiffFusion.AbstractPath","text":"abstract type AbstractPath end\n\nAn AbstractPath specifies the interface for path implementations.\n\nThis aims at providing the flexibility to add other types of paths in the future.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/paths/#DiffFusion.Path","page":"Simulated Paths","title":"DiffFusion.Path","text":"struct Path <: AbstractPath\n    sim::Simulation\n    ts_dict::Dict{String,<:Termstructure}\n    state_alias_dict::Dict{String,Int}\n    context::Context\n    interpolation::PathInterpolation\nend\n\nA Path combines a model, simulated model states and term structures. The interface to market references is established by a valuation context.\n\nPaths are used by payoffs to calculate simulated zero bonds, asset prices and further building blocks of financial instrument payoffs.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/paths/#DiffFusion.path","page":"Simulated Paths","title":"DiffFusion.path","text":"path(\n    sim::Simulation,\n    ts_dict::Dict{String,<:Termstructure},\n    cxt::Context,\n    ip::PathInterpolation = NoPathInterpolation\n    )\n\nCreate a Path object.\n\n\n\n\n\npath(\n    sim::Simulation,\n    ts::Vector{Termstructure},\n    cxt::Context,\n    ip::PathInterpolation = NoPathInterpolation\n    )\n\nCreate a Path object from a list of term structures.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.PathInterpolation","page":"Simulated Paths","title":"DiffFusion.PathInterpolation","text":"@enum(\n    PathInterpolation,\n    NoPathInterpolation,\n    LinearPathInterpolation,\n)\n\nPathInterpolation encodes how simulated states can be interpolates.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/paths/#Path-Functions","page":"Simulated Paths","title":"Path Functions","text":"","category":"section"},{"location":"pricing_configuration/paths/#DiffFusion.numeraire","page":"Simulated Paths","title":"DiffFusion.numeraire","text":"numeraire(p::AbstractPath, t::ModelTime, curve_key::String)\n\nCalculate the numeraire in the domestic currency.\n\nWe allow for curve-specific numeraire calculation e.g. to allow for trade-specific discounting in AMC valuation.\n\n\n\n\n\nnumeraire(p::Path, t::ModelTime, curve_key::String)\n\nCalculate the numeraire in the domestic currency.\n\nWe allow for curve-specific numeraire calculation e.g. to allow for trade-specific discounting in AMC valuation.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.bank_account","page":"Simulated Paths","title":"DiffFusion.bank_account","text":"bank_account(p::AbstractPath, t::ModelTime, key::String)\n\nCalculate a continuous compounded bank account value.\n\n\n\n\n\nbank_account(p::Path, t::ModelTime, key::String)\n\nCalculate a continuous compounded bank account value.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.zero_bond","page":"Simulated Paths","title":"DiffFusion.zero_bond","text":"zero_bond(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nCalculate a zero coupon bond price.\n\n\n\n\n\nzero_bond(p::Path, t::ModelTime, T::ModelTime, key::String)\n\nCalculate a zero coupon bond price.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.zero_bonds","page":"Simulated Paths","title":"DiffFusion.zero_bonds","text":"zero_bonds(\n    yts::YieldTermstructure,\n    m::GaussianHjmModel,\n    t::ModelTime,\n    T::AbstractVector,\n    SX::ModelState,\n    )\n\nZero bond price reconstruction.\n\nReturns a vector of length p where p is the number of paths in SX.\n\n\n\n\n\nzero_bond(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nCalculate a zero coupon bond prices.\n\n\n\n\n\nzero_bonds(p::Path, t::ModelTime, T::AbstractVector, key::String)\n\nCalculate zero coupon bond prices.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.compounding_factor","page":"Simulated Paths","title":"DiffFusion.compounding_factor","text":"compounding_factor(p::AbstractPath, t::ModelTime, T1::ModelTime, T2::ModelTime, key::String)\n\nCalculate a compounding factor P(t,T1) / P(t,T2).\n\n\n\n\n\ncompounding_factor(p::Path, t::ModelTime, T1::ModelTime, T2::ModelTime, key::String)\n\nCalculate a compounding factor P(t,T1) / P(t,T2).\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.asset","page":"Simulated Paths","title":"DiffFusion.asset","text":"asset(p::AbstractPath, t::ModelTime, key::String)\n\nCalculate asset price.\n\n\n\n\n\nasset(p::Path, t::ModelTime, key::String)\n\nCalculate asset price.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.forward_asset","page":"Simulated Paths","title":"DiffFusion.forward_asset","text":"forward_asset(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nCalculate forward asset price as expectation in T-forward measure.\n\n\n\n\n\nforward_asset(p::Path, t::ModelTime, T::ModelTime, key::String)\n\nCalculate forward asset price as expectation in T-forward measure, conditional on time-t.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.forward_asset_and_zero_bonds","page":"Simulated Paths","title":"DiffFusion.forward_asset_and_zero_bonds","text":"forward_asset_and_zero_bonds(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nCalculate asset and zero bond components for forward asset price calculation.\n\n\n\n\n\nforward_asset_zero_bonds(p::Path, t::ModelTime, T::ModelTime, key::String)\n\nCalculate asset (plus deterministic jumps) as well as domestic and foreign zero bond price associated with an Asset key.\n\nThis function implements methodology redundant to forward_asset(...). But it returns asset and zero bonds separately.\n\nThis function is used for barrier option pricing.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.fixing","page":"Simulated Paths","title":"DiffFusion.fixing","text":"fixing(p::AbstractPath, t::ModelTime, key::String)\n\nReturn a fixing from a term structure.\n\nThis is used to handle fixings for indices etc.\n\n\n\n\n\nfixing(p::Path, t::ModelTime, key::String)\n\nReturn a fixing from a term structure.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.asset_convexity_adjustment","page":"Simulated Paths","title":"DiffFusion.asset_convexity_adjustment","text":"asset_convexity_adjustment(\n    p::AbstractPath,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    key::String\n    )\n\nReturn the convexity adjustment for a YoY asset payoff.\n\n\n\n\n\nasset_convexity_adjustment(\n    p::Path,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    key::String\n    )\n\nReturn the convexity adjustment for a YoY asset payoff.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.forward_index","page":"Simulated Paths","title":"DiffFusion.forward_index","text":"forward_index(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nExpectation Et^T[ST] of a tradeable asset.\n\n\n\n\n\nforward_index(p::Path, t::ModelTime, T::ModelTime, key::String)\n\nExpectation Et^T[ST] of a tradeable asset.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.index_convexity_adjustment","page":"Simulated Paths","title":"DiffFusion.index_convexity_adjustment","text":"index_convexity_adjustment(\n    p::AbstractPath,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    key::String\n    )\n\nReturn the convexity adjustment for a YoY index payoff.\n\n\n\n\n\nindex_convexity_adjustment(\n    p::Path,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    key::String\n    )\n\nReturn the convexity adjustment for a YoY index payoff.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.future_index","page":"Simulated Paths","title":"DiffFusion.future_index","text":"future_index(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nExpectation E_t^Q[F(T,T)] of a Future index/price.\n\n\n\n\n\nfuture_index(p::Path, t::ModelTime, T::ModelTime, key::String)\n\nExpectation E_t^Q[F(T,T)] of a Future index/price.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#Auxiliary-methods","page":"Simulated Paths","title":"Auxiliary methods","text":"","category":"section"},{"location":"pricing_configuration/paths/#Base.length","page":"Simulated Paths","title":"Base.length","text":"length(p::AbstractPath)\n\nReturn the number of realisations represented by the AbstractPath object.\n\nWe assume that model functions applied to an AbstractPath return a vector of length(p) where p is the number realisations.\n\n\n\n\n\nlength(p::Path)\n\nDerive the number of realisations from the linked simulation.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.state_variable","page":"Simulated Paths","title":"DiffFusion.state_variable","text":"state_variable(sim::Simulation, t::ModelTime, ip::PathInterpolation)\n\nDerive a state variable for a given observation time.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/paths/#DiffFusion.discount","page":"Simulated Paths","title":"DiffFusion.discount","text":"discount(\n    t::ModelTime,\n    ts_dict::Dict{String,Termstructure},\n    first_alias::String,\n    second_alias::Union{String,Nothing} = nothing,\n    operation::Union{String,Nothing} = nothing,\n    )\n\nDerive the discount factor for one or two of curve alias and a curve operation.\n\n\n\n\n\n","category":"function"},{"location":"introduction/simulation_framework/#Simulation-Framework","page":"Simulation Framework","title":"Simulation Framework","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this documentation we discuss our framework for efficient implementation of Monte Carlo methods that aim at simulating joint diffusion processes. The framework is designed with the following objectives in mind:","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Simulation should be exact (i.e. bias-free) if the underlying model   allows for exact simulation.\nFramework should allow for efficient factorisation of the joint   covariance matrix and exploit independence structures.\nSimulation should be formulated in terms of matrix and tensor   operations.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Simulation models in scope are models for interest rates, FX rates, equities, inflation, futures and credit. Basic variants of such models can be formulated as Ornstein-Uhlenbeck (OU) processes. Such OU processes do allow for exact simulation.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Common notation.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t is an n-dimensional state variable which describes the   model dynamic.\nW_u is an m-dimensional Brownian motion under the common   risk-neutral measure mathbbQ.\nGamma is an mtimes m matrix representing correlations of   increments in W_u.\ns, u, t are simulation times with 0leq sleq uleq t.\nX_t^k for k=1ldotsN are model component states that   represent a slice of the full vector X_t.\nThetaleft(cdotright), Hleft(cdotright),   Sigmaleft(cdotright) and Lleft(cdotright) are composite   model functions for the full state X_t.\nTheta^kleft(cdotright), H^kleft(cdotright) and   Sigma^kleft(cdotright) are component model functions that   represent slices of Thetaleft(cdotright),   Hleft(cdotright) and Sigmaleft(cdotright).\nVleft(stX_sright) is a diagonal ntimes n matrix   representing volatilities of the increments of state vector X_t.\nCleft(stX_sright) is a ntimes n matrix representing   correlations of the increments of state vector X_t.\nZ^left(1right)ldotsZ^left(pright) are independent   n-dimensional standard normal random variables for p paths.\nX_t^left(1right)ldotsX_t^left(pright) are simulated   realisations of the full random state variable X_t for p   paths.","category":"page"},{"location":"introduction/simulation_framework/#Hybrid-Model-Specification","page":"Simulation Framework","title":"Hybrid Model Specification","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The hybrid model is described by a multi-variate process left(X_tright)_t with X_tinmathbbR^n and initial condition X_0=0. The elements of the process left(X_tright)_t are grouped into models. That is, we decompose","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t=leftbeginarrayc\nX_t^1\nvdots\nX_t^N\nendarrayright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Each component model is descibed by the process left(X_t^kright)_t with X_t^kinmathbbR^n_k, k=1ldotsN. Each component model is specified independently but with a common interface. This allows for a flexible combination of models.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Component models.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Denote left(Omegacal F_tmathbbQright) a filtered probability space with (risk-neutral) probability measure mathbbQ. The common structure of the component models is given by the dynamics","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t^k=Theta^kleft(stX_sright)+H^kleft(stX_sright)X_s+int_s^tSigma^kleft(uX_sright)^topdW_u","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"for 0leq sleq t. Here, Theta^kleft(stX_sright)inmathbbR^n_k is a deterministic drift vector. The matrix H^kleft(stX_sright)inmathbbR^n_ktimes n typically accounts for mean reversion in the component model. Finally, the matrix Sigma^kleft(uX_sright)^topinmathbbR^n_ktimes m represents the volatility function of the component model and W_uinmathbbR^m is an m-dimensional vector of Brownian motions under mathbbQ.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Above specification is fairly general. We make a few comments to indicate how concrete component models will implement the specification.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The component model functions Theta^k, H^k and Sigma^k  may depend on the model state X_s. However, we impose that the  model state is observed at time s. This allows to cover local and  stochastic volatility models. But the component model functions  already need to implement some time-discretisation.\nIdeally, the component model functions Theta^k, H^k and  Sigma^k are independent of the model state. This is the case  for models based on OU processes. Then simulation can be exact.\nIn typical cases, component model states X_t^k do not depend  on the full hybrid model state X_s. Instead, X_t^k (as  well as Theta^k, H^k and Sigma^k) only use information  from X_s^k plus a few dependencies to other models.  Consequently, the dimensions n and m can effectively be reduced  to numbers in the order of n_k. We leave the general  representation in order to keep notation brief. But keep in mind  that with the general notation the full matrices H^k and  Sigma^k will be sparse.","category":"page"},{"location":"introduction/simulation_framework/#Hybrid-Model-Simulation","page":"Simulation Framework","title":"Hybrid Model Simulation","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Our general component model specification yields that the hybrid model dynamics become","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t=Thetaleft(stX_sright)+Hleft(stX_sright)X_s+int_s^tSigmaleft(uX_sright)^topdW_u","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with composite hybrid model functions","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nThetaleft(stX_sright)  =leftbeginarrayc\nTheta^1left(stX_sright)\nvdots\nTheta^Nleft(stX_sright)\nendarrayrightinmathbbR^n\nHleft(stX_sright)  =leftbeginarrayc\nH^1left(stX_sright)^top\nvdots\nH^Nleft(stX_sright)^top\nendarrayrightinmathbbR^ntimes nquadtextand\nSigmaleft(uX_sright)^top  =leftbeginarrayc\nSigma^1left(uX_sright)^top\nvdots\nSigma^Nleft(uX_sright)^top\nendarrayrightinmathbbR^ntimes m\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"As a consequence, we find that X_tX_s is multi-variate normally distributed with","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"mathbbEleftX_tX_sright=Thetaleft(stX_sright)+Hleft(stX_sright)X_sinmathbbR^n","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"textCovleftX_tX_sright=int_s^tSigmaleft(uX_sright)^topGammaSigmaleft(uX_sright)dtinmathbbR^ntimes n","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The constant symmetric matrix GammainmathbbR^mtimes m represents the instantaneous correlations of increments dW_t. We get for the elements textCovleftX_tX_sright_ij of the covariance matrix","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\ntextCovleftX_tX_sright_ij  =int_s^tSigmaleft(uX_sright)_i^topGammaSigmaleft(uX_sright)_jdu\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, Sigmaleft(uX_sright)_i and Sigmaleft(uX_sright)_j are the i-th and j-th column (ij=1ldotsn) of the volatility matrix Sigmaleft(uX_sright).","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The covariance matrix is decomposed into a diagonal state-volatility matrix Vleft(stX_sright) and a state-correlation matrix Cleft(stX_sright) such that","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nleftVleft(stX_sright)right_ii  =sqrtlefttextCovleftX_tX_srightright_iileft(t-sright)\nleftCleft(stX_sright)right_ii  =1\nleftCleft(stX_sright)right_ij  =begincases\nfraclefttextCovleftX_tX_srightright_ijleftVleft(stX_sright)right_iileftVleft(stX_sright)right_jjleft(t-sright)  textif leftVleft(stX_sright)right_iileftVleft(stX_sright)right_jj0\n0  textelse\nendcases\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"for all indices ij=1ldotsn. Then textCovleftX_tX_sright=Vleft(stX_sright)Cleft(stX_sright)Vleft(stX_sright)left(t-sright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"If all model functions are independent of the state X_s then we can directly calculate a (Cholesky) decomposition","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"textCovleftX_tX_sright=Vleft(stright)Lleft(stright)Lleft(stright)^topVleft(stright)left(t-sright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With such a factorisation we can simulate","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t=Thetaleft(stright)+Hleft(stright)X_s+Vleft(stright)Lleft(stright)Zsqrtt-s","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with standard normal vectors Zsimcal Nleft(01right). For a list of paths leftX_s^left(1right)ldotsX_s^left(pright)rightinmathbbR^ntimes p and standard normal increments leftZ^left(1right)ldotsZ^left(pright)rightinmathbbR^ntimes p this can be implemented as matrix multiplication and addition","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nleftX_t^left(1right)ldotsX_t^left(pright)right  =leftThetaleft(stright)ldotsThetaleft(stright)right\n  quad+Hleft(stright)^topleftX_s^left(1right)ldotsX_s^left(pright)right\n  quad+Vleft(stright)Lleft(stright)leftZ^left(1right)ldotsZ^left(pright)rightsqrtt-s\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The assumption of state-independent model component functions holds e.g. for Gaussian short rate models, Black-Scholes equity/foreign exchange models, and Dodgson-Kainth inflation model.","category":"page"},{"location":"introduction/simulation_framework/#Component-Models","page":"Simulation Framework","title":"Component Models","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this section, we specify component models for our hybrid model framework.","category":"page"},{"location":"introduction/simulation_framework/#Interest-Rate-Models","page":"Simulation Framework","title":"Interest Rate Models","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Interest rate models are formulated as separable Heath-Jarrow-Morton (HJM) models for the continuous forward rate fleft(tTright) with observation time t and term T.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Our specification follows in large parts Andersen/Piterbarg, Interest Rate Modeling, 2010, Sec. 4.4 and 4.5.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Forward rates are directly linked to zero coupon bonds Pleft(tTright). We have","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Pleft(tTright)=expleft -int_t^Tfleft(tsright)dsright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"or equivalently","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"fleft(tTright)=-fracpartialpartial Tlogleft(Pleft(tTright)right)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We formulate the model in risk neutral measure. The risk neutral measure uses the continuous bank account as numeraire. The bank account accruals at the short rate","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r_t=f(tt)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"And the price process of the bank account left(B_tright)_t is given by","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"B_t=e^int_0^tr_sds","category":"page"},{"location":"introduction/simulation_framework/#Heath-Jarrow-Morton-Modelling-Framework","page":"Simulation Framework","title":"Heath-Jarrow-Morton Modelling Framework","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Consider a general HJM model for the forward rates f(tT). No-arbitrage considerations yield the dynamics","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"dfleft(tTright)=sigma_fleft(tTright)^topcdotleftint_t^Tsigma_fleft(turight)durightcdot dt+sigma_fleft(tTright)^topcdot dW_t","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, sigma_fleft(tTright)^top is a d-dimensional vector of forward rate volatilities and W_t is a d-dimensional Brownian motion in the risk-neutral measure. The drift term of the HJM model follows from no-arbitrage considerations. Thus it remains to specify the forward rate volatility function sigma_fleft(tTright)^top.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In an HJM model with separable volatility the forward rate volatility takes the form sigma_fleft(tTright)=gleft(tright)hleft(Tright). Here gleft(tright)=gleft(tomegaright)inmathbbR^dtimes d is a matrix-valued process adapted to cal F_t and hleft(Tright)inmathbbR^d is a vector-valued deterministic function. The models of this class are also considered Quasi-Gaussian models.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For an HJM model we get the bond price dynamics in risk-neutral measure as","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"fracdPleft(tTright)Pleft(tTright)=r_tcdot dt-sigma_Pleft(tTright)^topcdot dW_t","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The minus sign indicates that if rates increase bond prices decrease (and vice versa). In a separable volatility HJM model the bond price volatility becomes","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_Pleft(tTright)=gleft(tright)cdotint_t^Thleft(uright)cdot du","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Integration yields the forward rates","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nfleft(tTright)  =fleft(0Tright)+\n  quad hleft(Tright)^topint_0^tgleft(sright)^topgleft(sright)left(int_s^Thleft(uright)duright)ds+\n  quad hleft(Tright)^topint_0^tgleft(sright)^topdW_s\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r_t=fleft(0tright)+hleft(tright)^topleftint_0^tgleft(sright)^topgleft(sright)left(int_s^thleft(uright)duright)ds+int_0^tgleft(sright)^topdW_sright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We can re-write hleft(tright)^top=boldsymbol1^topHleft(tright) and get","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r(t)=f(0t)+boldsymbol1^topHleft(tright)leftint_0^tgleft(sright)^topgleft(sright)left(int_s^thleft(uright)duright)ds+int_0^tgleft(sright)^topdW_sright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"boldsymbol1=left(beginarrayc\n1\nvdots\n1\nendarrayright)text and Hleft(tright)=textdiagleft(hleft(tright)right)=left(beginarrayccc\nh_1left(tright)  0  0\n0  ddots  0\n0  0  h_dleft(tright)\nendarrayright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Now, we can introduce the vector of state variables x_t with","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =Hleft(tright)leftint_0^tgleft(sright)^topgleft(sright)left(int_s^thleft(uright)duright)ds+int_0^tgleft(sright)^topdW_sright\n  =Hleft(tright)leftint_0^tgleft(sright)^topsigma_Pleft(stright)ds+int_0^tgleft(sright)^topdW_sright\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Some (lengthy) calculations yield the representation","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hleft(tright)^-1x_t-Hleft(sright)^-1x_s=Hleft(sright)^-1y_sGleft(stright)+int_s^tgleft(uright)^topleftsigma_Pleft(utright)du+dW_uright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with model function","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Gleft(stright)=int_s^tHleft(sright)^-1Hleft(uright)boldsymbol1du","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and auxilliary state variable process","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"y_t=Hleft(tright)left(int_0^tgleft(sright)^topgleft(sright)dsright)Hleft(tright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Separation of volatility and mean reversion.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In order to better separate volatility and mean reversion components, we set","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\ngleft(tright)  =Hleft(tright)^-1sigma_t\nHleft(stright)  =Hleft(tright)Hleft(sright)^-1\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =Hleft(stright)leftx_s+y_sGleft(stright)+int_s^tHleft(suright)^-1sigma_u^topleftsigma_uGleft(utright)du+dW_urightright\ny_t  =Hleft(stright)y_sHleft(stright)+int_s^tHleft(utright)sigma_u^topsigma_uHleft(utright)ds\nGleft(stright)  =int_s^tHleft(suright)boldsymbol1du\nsigma_Pleft(utright)  =sigma_uGleft(utright)\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Above representation is the basis for our hybrid model interface.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We note, that we also get the following equality for the drift terms","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"underbracey_sGleft(stright)+int_s^tHleft(suright)^-1sigma_u^topsigma_uGleft(utright)du_I_1left(tright)=underbraceint_s^tHleft(suright)^-1y_uboldsymbol1du_I_2left(tright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This property follows by differentiating both sides w.r.t. t. Then we get for the left side of the equation","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nI_1left(tright)  =y_sHleft(stright)boldsymbol1+int_s^tHleft(suright)^-1sigma_u^topsigma_uHleft(utright)boldsymbol1du\n  =y_sHleft(stright)boldsymbol1+Hleft(stright)^-1int_s^tHleft(utright)sigma_u^topsigma_uHleft(utright)boldsymbol1du\n  =y_sHleft(stright)boldsymbol1+Hleft(stright)^-1lefty_t-Hleft(stright)y_sHleft(stright)rightboldsymbol1\n  =Hleft(stright)^-1y_tboldsymbol1\n  =I_2left(tright)\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The alternative representation of the drift term is useful in some situations because the integrand does not depend on the upper boundary t. We get","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=Hleft(stright)leftx_s+int_s^tHleft(suright)^-1lefty_uboldsymbol1du+sigma_u^topdW_urightright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Integrated state variable.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In addition to the state variable x_t itself we are also interested in the integrated state variable z_t=boldsymbol1^topint_0^tx_sds. In order to derive the dynamics of the integrated state variable, we need to calculate","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nIleft(stright)  =int_s^tx_vdv\n  =int_s^tleft(Hleft(svright)leftx_s+int_s^vHleft(suright)^-1lefty_uboldsymbol1du+sigma_u^topdW_urightrightright)dv\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For the first term, we get","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"int_s^tHleft(svright)x_sdv=textdiagleft(Gleft(stright)right)x_s","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In order to simplify calculation for the second term we substitute dbarW_u=y_uboldsymbol1du+sigma_u^topdW_u. Then","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nint_s^tHleft(svright)int_s^vHleft(suright)^-1dbarW_udv  =int_s^tint_s^vHleft(uvright)dbarW_udv\n  =int_s^tleft(int_u^tHleft(uvright)dvright)dbarW_u\n  =int_s^ttextdiagleft(Gleft(utright)right)dbarW_u\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This yields","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Ileft(stright)=textdiagleft(Gleft(stright)right)x_s+int_s^ttextdiagleft(Gleft(utright)right)lefty_uboldsymbol1du+sigma_u^topdW_uright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With these preparations we get z_t=z_s+Gleft(stright)^topx_s+int_s^tGleft(utright)^toplefty_uboldsymbol1du+sigma_u^topdW_uright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Yield Curve Reconstruction","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We can derive future zero coupon bonds in terms of x_t and y_t as","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"P(tT)=fracP(0T)P(0t)expleft -G(tT)^topx_t-frac12G(tT)^topy_tG(tT)right","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and future forward rates as","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"f(tT)=f(0T)+boldsymbol1^topH(T)H(t)^-1leftx_t+y_tG(tT)right","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Also, we directly get the short rate representation","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r_t=f(0t)+boldsymbol1^topx_t","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"From the short rate we can also recontruct the bank account price process left(B_tright)_t as","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"B_t=e^int_0^tr_sds=frace^z_tPleft(0tright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The zero coupon bond formula is the basic building block for calculating future option payoffs. More details on HJM models are elaborated in Andersen/Piterbarg, Interest Rate Modeling, 2010, Sec. 4.4 and 4.5. The bank account representation is used for numeraire calculation as well as future asset price reconstruction.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Constant mean reversion specification.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"So far, we have not specified the structure of the matrix function Hleft(tright) in our separable HJM model. In order, to make the model tractable, we set","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hleft(tright)=textdiagleft(lefte^-chi_1tldotse^-chi_dtrightright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The parameters chi_1ldotschi_d represent the constant mean reversion parameters in the model.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With constant mean reversion parameters we can calculate","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hleft(stright)=textdiagleft(lefte^-chi_1left(t-sright)ldotse^-chi_dleft(t-sright)rightright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Gleft(stright)=leftfrac1-e^-chi_1left(t-sright)chi_1ldotsfrac1-e^-chi_dleft(t-sright)chi_dright^top","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Benchmark rates.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We choose d benchmark rates f_i(t)=f(tt+delta_i) (i=1ldotsd). The maturity terms delta_i represent the points on the yield curve that are selected to be modelled specifically. Consequently, delta_1 to delta_d should reasonably span the whole yield curve maturities relevant for pricing.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Furthermore, we denote","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"H^f(t)=left(beginarrayc\nhleft(t+delta_1right)^top\nvdots\nhleft(t+delta_dright)^top\nendarrayright)=left(beginarrayccc\ne^-chi_1left(t+delta_1right)  ldots  e^-chi_dleft(t+delta_1right)\nvdots    vdots\ne^-chi_1left(t+delta_dright)  ldots  e^-chi_dleft(t+delta_dright)\nendarrayright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"which yields","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"H(t)H^f(t)^-1=leftH^f(t)H(t)^-1right^-1=left(beginarrayccc\ne^-chi_1delta_1  ldots  e^-chi_ddelta_1\nvdots    vdots\ne^-chi_1delta_d  ldots  e^-chi_ddelta_d\nendarrayright)^-1","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Note that H(t)H^f(t)^-1 is independent of the observation time t. Consequently, the matrix inversion only needs to be evaluated once at inception of the model.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Benchmark rate volatility.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Model volatility is characterised by the volatility specification of the benchmark rates as","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^f=left(beginarrayccc\nsigma_t^f_1\n  ddots\n    sigma_t^f_d\nendarrayright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The benchmark rate dynamics are coupled by a dtimes d correlation matrix Gamma_f which is decomposed into","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Gamma_f=leftD^fright^topD^f","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For our specification we choose a time-homogenous correlation matrix. Hence, the matrix decomposition above only needs to be computed at inception of the model.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Given the above specifications the volatility of the HJM model is defined via","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^top=H(t)H^f(t)^-1sigma_t^fD^f(t)^top","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The volatility specification is chosen such that dynamics of the benchmark rates become","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"df_i(t)=O(dt)+sigma_t^f_1dU_i(t)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with dU(t)=D^f(t)^topdW(t). For details on the derivation of the benchmark rate dynamics see Andersen/Piterbarg, Interest Rate Modeling, 2010, Prop. 13.3.2.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Note that within our hybrid model framework, the correlation Gamma_f is part of the full risk factor correlation matrix Gamma. Consequently, for our hybrid model interface, we use the specification","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^top=H(t)H^f(t)^-1sigma_t^f","category":"page"},{"location":"introduction/simulation_framework/#Multi-factor-Gaussian-Model","page":"Simulation Framework","title":"Multi-factor Gaussian Model","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In order fully specify an interest rate model we need to define the dtimes d volatility process matrix left(sigma_tright)_t. By means of the benchmark forward rates f_i we already reduced this problem to the specification of the d individual benchmark rate volatility processes left(sigma_itright)_t. In this section, we give a first full specification of the benchmark rate volatility processes.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In a Gaussian model we assume deterministic volatility processes sigma_it=sigma_ileft(tright) for i=1ldotsd. In order to simplify analytics, er also assume that the volatility functions sigma_ileft(tright) are piece-wise constant. Then, also the model volatility sigma_t=sigmaleft(tright) is deterministic and piece-wise constant.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"An important consequence of this modelling choice is that the auxiliary state process y_t also becomes deterministic and easily computable. Assume yleft(sright) is known and sigmaleft(uright)=sigma is constant on the intervall left(stright). Then","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"yleft(sright)=Hleft(stright)yleft(sright)Hleft(stright)+int_s^tHleft(utright)sigma^topsigma Hleft(utright)ds","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The integral becomes","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nint_s^tHleft(utright)sigma^topsigma Hleft(utright)ds  =leftint_s^te^-chi_ileft(t-uright)leftsigma^topsigmaright_ije^-chi_jleft(t-uright)duright_ij=1ldotsd\n  =leftleftsigma^topsigmaright_ijint_s^te^-left(chi_i+chi_jright)left(t-uright)duright_ij=1ldotsd\n  =leftleftsigma^topsigmaright_ijleftfrac1-e^-left(chi_i+chi_jright)left(t-uright)chi_i+chi_jrightright_ij=1ldotsd\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With this formula we calculate and store left(yleft(t_kright)right)_k on the grid left(t_1t_2ldotsright) of piece-wise constant volatility values left(sigma_left(kright)right)_k. Then a value yleft(tright) for some t_k-1leq tt_k is calculated as","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"yleft(tright)=Hleft(t_k-1tright)yleft(t_k-1right)Hleft(t_k-1tright)+leftleftsigma_left(kright)^topsigma_left(kright)right_ijleftfrac1-e^-left(chi_i+chi_jright)left(t-t_k-1right)chi_i+chi_jrightright_ij=1ldotsd","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hybrid model interface.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In our hybrid model framework we need to take into account that we simulate in a measure other than the natural risk neutral measure for a given rates model. In such a situation need to take into account quanto adjustments. Denote left(W_t^nright)_t a Brownian motion under a common hybrid mode risk neutral measure. Girsanov's theorem yields that there is a process left(alpha_tright)_t and","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^n=W_t+int_0^talpha_sdt","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With this change of measure, we get","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=Hleft(stright)leftx_s+y_sGleft(stright)+int_s^tHleft(suright)^-1sigma_u^topleftsigma_uGleft(utright)du+leftdW_u^n-alpha_udurightrightright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =Hleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigmaleft(uright)^topleftsigmaleft(uright)Gleft(utright)-alpha_urightdu+\n  quad Hleft(stright)x_s+\n  quadint_s^tHleft(utright)sigmaleft(uright)^topdW_u^n\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Furthermore, we have for the integrated state variable","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nz_t  =z_s+Gleft(stright)^topx_s+int_s^tGleft(utright)^topleftyleft(uright)boldsymbol1du+sigmaleft(uright)^topleftdW_u^n-alpha_udurightright\n  =z_s+Gleft(stright)^topx_s+int_s^tGleft(utright)^topleftleftyleft(uright)boldsymbol1-sigmaleft(uright)^topalpha_urightdu+sigmaleft(uright)^topdW_u^nright\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"As a result, we find that we can specify our hybrid model state variable X_t^k and identify the model component functions Theta^kleft(cdotright), H^kleft(cdotright) and Sigma^kleft(cdotright) for a Gaussian model. We set","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t^k=leftbeginarrayc\nx_t\nz_t\nendarrayright=leftbeginarrayc\nx_t^1\nvdots\nx_t^d\nz_t\nendarrayright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nTheta^kleft(stright)  =leftbeginarrayc\nHleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigmaleft(uright)^topleftsigmaleft(uright)Gleft(utright)-alpha_urightdu\nint_s^tGleft(utright)^topleftyleft(uright)boldsymbol1-sigmaleft(uright)^topalpha_urightdu\nendarrayright\nH^kleft(stright)  =leftbeginarraycc\nHleft(stright)  0\nGleft(stright)^top  1\nendarrayright\nSigmaleft(uright)^top  =leftbeginarrayc\nHleft(utright)sigmaleft(uright)^top\nGleft(utright)^topsigmaleft(uright)^top\nendarrayright\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We note, that the drift function Theta^k is only state-independent if the quanto drift alpha_t is state-independent. This property is closely linked to the volatility assumptions of the foreign exchange model between rates model's currency and the hybrid model numeraire currency.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Alternative drift formula.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=Hleft(stright)leftx_s+int_s^tHleft(suright)^-1lefty_uboldsymbol1du+sigma_u^topleftdW_u^n-alpha_udurightrightright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =int_s^tHleft(utright)leftyleft(uright)boldsymbol1-sigmaleft(uright)^topalpha_urightdt+\n  quad Hleft(stright)x_s+\n  quadint_s^tHleft(utright)sigmaleft(uright)^topdW_u^n\nendaligned","category":"page"},{"location":"introduction/simulation_framework/#Tradeable-Asset-Models","page":"Simulation Framework","title":"Tradeable Asset Models","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this subsection we specify our component models for tradeable assets. Such assets are typically foreign exchange rates, equities, equity indices and inflation indices. We use the notation of foreign exchange rates models with domestic and foreign currency. An adaption to equity and inflation models is then straight forward.","category":"page"},{"location":"introduction/simulation_framework/#Hybrid-FX-Modelling-Framework","page":"Simulation Framework","title":"Hybrid FX Modelling Framework","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We consider the positive price process left(S_tright)_t of one unit of foreign currency measured by units of domestic currency. Moreover, denote left(B_t^dright)_t and left(B_t^fright)_t the bank account processes in domestic and foreign currency. The process left(S_tB_t^fright)_t represents the price process of the foreign currency bank account measured in units of domestic currency. This is a tradeable asset in domestic currency. The domestic currency risk-neutral measure uses the bank account left(B_t^dright)_t as numeraire. As a consequence, the process","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"left(fracS_tB_t^fB_t^dright)_t","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"must be a martingale.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The martingale property motivates the asset price process","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"S_t=fracB_t^dB_t^fe^x_t","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"for a normalised state variable process left(x_tright)_t. For the state variable we assume the dynamics","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=-frac12int_0^tsigma_s^2ds+int_0^tsigma_sdW_s","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, left(sigma_tright)_t is a scalar volatility process adapted to cal F_t, and left(W_tright)_t is a scalar Brownian motion in the domestic currency risk-neutral measure.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Note that above specification of the process left(x_tright)_t covers a wide range of models. The models are distinguished by the modelling of the volatility process left(sigma_tright)_t. The representation S_t=left(B_t^dB_t^fright)e^x_t allows for a clear decoupling of interest rate modelling and hybrid asset modelling. For the sake of clarity we can also write the dynamics of left(S_tright)_t explicitely as","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"S_t=S_s+int_s^tS_uleft(r_u^d-r_u^fright)du+int_s^tsigma_udW_u","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with domestic and foreign short rates r_u^d and r_u^f.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"There is an important consequence from the asset price representation S_t=left(B_t^dB_t^fright)e^x_t . In order to reconstruct future asset prices S_t the asset model must know its corresponding domestic and foreign interest rate model. Moreover, the asset model also requires the integrated state variables z_t^d and z_t^f in order to allow for the domestic and foreign interest rate model to calculate B_t^d and B_t^f.","category":"page"},{"location":"introduction/simulation_framework/#Quanto-Adjustment","page":"Simulation Framework","title":"Quanto Adjustment","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"So far, we implicitly assumed that interest rate models are formulated in the risk-neutral measure of their respective currency. Similarly, we also assumed that asset models are formulated in their respective domestic currency risk neutral measure.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In a hybrid modelling framework for various currencies we need to decide on a common numeraire currency, the corresponding numeraire price process and the common martingale measure. Such a common martingale measure in general does not coincide with the risk-neutral measures that are typically used to formulate foreign currency component models. Consequently, we need to incorporate a change of measure for such foreign currency component models.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this section, we formulate the change of measure from a given risk neutral measure to a common numeraire currency risk neutral measure. The change of measure is formulated in a rather general way in order to apply it later on for various component models. We consider a domestic currency with some asset price process X_t^d. For practical purposes, such an asset is typically","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"a domestic zero coupon bond with price process   left(P^dleft(tTright)right)_t or\nforeign currency bank account measured in units of domestic currency   with price process left(S_t^f-dB_t^fright)_t.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The corresponding domestic currency discounted asset process is denoted left(tildeX_t^dright)_t with","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"tildeX_t^d=fracX_t^dB_t^d","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Without loss of generality, we assume that the discounted asset price process follows the dynamics","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"fracdtildeX_t^dtildeX_t^d=leftsigma_t^X^dright^topdW_t^d","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"where left(sigma_t^X^dright)_t is an adapted process and left(W_t^dright)_t is a n^d-dimensional Brownian motion in domestic currency risk neutral measure mathbbQ^d.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In addition to the domestic (and foreign) currency we consider a numeraire currency with bank account prices B_t^n. The price of one unit domestic currency measured by units of numeraire currency is denoted as S_t^d-n. The price of our domestic currency asset measured in units of numeraire currency is S_t^d-nX_t^d. Under the numeraire currency risk-neutral measure mathbbQ^n with numeraire price process left(B_t^nright)_t we can also formulate the discounted price process left(M_tright)_t with M_t=fracS_t^d-nP^dleft(tTright)B_t^n No-arbitrage arguments require that left(M_tright)_t is a mathbbQ^n-martingale.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Using our hybrid FX modelling framework we can write M_t as","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"M_t=fracB_t^nB_t^de^x_t^d-nfracX_t^dB_t^n=fracX_t^dB_t^de^x_t^d-n=tildeX_t^de^x_t^d-n","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with domestic numeraire FX model state variable process left(x_t^d-nright)_t. In order to further simplify notation, we set Y_t^d-n=e^x_t^d-n and note that","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nY_t^d-n  =Y_0^d-n+int_0^tY_s^d-ndx_s^d-n+frac12int_0^tY_s^d-ndleftlangle x_s^d-nx_s^d-nrightrangle \n  =Y_0^d-n+int_0^tY_s^d-nsigma_s^d-ndW_s^d-n\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this representation, left(sigma_t^d-nright)_t is the FX volatility process of left(S_t^d-nright)_t and left(W_t^d-nright)_t is a Brownian motion in numeraire currency risk neutral measure. Above calculation also demonstrates that left(Y_t^d-nright)_t is a mathbbQ^n-martingale driven by an Ito integral.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Now, Ito product rule yields for the process left(M_tright)_t that","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"M_t=M_0+int_0^ttildeX_s^ddY_s^d-n+int_0^tY_s^d-ndtildeX_s^d+int_0^tdleftlangle tildeX_s^dY_s^d-nrightrangle ","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The first Ito integral is","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_1=int_0^ttildeX_s^ddY_s^d-n=int_0^tM_ssigma_s^d-ndW_s^d-n","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This term is a mathbbQ^n-martingale. For the second integral we get","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_2=int_0^tY_s^d-ndtildeX_s^d=int_0^tM_sleftsigma_s^X^dright^topdW_s^d","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This term is a mathbbQ^d-martingale because by construction left(W_t^dright)_t is a Brownian motion in the domestic currency risk neutral measure. for the third integral we get","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_3=int_0^tdleftlangle tildeX_s^dY_s^d-nrightrangle =int_0^tleftlangle dtildeX_s^ddY_s^d-nrightrangle =int_0^tM_sleftlangle leftsigma_s^X^dright^topdW_s^dsigma_s^d-ndW_s^d-nrightrangle ","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Girsanov's theorem yields that there is an adapted process left(alpha_tright)_t such that","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^dn=W_t^d+int_0^talpha_sds","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"is a Brownian motion under mathbbQ^n. This yields","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_2=int_0^tM_sleftsigma_t^X^dright^topleft(dW_s^dn-alpha_sdsright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For the third integral, we can now use linearity of covariance process and the property, that the quadratic variation of int_0^talpha_sds vanishes. This gives","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nI_3  =int_0^tM_sleftlangle leftsigma_s^X^dright^topleft(dW_s^dn-alpha_sdsright)sigma_s^d-ndW_s^d-nrightrangle \n  =int_0^tM_sleftlangle leftsigma_s^X^dright^topdW_s^dnsigma_s^d-ndW_s^d-nrightrangle \nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The Brownian motion increments are correlated such that","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"leftlangle dW_s^dndW_s^d-nrightrangle =Gamma^X^dS^d-ndt","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with instantaneous correlation matrix Gamma^X^dS^d-n of shape left(n^d1right). This leads to the representation","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_3=int_0^tM_sleftsigma_s^X^dright^topGamma^X^dS^d-nsigma_s^d-nds","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Recall that left(M_tright)_t is a mathbbQ^n-martingale. This requires that","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_2+I_3=int_0^tM_sleftsigma_t^X^dright^topleft(dW_s^dn+leftGamma^X^dS^d-nsigma_s^d-n-alpha_srightdsright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"is a mathbbQ^n-martingale. This leads to the condition","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"alpha_t=Gamma^X^dS^d-nsigma_t^d-n","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and the change of measure formula","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^dn=W_t^d+int_0^tGamma^X^dS^d-nsigma_s^d-nds","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Quanto adjustment for rates models.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For Gaussian rates models in a domestic currency we have","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Theta^kleft(stright)=leftbeginarrayc\nHleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigma^dleft(uright)^topleftsigma^dleft(uright)Gleft(utright)-alpha_urightdu\nint_s^tGleft(utright)^topleftyleft(uright)boldsymbol1-sigma^dleft(uright)^topalpha_urightdu\nendarrayright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Assets prices are zero coupon bonds, X_t^d=P^dleft(tTright) driven by the state variable x_t^d. Consequently, the quanto adjustment drift becomes","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"alpha_t=Gamma^x^dS^d-nsigma_t^d-n","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, Gamma^x^dS^d-n summarises the instantaneous correlations of the interest rate risk factors and the FX risk factor. Assuming FX volatility is deterministic with sigma_t^d-n=sigma^d-nleft(tright), we get","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Theta^kleft(stright)=leftbeginarrayc\nHleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigma^dleft(uright)^topleftsigma^dleft(uright)Gleft(utright)-Gamma^x^dS^d-nsigma_t^d-nrightdu\nint_s^tGleft(utright)^topleftyleft(uright)boldsymbol1-sigma^dleft(uright)^topGamma^x^dS^d-nsigma_t^d-nrightdu\nendarrayright","category":"page"},{"location":"introduction/simulation_framework/#Lognormal-Model","page":"Simulation Framework","title":"Lognormal Model","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We construct a basic asset model by assuming that the volatility process left(sigma_t^f-dright)_t is deterministic, i.e. sigma_t^f-d=sigma^f-dleft(tright). Then","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t^f-d=x_s^f-d-frac12int_s^tsigma^f-dleft(uright)^2du+int_s^tsigma^f-dleft(uright)dW_u^d","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"If the domestic currency differs from the numeraire currency then we need to incorporate quanto adjustment with","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^dn=W_t^d+int_0^tGamma^S^f-dS^d-nsigma_s^d-nds","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This yields","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t^f-d  =x_s^f-d-frac12int_s^tsigma^f-dleft(uright)^2du+int_s^tsigma^f-dleft(uright)leftdW_u^dn-Gamma^S^f-dS^d-nsigma_u^d-nduright\n  =x_s^f-d-frac12int_s^tsigma^f-dleft(uright)leftsigma^f-dleft(uright)+2Gamma^S^f-dS^d-nsigma_u^d-nrightdu+int_s^tsigma^f-dleft(uright)dW_u^dn\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this model setting the state variable process left(x_t^f-dright)_t has normal terminal distributions. Consequently, e^x_t is lognormal. If interest rates are modelled by (multi-factor) Gaussian models then B_t^d and B_t^f are also lognormal. As a result, we find that the asset price S_t is also lognormal.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In the lognormal model, our generic hybrid model state variable X_t^k and component functions Theta^kleft(cdotright), H^kleft(cdotright) and Sigma^kleft(cdotright) are easily identified. We set","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nX_t^k  =leftx_tright\nTheta^kleft(stright)  =left-frac12int_s^tsigma^f-dleft(uright)leftsigma^f-dleft(uright)+2Gamma^S^f-dS^d-nsigma_u^d-nrightduright\nH^kleft(stright)  =left1right\nSigma^kleft(uright)^top  =leftsigma^f-dleft(uright)right\nendaligned","category":"page"},{"location":"introduction/simulation_framework/#Future-Index/Price-Models","page":"Simulation Framework","title":"Future Index/Price Models","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this section we specify models for Future index curves or Future price curves. Such models are typical for commodity derivatives.","category":"page"},{"location":"introduction/simulation_framework/#Markov-Model-Specification","page":"Simulation Framework","title":"Markov Model Specification","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The model is specified following  Andersen 2008, eq. (10) - (12). We keep notation as close as possible to the HJM model specification used for interest rates.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We denote","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Fleft(tTright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"a Future index or future price curve. The Future price is denominated in units of domestic currency. A key proposition is that for tleq T the future price left(Fleft(tTright)right)_t is a martingale in the domestic currency risk-neutral measure. The martingale property and the theory of separable HJM models motivate the specification","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Fleft(tTright) = \nFleft(0Tright)exp\n  left \n    hleft(tTright)^top\n    left\n        x_t+frac12y_tleft(I-Hleft(tTright)right)boldsymbol1\n    right\nright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with d-dimensional state variable process left(x_tright)_t and dtimes d-dimensional auxiliary (variance) variable process left(y_tright)_t. State and auxiliary variable follow the dynamics","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\n  x_t =\n  Hleft(stright)\n  left\n    x_s+int_s^tHleft(suright)^-1\n    left\n        frac12\n        left(\n            y_uchileft(uright)-sigma_u^topsigma_u\n        right)\n        boldsymbol1du+sigma_u^topdW_u^d\n    right\n  right\n  y_t =\n  Hleft(stright)y_sHleft(stright)+\n  int_s^tHleft(utright)sigma_u^topsigma_uHleft(utright)du\n  endaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Quanto-adjustment.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"If the domestic currency differs from the numeraire currency then we need to incorporate the change of measure","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\n  W_t^dn\n  = W_t^d+int_0^talpha_sds\n  = W_t^d+int_0^tGamma^X^dS^d-nsigma_s^d-nds\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This yields the state variable representation with Quanto adjustment as","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t =\nHleft(stright)\nleft\n  x_s + \n  int_s^tHleft(suright)^-1\n  left\n    frac12left(y_uchileft(uright)boldsymbol1 -\n    sigma_u^topleftsigma_uboldsymbol1-2alpha_urightright)du +\n    sigma_u^topdW_u^dn\n  right\nright","category":"page"},{"location":"introduction/simulation_framework/#Multi-factor-Gaussian-Model-2","page":"Simulation Framework","title":"Multi-factor Gaussian Model","text":"","category":"section"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"A critical aspect is the specification of the volatility process left(sigma_tright)_t. For the Gaussian Future index model we re-use the methodology from the interest rate model. That is, we assume constant mean reversion parameters chi_1ldotschi_d and benchmark times delta_1ldotsdelta_d. Moreover, denote Gamma^F=leftGamma_ij^Fright the instantaneous correlations between Future prices Fleft(tt+delta_iright) and Fleft(tt+delta_jright).","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then we set","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^top=H(t)H^F(t)^-1sigma_t^FleftD^F(t)right^top","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nH(t)H^F(t)^-1  =left(beginarrayccc\ne^-chi_1delta_1  ldots  e^-chi_ddelta_1\nvdots    vdots\ne^-chi_1delta_d  ldots  e^-chi_ddelta_d\nendarrayright)^-1\nleftD^F(t)right^topD^F(t)  =Gamma^F\nendaligned","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This methodology reduces the modelling to the specification of a diagonal matrix of benchmark price volatilities","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^F=left(beginarrayccc\nsigma_t^F_1\n  ddots\n    sigma_t^F_d\nendarrayright)","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For the Gaussian Future index model, we further assume piece-wise constant volatility functions sigma_t^F_i=sigma_ileft(tright). Then, also the model volatility sigma_t=sigmaleft(tright) is deterministic and piece-wise constant. With this specification the auxilliary variable process left(y_tright)_t is deterministic as well. And we can re-use the machinery from interest rate models to calculate y_t=yleft(tright).","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hybrid model interface.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We specify the hybrid model state variable X_t^k and identify the model component functions Theta^kleft(cdotright), H^kleft(cdotright) and Sigma^kleft(cdotright) for a Gaussian Future price model.","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We set","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t^k=leftbeginarrayc\nx_t^1\nvdots\nx_t^d\nendarrayright","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then","category":"page"},{"location":"introduction/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nTheta^kleft(stright)\n= frac12int_s^tHleft(utright)\n   left\n     left(\n        yleft(uright)chiboldsymbol1-\n        left\n            sigmaleft(uright)^topsigmaleft(uright)boldsymbol1 - \n            2sigmaleft(uright)^topalphaleft(uright)\n        right\n     right) du\n    right\nH^kleft(stright) = Hleft(stright)\nSigma^kleft(uright)^top\n= Hleft(utright)sigmaleft(uright)^top\nendaligned","category":"page"},{"location":"serialisation/serialisation/#Serialisation-Functions","page":"Serialisation Functions","title":"Serialisation Functions","text":"","category":"section"},{"location":"serialisation/serialisation/","page":"Serialisation Functions","title":"Serialisation Functions","text":"In this section we document methods for serialising and de-serialising DiffFusion.jl objects.","category":"page"},{"location":"serialisation/serialisation/","page":"Serialisation Functions","title":"Serialisation Functions","text":"We serialise objects into ordered dictionaries of the general form","category":"page"},{"location":"serialisation/serialisation/","page":"Serialisation Functions","title":"Serialisation Functions","text":"typename : TypeName\nconstructor : function_name\nfield_name_1 : field_value_1\n...\nfield_name_n : field_value_n","category":"page"},{"location":"serialisation/serialisation/","page":"Serialisation Functions","title":"Serialisation Functions","text":"Dictionary keys are strings, dictionary values are strings, numbers o ordered dictionaries of component structures.","category":"page"},{"location":"serialisation/serialisation/","page":"Serialisation Functions","title":"Serialisation Functions","text":"We utilise multiple dispatch to specify serialisation recursively.","category":"page"},{"location":"serialisation/serialisation/#Object-Serialisation","page":"Serialisation Functions","title":"Object Serialisation","text":"","category":"section"},{"location":"serialisation/serialisation/#DiffFusion.serialise","page":"Serialisation Functions","title":"DiffFusion.serialise","text":"serialise(o::Any)\n\nSerialise an arbitrary object.\n\n\n\n\n\nserialise(o::Future)\n\nSerialise a Future object from a remotecall(...).\n\nThis operation is blocking. We require that the result is calculated such that it actually can be serialised.\n\n\n\n\n\nserialise(o::Nothing)\n\nSerialise Nothing.\n\n\n\n\n\nserialise(o::AbstractString)\n\nSerialise String.\n\n\n\n\n\nserialise(o::Integer)\n\nSerialise Integer.\n\n\n\n\n\nserialise(o::ModelValue)\n\nSerialise Float.\n\n\n\n\n\nserialise(o::AbstractDict)\n\nSerialise dictionaries.\n\n\n\n\n\nserialise(o::AbstractVector)\n\nSerialise vectors.\n\n\n\n\n\nserialise(o::AbstractMatrix)\n\nSerialise matrices.\n\n\n\n\n\nserialise(o::AbstractArray)\n\nSerialise d-dimensional arrays.\n\n\n\n\n\nserialise(o::FlatForward)\n\nSerialise FlatForward.\n\n\n\n\n\nserialise(o::ZeroCurve)\n\nSerialise ZeroCurve.\n\n\n\n\n\nserialise(o::LinearZeroCurve)\n\nSerialise LinearZeroCurve.\n\n\n\n\n\nserialise(o::BackwardFlatVolatility)\n\nSerialise BackwardFlatVolatility.\n\n\n\n\n\nserialise(o::PiecewiseFlatParameter)\n\nSerialise PiecewiseFlatParameter.\n\n\n\n\n\nserialise(o::CorrelationHolder)\n\nSerialise CorrelationHolder.\n\n\n\n\n\nserialise(o::Context)\n\nSerialise model Context.\n\n\n\n\n\nserialise(o::BenchmarkTimesScaling)\n\nSerialise a BenchmarkTimesScaling enumeration object.\n\n\n\n\n\nserialise(o::GaussianHjmModel)\n\nSerialise GaussianHjmModel.\n\n\n\n\n\nserialise(o::LognormalAssetModel)\n\nSerialise LognormalAssetModel.\n\n\n\n\n\nserialise(o::CevAssetModel)\n\nSerialise CevAssetModel.\n\n\n\n\n\nserialise(o::SimpleModel)\n\nSerialise SimpleModel.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.serialise_struct","page":"Serialisation Functions","title":"DiffFusion.serialise_struct","text":"serialise_struct(o::Any)\n\nCreate a dictionary from an arbitrary struct object\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion._serialise_key_references","page":"Serialisation Functions","title":"DiffFusion._serialise_key_references","text":"Identifyiers used to specify a reference for serialisation.\n\n\n\n\n\n","category":"constant"},{"location":"serialisation/serialisation/#DiffFusion.serialise_key","page":"Serialisation Functions","title":"DiffFusion.serialise_key","text":"serialise_key(alias::String)\n\nSerialise an alias as a key.\n\nThis is required to capture object dependencies for de-serialisation. \n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.serialise_as_list","page":"Serialisation Functions","title":"DiffFusion.serialise_as_list","text":"serialise_as_list(o::SimpleModel)\n\nSerialise SimpleModel as a list and capture references.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#Object-De-Serialisation","page":"Serialisation Functions","title":"Object De-Serialisation","text":"","category":"section"},{"location":"serialisation/serialisation/#DiffFusion.deserialise","page":"Serialisation Functions","title":"DiffFusion.deserialise","text":"deserialise(o::String, d::Union{AbstractDict, Nothing} = nothing)\n\nDe-serialise strings.\n\nWe incorporate some logic to handle external references.\n\nWe allow that the repository disctionary d contains remote call Futures. However, we want to ensure that the method returns actual objects. Thus, we fetch any Future within this method.\n\n\n\n\n\ndeserialise(o::Number, d::Union{AbstractDict, Nothing} = nothing)\n\nDe-serialise numbers.\n\n\n\n\n\ndeserialise(o::AbstractDict, d::Union{AbstractDict, Nothing} = nothing)\n\nDe-serialise dictionary.\n\n\n\n\n\ndeserialise(o::AbstractVector, d::Union{AbstractDict, Nothing} = nothing)\n\nDe-serialise vector or matrix.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.deserialise_object","page":"Serialisation Functions","title":"DiffFusion.deserialise_object","text":"deserialise_object(o::OrderedDict, d::Union{AbstractDict, Nothing} = nothing)\n\nDe-serialise objects.\n\nCaution, this method bares the potential risk of code injection.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.deserialise_from_list","page":"Serialisation Functions","title":"DiffFusion.deserialise_from_list","text":"deserialise_from_list(dict_list::AbstractVector)\n\nDe-serialise a list of objects and capture references.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.array","page":"Serialisation Functions","title":"DiffFusion.array","text":"array(data::AbstractVector, dims)\n\nConvert vector data into d-dimensional array. Here, d is length(dims).\n\nParameter dims is a vector or tuple of number of elements per dimension.\n\nData vector data must be of appropriate length, i.e. length(data) == prod(dims).\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#Rebuild-Models","page":"Serialisation Functions","title":"Rebuild Models","text":"","category":"section"},{"location":"serialisation/serialisation/","page":"Serialisation Functions","title":"Serialisation Functions","text":"This subsection contains methods to extract term structures and re-build models.","category":"page"},{"location":"serialisation/serialisation/","page":"Serialisation Functions","title":"Serialisation Functions","text":"Methods are intended to be used for sensitivity calculations. For that purpose we need to identify model parameters as inputs to the valuation function.","category":"page"},{"location":"serialisation/serialisation/","page":"Serialisation Functions","title":"Serialisation Functions","text":"Model parameters for a model m::Model are stored in a Dict{String, Any} of the form","category":"page"},{"location":"serialisation/serialisation/","page":"Serialisation Functions","title":"Serialisation Functions","text":"\"type\" => typeof(m),\n\"alias\" => m.alias,\n[parameter identifier] => [parameter value(s)]\n...","category":"page"},{"location":"serialisation/serialisation/#DiffFusion.model_parameters","page":"Serialisation Functions","title":"DiffFusion.model_parameters","text":"model_parameters(m::GaussianHjmModel)\n\nExtract model parameters from GaussianHjmModel.\n\n\n\n\n\nmodel_parameters(m::LognormalAssetModel)\n\nExtract model parameters from LognormalAssetModel.\n\n\n\n\n\nmodel_parameters(m::CevAssetModel)\n\nExtract model parameters from CevAssetModel.\n\n\n\n\n\nmodel_parameters(m::SimpleModel)\n\nExtract model parameters from SimpleModel.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.build_model","page":"Serialisation Functions","title":"DiffFusion.build_model","text":"build_model(\n     alias::String,\n     param_dict::Dict,\n     model_dict::Dict,\n     )\n\nRe-build a model from model parameters dictionary.\n\nAlias identifies the model which is to be build. Input parameter term structures are stored in paramdict. The modeldict is used to reference quanto models.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.termstructure_values","page":"Serialisation Functions","title":"DiffFusion.termstructure_values","text":"termstructure_values(ts_dict::AbstractDict)\n\nExtract term structure labels and values from term structure dictionary\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.termstructure_dictionary!","page":"Serialisation Functions","title":"DiffFusion.termstructure_dictionary!","text":"termstructure_dictionary!(\n    ts_dict::AbstractDict,\n    ts_labels::AbstractVector,\n    ts_values::AbstractVector,\n    )\n\nRe-build term structure dictionary from labels and values.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.model_volatility_values","page":"Serialisation Functions","title":"DiffFusion.model_volatility_values","text":"model_volatility_values(\n    alias::String,\n    param_dict::Dict,\n    )\n\nExtract volatility labels and values from model parameters.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.model_parameters!","page":"Serialisation Functions","title":"DiffFusion.model_parameters!","text":"model_parameters!(\n    param_dict::Dict,\n    param_labels::AbstractVector,\n    param_values::AbstractVector,\n    )\n\nRe-build model parameter dictionary from volatility labels and values.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#Read-Term-Structures-From-CSV-Files","page":"Serialisation Functions","title":"Read Term Structures From CSV Files","text":"","category":"section"},{"location":"serialisation/serialisation/#DiffFusion.read_zero_curves","page":"Serialisation Functions","title":"DiffFusion.read_zero_curves","text":"read_zero_curves(\n    source,\n    delim::AbstractChar,\n    method_alias::String = \"LINEAR\"\n    )\n\nRead times and values from CSV file and create ZeroCurve.\n\nArguments source and delim are passed on to DelimitedFiles.readdlm.\n\nmethod_alias is the interpolation string used in interpolation_methods.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.read_volatilities","page":"Serialisation Functions","title":"DiffFusion.read_volatilities","text":"read_volatilities(\n    source,\n    delim::AbstractChar,\n    )\n\nRead times and values from CSV file and create scalar-valued BackwardFlatVolatility.\n\nArguments source and delim are passed on to DelimitedFiles.readdlm.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.read_volatility","page":"Serialisation Functions","title":"DiffFusion.read_volatility","text":"read_volatility(\n    source,\n    delim::AbstractChar,\n    )\n\nRead times and values from CSV file and create a single vector-valued BackwardFlatVolatility.\n\nArguments source and delim are passed on to DelimitedFiles.readdlm.\n\nTermstructure alias is read from the first data column header.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.read_parameters","page":"Serialisation Functions","title":"DiffFusion.read_parameters","text":"read_parameters(\n    source,\n    delim::AbstractChar,\n    param_func::Function = forward_flat_parameter,\n    )\n\nRead times and values from CSV file and create scalar-valued ParameterTermstructures.\n\nArguments source and delim are passed on to DelimitedFiles.readdlm.\n\nconstructor is the constructor called to create the term structure. It is used to apply method to read ForwardFlatParameter and BackwardFlatParameter.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#DiffFusion.read_correlations","page":"Serialisation Functions","title":"DiffFusion.read_correlations","text":"read_correlations(\n    source,\n    delim::AbstractChar,\n    )\n\nRead factor aliases and correlation values and setup a CorrelationHolder.\n\nArguments source and delim are passed on to DelimitedFiles.readdlm.\n\n\n\n\n\n","category":"function"},{"location":"simulations/simulations/#Monte-Carlo-Simulations","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"","category":"section"},{"location":"simulations/simulations/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"In this section we document data structures and methods for Monte Carlo  simulation.","category":"page"},{"location":"simulations/simulations/#Simulation-Types","page":"Monte Carlo Simulations","title":"Simulation Types","text":"","category":"section"},{"location":"simulations/simulations/#DiffFusion.Simulation","page":"Monte Carlo Simulations","title":"DiffFusion.Simulation","text":"struct Simulation\n    model::Model\n    times::AbstractVector\n    X::AbstractArray\n    dZ::Union{AbstractArray, Nothing}\nend\n\nA Simulation object represents the result of a Monte Carlo simulation.\n\nElements are:\n\nmodel - the model used for simulation.\ntimes - vector of simulation times starting with 0.\nX - tensor of size (N_1, N_2, N_3) and type ModelValue where\nN_1 is length(m.state_alias),\nN_2 is number of Monte Carlo paths,\nN_3 is length(times).\ndZ - Brownian motion increments.\n\n\n\n\n\n","category":"type"},{"location":"simulations/simulations/#DiffFusion.pseudo_brownian_increments","page":"Monte Carlo Simulations","title":"DiffFusion.pseudo_brownian_increments","text":"pseudo_brownian_increments(\n    n_states::Int,\n    n_paths::Int,\n    n_times::Int,  # without zero\n    seed::Int = 271828182846,\n    )\n\nA simple method to generate Brownian motion increments.\n\n\n\n\n\n","category":"function"},{"location":"simulations/simulations/#DiffFusion.sobol_brownian_increments","page":"Monte Carlo Simulations","title":"DiffFusion.sobol_brownian_increments","text":"sobol_brownian_increments(\n    n_states::Int,\n    n_paths::Int,\n    n_times::Int,  # without zero\n    )\n\nGenerate Brownian motion increments via Sobol sequence.\n\n\n\n\n\n","category":"function"},{"location":"simulations/simulations/#DiffFusion.simple_simulation","page":"Monte Carlo Simulations","title":"DiffFusion.simple_simulation","text":"simple_simulation(\n    model::Model,\n    ch::CorrelationHolder,\n    times::AbstractVector,\n    n_paths::Int;\n    with_progress_bar::Bool = true,\n    brownian_increments::Function = pseudo_brownian_increments,\n    store_brownian_increments::Bool = false,\n    )\n\nA simple Monte Carlo simulation method assuming all model components are state-independent.\n\n\n\n\n\n","category":"function"},{"location":"simulations/simulations/#DiffFusion.diagonal_simulation","page":"Monte Carlo Simulations","title":"DiffFusion.diagonal_simulation","text":"diagonal_simulation(\n    model::Model,\n    ch::CorrelationHolder,\n    times::AbstractVector,\n    n_paths::Int;\n    with_progress_bar::Bool = true,\n    brownian_increments::Function = pseudo_brownian_increments,\n    store_brownian_increments::Bool = false,\n    )\n\nA Monte Carlo simulation method assuming all model components are diagonal models.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/yield_curves/#Yield-Curves","page":"Yield Curves","title":"Yield Curves","text":"","category":"section"},{"location":"termstructures/yield_curves/#Yield-Term-Structure-Types","page":"Yield Curves","title":"Yield Term Structure Types","text":"","category":"section"},{"location":"termstructures/yield_curves/#DiffFusion.YieldTermstructure","page":"Yield Curves","title":"DiffFusion.YieldTermstructure","text":"abstract type YieldTermstructure <: Termstructure end\n\nAn abstract yield term structure that provides methods to calculate discount factors zero rates and forward rates.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/yield_curves/#DiffFusion.FlatForward","page":"Yield Curves","title":"DiffFusion.FlatForward","text":"struct FlatForward <: YieldTermstructure\n    alias::String\n    rate\nend\n\nA constant yield term structure.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/yield_curves/#DiffFusion.flat_forward","page":"Yield Curves","title":"DiffFusion.flat_forward","text":"flat_forward(alias::String, rate)\n\nCreate a FlatForward yield curve.\n\n\n\n\n\nflat_forward(rate)\n\nCreate a FlatForward yield curve without alias.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/yield_curves/#DiffFusion.ZeroCurve","page":"Yield Curves","title":"DiffFusion.ZeroCurve","text":"struct ZeroCurve <: YieldTermstructure\n    alias::String\n    times::AbstractVector\n    values::AbstractVector\n    interpolation\nend\n\nA yield term structure based on interpolated continuous compounded zero rates.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/yield_curves/#DiffFusion.zero_curve","page":"Yield Curves","title":"DiffFusion.zero_curve","text":"zero_curve(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    interp_method = (x,y) -> linear_interpolation(x, y, extrapolation_bc = Line()),\n    )\n\nCreate a ZeroCurve object.\n\n\n\n\n\nzero_curve(\n    times::AbstractVector,\n    values::AbstractVector,\n    interp_method = (x,y) -> linear_interpolation(x, y, extrapolation_bc = Line()),\n    )\n\nCreate a ZeroCurve object without alias.\n\n\n\n\n\nzero_curve(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    method_alias::String,\n    )\n\nCreate a ZeroCurve object using interpolation string.\n\n\n\n\n\nzero_curve(\n    times::AbstractVector,\n    values::AbstractVector,\n    method_alias::String,\n    )\n\nCreate a ZeroCurve object using interpolation string.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/yield_curves/#DiffFusion.LinearZeroCurve","page":"Yield Curves","title":"DiffFusion.LinearZeroCurve","text":"struct LinearZeroCurve <: YieldTermstructure\n    alias::String\n    times::AbstractVector\n    values::AbstractVector\nend\n\nA yield term structure based on continuous compounded zero rates with linear interpolation and flat extrapolation.\n\nThis curve aims at mitigating limitations of Zygote and ZeroCurve.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/yield_curves/#DiffFusion.linear_zero_curve","page":"Yield Curves","title":"DiffFusion.linear_zero_curve","text":"linear_zero_curve(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a LinearZeroCurve.\n\n\n\n\n\nlinear_zero_curve(\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a LinearZeroCurve with empty alias.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/yield_curves/#Functions","page":"Yield Curves","title":"Functions","text":"","category":"section"},{"location":"termstructures/yield_curves/#Discount-Factor-Calculation","page":"Yield Curves","title":"Discount Factor Calculation","text":"","category":"section"},{"location":"termstructures/yield_curves/","page":"Yield Curves","title":"Yield Curves","text":"Call operator for YieldTermstructure is defined as","category":"page"},{"location":"termstructures/yield_curves/","page":"Yield Curves","title":"Yield Curves","text":"(ts::YieldTermstructure)(args...) = discount(ts, args...)","category":"page"},{"location":"termstructures/yield_curves/#DiffFusion.discount-Tuple{DiffFusion.YieldTermstructure, Number}","page":"Yield Curves","title":"DiffFusion.discount","text":"discount(ts::YieldTermstructure, t::ModelTime)\n\nReturn the discount factor with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/yield_curves/#DiffFusion.discount-Tuple{DiffFusion.FlatForward, Number}","page":"Yield Curves","title":"DiffFusion.discount","text":"discount(ts::FlatForward, t::ModelTime)\n\nCalculate discount factor.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/yield_curves/#DiffFusion.discount-Tuple{DiffFusion.ZeroCurve, Number}","page":"Yield Curves","title":"DiffFusion.discount","text":"discount(ts::ZeroCurve, t::ModelTime)\n\nCalculate discount factor.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/yield_curves/#DiffFusion.discount-Tuple{DiffFusion.LinearZeroCurve, Number}","page":"Yield Curves","title":"DiffFusion.discount","text":"discount(ts::LinearZeroCurve, t::ModelTime)\n\nCalculate discount factor.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/yield_curves/#Zero-Rate-Calculation","page":"Yield Curves","title":"Zero Rate Calculation","text":"","category":"section"},{"location":"termstructures/yield_curves/#DiffFusion.zero_rate-Tuple{DiffFusion.YieldTermstructure, Number}","page":"Yield Curves","title":"DiffFusion.zero_rate","text":"zero_rate(ts::YieldTermstructure, t::ModelTime)\n\nReturn the continuous compounded zero rate as of today with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/yield_curves/#DiffFusion.zero_rate-Tuple{DiffFusion.YieldTermstructure, Number, Number}","page":"Yield Curves","title":"DiffFusion.zero_rate","text":"zero_rate(ts::YieldTermstructure, t0::ModelTime, t1::ModelTime)\n\nReturn the continuous compounded zero rate over a period t0 to t1.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/yield_curves/#Forward-Rate-Calculation","page":"Yield Curves","title":"Forward Rate Calculation","text":"","category":"section"},{"location":"termstructures/yield_curves/#DiffFusion.forward_rate","page":"Yield Curves","title":"DiffFusion.forward_rate","text":"forward_rate(ts::YieldTermstructure, t::ModelTime, dt=1.0e-6)\n\nReturn the instantaneous forward rate with observation time t.\n\n\n\n\n\n","category":"function"},{"location":"additional_functions/additional_functions/#Additional-Functions","page":"Additional Functions","title":"Additional Functions","text":"","category":"section"},{"location":"additional_functions/additional_functions/","page":"Additional Functions","title":"Additional Functions","text":"In this section we document additional functions.","category":"page"},{"location":"additional_functions/additional_functions/#DiffFusion.alias","page":"Additional Functions","title":"DiffFusion.alias","text":"alias(ts::Termstructure)\n\nReturn the term structure's alias.\n\n\n\n\n\nalias(m::Model)\n\nReturn the model's own alias. This is the default implementation.\n\n\n\n\n\nalias(m::MarkovFutureModel)\n\nReturn the model's own alias. This is the default implementation.\n\n\n\n\n\nalias(c::Context)\n\nReturn the alias of a Context object.\n\n\n\n\n\nalias(leg::CashFlowLeg)\n\nReturn the leg alias\n\n\n\n\n\n","category":"function"},{"location":"additional_functions/additional_functions/#Aliases-for-Common-Abstract-Data-Types","page":"Additional Functions","title":"Aliases for Common Abstract Data Types","text":"","category":"section"},{"location":"additional_functions/additional_functions/#DiffFusion.ModelTime","page":"Additional Functions","title":"DiffFusion.ModelTime","text":"A type alias for variables representing time.\n\n\n\n\n\n","category":"type"},{"location":"additional_functions/additional_functions/#DiffFusion.ModelValue","page":"Additional Functions","title":"DiffFusion.ModelValue","text":"A type alias for variables representing modelled quantities.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#Cash-Flow-and-Coupons","page":"Cash Flow and Coupons","title":"Cash Flow and Coupons","text":"","category":"section"},{"location":"products/cash_flows/","page":"Cash Flow and Coupons","title":"Cash Flow and Coupons","text":"Cash flows and coupons are the building blocks for financial instruments.","category":"page"},{"location":"products/cash_flows/#Basic-Cash-Flows","page":"Cash Flow and Coupons","title":"Basic Cash Flows","text":"","category":"section"},{"location":"products/cash_flows/#DiffFusion.CashFlow","page":"Cash Flow and Coupons","title":"DiffFusion.CashFlow","text":"abstract type CashFlow end\n\nA CashFlow represents a general payment in an unspecified currency.\n\nIn a simulation, we calculate discounted expected cash flows in a consistent numeraire currency.\n\nThe CashFlow object is inspired by QuantLib's CashFlow interface.\n\nWe apply the convention that cash flows are formulated for unit notionals. Actual notionals are applied at the level of legs. This design aims at simplifying MTM cross currency swap legs with notional exchange.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#DiffFusion.FixedCashFlow","page":"Cash Flow and Coupons","title":"DiffFusion.FixedCashFlow","text":"struct FixedCashFlow <: CashFlow\n    pay_time::ModelTime\n    amount::ModelValue\nend\n\nA simple deterministic cash flow (normalised to one unit notional)\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#DiffFusion.CombinedCashFlow","page":"Cash Flow and Coupons","title":"DiffFusion.CombinedCashFlow","text":"struct CombinedCashFlow <: CashFlow\n    first::CashFlow\n    second::CashFlow\n    op::Function\nend\n\nA composition of two cash flows in a single cash flow.\n\nThis CashFlow type is intended e.g. for spreads and caplets/floorlets.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#DiffFusion.combined_cashflow","page":"Cash Flow and Coupons","title":"DiffFusion.combined_cashflow","text":"combined_cashflow(\n    first::CashFlow,\n    second::CashFlow,\n    op::Function,\n    )\n\nCreate a CombinedCashFlow object.\n\n\n\n\n\n","category":"function"},{"location":"products/cash_flows/#Coupons","page":"Cash Flow and Coupons","title":"Coupons","text":"","category":"section"},{"location":"products/cash_flows/#DiffFusion.Coupon","page":"Cash Flow and Coupons","title":"DiffFusion.Coupon","text":"abstract type Coupon <: CashFlow end\n\nA Coupon is a payment that is composed of an (effective) coupon rate and a year fraction.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#Interest-Rate-Coupons","page":"Cash Flow and Coupons","title":"Interest Rate Coupons","text":"","category":"section"},{"location":"products/cash_flows/#DiffFusion.FixedRateCoupon","page":"Cash Flow and Coupons","title":"DiffFusion.FixedRateCoupon","text":"struct FixedRateCoupon <: Coupon\n    pay_time::ModelTime\n    fixed_rate::ModelValue\n    year_fraction::ModelValue\n    first_time::Union{ModelTime,Nothing}\nend\n\nA fixed rate coupon.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#DiffFusion.SimpleRateCoupon","page":"Cash Flow and Coupons","title":"DiffFusion.SimpleRateCoupon","text":"struct SimpleRateCoupon <: Coupon\n    fixing_time::ModelTime\n    start_time::ModelTime\n    end_time::ModelTime\n    pay_time::ModelTime\n    year_fraction::ModelValue\n    curve_key::String\n    fixing_key::Union{String, Nothing}\n    spread_rate::Union{ModelValue, Nothing}\nend\n\nA (legacy) Libor or Euribor rate coupon.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#DiffFusion.CompoundedRateCoupon","page":"Cash Flow and Coupons","title":"DiffFusion.CompoundedRateCoupon","text":"struct CompoundedRateCoupon <: Coupon\n    period_times::AbstractVector\n    period_year_fractions::AbstractVector\n    pay_time::ModelTime\n    curve_key::String\n    fixing_key::Union{String, Nothing}\n    spread_rate::Union{ModelValue, Nothing}\nend\n\nA backward-looking compounded RFR coupon.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#Caplets-and-Floorlets","page":"Cash Flow and Coupons","title":"Caplets and Floorlets","text":"","category":"section"},{"location":"products/cash_flows/#DiffFusion.OptionletCoupon","page":"Cash Flow and Coupons","title":"DiffFusion.OptionletCoupon","text":"struct OptionletCoupon <: Coupon\n    expiry_time::ModelTime\n    coupon::Union{SimpleRateCoupon, CompoundedRateCoupon}\n    strike_rate::ModelValue\n    call_put::ModelValue\n    coupon_type::DataType  # distinguish constructors\nend\n\nA caplet or floorlet coupon on a forward-looking or backward-looking rate.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#DiffFusion.OptionletCoupon-Tuple{Number, Union{DiffFusion.CompoundedRateCoupon, DiffFusion.SimpleRateCoupon}, Number, Number}","page":"Cash Flow and Coupons","title":"DiffFusion.OptionletCoupon","text":"OptionletCoupon(\n    expiry_time::ModelTime,\n    coupon::Union{SimpleRateCoupon, CompoundedRateCoupon},\n    strike_rate::ModelValue,\n    call_put::ModelValue,\n    )\n\nCreate an OptionletCoupon object from an underlying SimpleRateCoupon or CompoundedRateCoupon.\n\nOption expiry_time is specified by user.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.OptionletCoupon-Tuple{Union{DiffFusion.CompoundedRateCoupon, DiffFusion.SimpleRateCoupon}, Number, Number}","page":"Cash Flow and Coupons","title":"DiffFusion.OptionletCoupon","text":"OptionletCoupon(\n    expiry_time::ModelTime,\n    coupon::Union{SimpleRateCoupon, CompoundedRateCoupon},\n    strike_rate::ModelValue,\n    call_put::ModelValue,\n    )\n\nCreate an OptionletCoupon object from an underlying SimpleRateCoupon or CompoundedRateCoupon.\n\nOption expiry_time is determined from underlying coupon.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#Inflation-Coupons","page":"Cash Flow and Coupons","title":"Inflation Coupons","text":"","category":"section"},{"location":"products/cash_flows/#DiffFusion.RelativeReturnCoupon","page":"Cash Flow and Coupons","title":"DiffFusion.RelativeReturnCoupon","text":"struct RelativeReturnCoupon <: Coupon\n    first_time::ModelTime\n    second_time::ModelTime\n    pay_time::ModelTime\n    year_fraction::ModelValue\n    asset_key::String\n    curve_key_dom::String\n    curve_key_for::String\nend\n\nA RelativeReturnCoupon pays a coupon with rate (S2/S1 - 1) / dT. Here, S1 and S2 are spot asset prices.\n\nSuch a coupon is typical for year-on-year type instruments.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#DiffFusion.RelativeReturnIndexCoupon","page":"Cash Flow and Coupons","title":"DiffFusion.RelativeReturnIndexCoupon","text":"struct RelativeReturnIndexCoupon <: Coupon\n    first_time::ModelTime\n    second_time::ModelTime\n    pay_time::ModelTime\n    year_fraction::ModelValue\n    forward_index_key::String\nend\n\nA RelativeReturnIndexCoupon pays a coupon with rate (I2/I1 - 1) / dT. Here, I1 and I2 are spot (index) prices for which a forward index curve is available.\n\nSuch a coupon is typical for year-on-year type instruments.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#Vanilla-Options","page":"Cash Flow and Coupons","title":"Vanilla Options","text":"","category":"section"},{"location":"products/cash_flows/#DiffFusion.VanillaAssetOptionFlow","page":"Cash Flow and Coupons","title":"DiffFusion.VanillaAssetOptionFlow","text":"struct VanillaAssetOptionFlow <: CashFlow\n    expiry_time::ModelTime\n    pay_time::ModelTime\n    strike_price::ModelValue\n    call_put::ModelValue\n    asset_key::String\nend\n\nA CashFlow representing a Call or Put option on an Asset.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#DiffFusion.BarrierAssetOptionFlow","page":"Cash Flow and Coupons","title":"DiffFusion.BarrierAssetOptionFlow","text":"struct BarrierAssetOptionFlow <: CashFlow\n    expiry_time::ModelTime\n    pay_time::ModelTime\n    strike_price::ModelValue\n    barrier_level::ModelValue\n    rebate_price::ModelValue\n    option_type::String\n    asset_key::String\n    hit_obs_step_size::ModelTime\nend\n\nA CashFlow representing a Single Barrier option on an Asset.\n\noption_type is of the form [D|U][O|I][C|P].\n\nhit_obs_step_size represents a modelling parameter to build the grid of past observation times to monitor barrier hit along the path.\n\n\n\n\n\n","category":"type"},{"location":"products/cash_flows/#Cash-Flow-and-Coupon-Methods","page":"Cash Flow and Coupons","title":"Cash Flow and Coupon Methods","text":"","category":"section"},{"location":"products/cash_flows/#DiffFusion.pay_time-Tuple{DiffFusion.CashFlow}","page":"Cash Flow and Coupons","title":"DiffFusion.pay_time","text":"pay_time(cf::CashFlow)\n\nReturn the payment time for a CashFlow.\n\nThis represents a default implementation\n\nThis method is used to calculate discounted expected values.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.pay_time-Tuple{DiffFusion.CombinedCashFlow}","page":"Cash Flow and Coupons","title":"DiffFusion.pay_time","text":"pay_time(cf::CombinedCashFlow)\n\nReturn the payment time for a CombinedCashFlow.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.pay_time-Tuple{DiffFusion.OptionletCoupon}","page":"Cash Flow and Coupons","title":"DiffFusion.pay_time","text":"pay_time(cf::OptionletCoupon)\n\nReturn the payment time for a OptionletCoupon.\n\nThis coincides with the payment time of the underlying coupon.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.first_time","page":"Cash Flow and Coupons","title":"DiffFusion.first_time","text":"first_time(cf::Coupon)\n\nDerive the first event time of the Coupon.\n\nThis time is used in conjunction with call rights to determine whether a coupon period is already broken.\n\n\n\n\n\nfirst_time(cf::FixedRateCoupon)\n\nDerive the first event time of the FixedRateCoupon.\n\n\n\n\n\nfirst_time(cf::SimpleRateCoupon)\n\nDerive the first event time of the SimpleRateCoupon.\n\n\n\n\n\nfirst_time(cf::CompoundedRateCoupon)\n\nDerive the first event time of the CompoundedRateCoupon.\n\n\n\n\n\n","category":"function"},{"location":"products/cash_flows/#DiffFusion.amount","page":"Cash Flow and Coupons","title":"DiffFusion.amount","text":"amount(cf::CashFlow)\n\nReturn the payoff representing the simulated cash flow amount of the payment.\n\nThis method is intended to be used for general payoffs in conjunction with AMC.\n\n\n\n\n\namount(cf::Coupon)\n\nCalculate payment amount for a Coupon.\n\n\n\n\n\namount(cf::FixedCashFlow)\n\nReturn FixedCashFlow amount.\n\n\n\n\n\namount(cf::CombinedCashFlow)\n\nReturn the payoff representing the simulated cash flow amount of the payment.\n\n\n\n\n\namount(cf::VanillaAssetOptionFlow)\n\nReturn the payoff of the VanillaAssetOptionFlow.\n\n\n\n\n\namount(cf::BarrierAssetOptionFlow)\n\nReturn the payoff of the BarrierAssetOptionFlow.\n\n\n\n\n\n","category":"function"},{"location":"products/cash_flows/#DiffFusion.expected_amount","page":"Cash Flow and Coupons","title":"DiffFusion.expected_amount","text":"expected_amount(cf::CashFlow, obs_time::ModelTime)\n\nReturn the payoff representing the simulated expected amount of the payment.\n\nExpectation is calculated in T-forward measure of cash flow currency with T being the payment time and conditioning on observation time.\n\nThis method is intended to be used for analytical pricers.\n\n\n\n\n\nexpected_amount(cf::Coupon, obs_time::ModelTime)\n\nCalculate expected payment amount for a Coupon.\n\n\n\n\n\nexpected_amount(cf::FixedCashFlow, obs_time::ModelTime)\n\nReturn FixedCashFlow expected amount.\n\n\n\n\n\nexpected_amount(cf::CombinedCashFlow, obs_time::ModelTime)\n\nReturn the payoff representing the simulated expected amount of the payment.\n\n\n\n\n\nexpected_amount(cf::VanillaAssetOptionFlow, obs_time::ModelTime)\n\nReturn the payoff representing the simulated expected amount of the VanillaAssetOptionFlow.\n\nThis implementation is an approximation and does not capture payment delay convexity adjustments.\n\n\n\n\n\nexpected_amount(cf::BarrierAssetOptionFlow, obs_time::ModelTime)\n\nReturn the payoff representing the simulated expected amount of the BarrierAssetOptionFlow.\n\nThis implementation is an approximation and does not capture payment delay convexity adjustments.\n\n\n\n\n\n","category":"function"},{"location":"products/cash_flows/#DiffFusion.year_fraction","page":"Cash Flow and Coupons","title":"DiffFusion.year_fraction","text":"year_fraction(cf::Coupon)\n\nDerive the year fraction for a Coupon.\n\n\n\n\n\nyear_fraction(cf::FixedRateCoupon)\n\nReturn FixedRateCoupon year_fraction.\n\n\n\n\n\nyear_fraction(cf::SimpleRateCoupon)\n\nReturn SimpleRateCoupon year_fraction.\n\n\n\n\n\nyear_fraction(cf::CompoundedRateCoupon)\n\nReturn CompoundedRateCoupon year_fraction.\n\n\n\n\n\nyear_fraction(cf::OptionletCoupon)\n\nReturn OptionletCoupon year_fraction.\n\n\n\n\n\nyear_fraction(cf::RelativeReturnCoupon)\n\nReturn RelativeReturnCoupon year_fraction.\n\n\n\n\n\nyear_fraction(cf::RelativeReturnIndexCoupon)\n\nReturn RelativeReturnIndexCoupon year_fraction.\n\n\n\n\n\n","category":"function"},{"location":"products/cash_flows/#DiffFusion.coupon_rate","page":"Cash Flow and Coupons","title":"DiffFusion.coupon_rate","text":"coupon_rate(cf::Coupon)\n\nReturn a payoff for the realised simulated effective coupon rate.\n\n\n\n\n\ncoupon_rate(cf::FixedRateCoupon)\n\nReturn FixedRateCoupon rate.\n\n\n\n\n\ncoupon_rate(cf::SimpleRateCoupon)\n\nReturn SimpleRateCoupon rate.\n\n\n\n\n\ncoupon_rate(cf::CompoundedRateCoupon)\n\nReturn CompoundedRateCoupon rate.\n\n\n\n\n\ncoupon_rate(cf::OptionletCoupon)\n\nReturn OptionletCoupon rate.\n\n\n\n\n\ncoupon_rate(cf::RelativeReturnCoupon)\n\nReturn RelativeReturnCoupon rate.\n\n\n\n\n\ncoupon_rate(cf::RelativeReturnIndexCoupon)\n\nReturn RelativeReturnIndexCoupon rate.\n\n\n\n\n\n","category":"function"},{"location":"products/cash_flows/#DiffFusion.forward_rate-Tuple{DiffFusion.Coupon, Number}","page":"Cash Flow and Coupons","title":"DiffFusion.forward_rate","text":"forward_rate(cf::Coupon, obs_time::ModelTime)\n\nReturn a payoff for the effective forward rate of the coupon.\n\nExpectation is calculated in T-forward measure of cash flow currency with T being the payment time and conditioning on observation time.\n\nThis method is intended to be used for analytical pricers.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.forward_rate-Tuple{DiffFusion.FixedRateCoupon, Number}","page":"Cash Flow and Coupons","title":"DiffFusion.forward_rate","text":"forward_rate(cf::FixedRateCoupon, obs_time::ModelTime)\n\nReturn FixedRateCoupon forward rate.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.forward_rate-Tuple{DiffFusion.SimpleRateCoupon, Number}","page":"Cash Flow and Coupons","title":"DiffFusion.forward_rate","text":"forward_rate(cf::SimpleRateCoupon, obs_time::ModelTime)\n\nReturn SimpleRateCoupon forward rate.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.forward_rate-Tuple{DiffFusion.CompoundedRateCoupon, Number}","page":"Cash Flow and Coupons","title":"DiffFusion.forward_rate","text":"forward_rate(cf::CompoundedRateCoupon, obs_time::ModelTime)\n\nReturn CompoundedRateCoupon forward rate.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.forward_rate-Tuple{DiffFusion.OptionletCoupon, Number}","page":"Cash Flow and Coupons","title":"DiffFusion.forward_rate","text":"forward_rate(cf::OptionletCoupon, obs_time::ModelTime)\n\nReturn OptionletCoupon forward rate.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.forward_rate-Tuple{DiffFusion.RelativeReturnCoupon, Number}","page":"Cash Flow and Coupons","title":"DiffFusion.forward_rate","text":"forward_rate(cf::RelativeReturnCoupon, obs_time::ModelTime)\n\nReturn RelativeReturnCoupon forward rate.\n\n\n\n\n\n","category":"method"},{"location":"products/cash_flows/#DiffFusion.forward_rate-Tuple{DiffFusion.RelativeReturnIndexCoupon, Number}","page":"Cash Flow and Coupons","title":"DiffFusion.forward_rate","text":"forward_rate(cf::RelativeReturnIndexCoupon, obs_time::ModelTime)\n\nReturn RelativeReturnIndexCoupon forward rate.\n\n\n\n\n\n","category":"method"},{"location":"introduction/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"On this page, we give an overview of the DiffFusion.jl modelling framework.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Some features mentioned here are still under development and will be added going forward. If you want to check the status of particular features, please get in touch.","category":"page"},{"location":"introduction/overview/#What-Is-the-Purpose-of-the-Framework?","page":"Overview","title":"What Is the Purpose of the Framework?","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Scenario-based financial instrument pricing is at the core of most risk management processes and methods. The DiffFusion.jl modelling framework provides a flexible and computationally efficient simulation and pricing engine. It contains state-of-the art model implementations for single and multi-factor models.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"The framework is designed for regular large-scale portfolio simulations as well as ad-hoc and interactive pricing and risk calculation analysis. As such, the framework can be used in production processes as well for benchmarking and model validation purposes. ","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"DiffFusion.jl is decomposed into the following components:","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"scenario generation,\nscenario-based financial instrument pricing and sensitivity calculation, as well as\nscenario-based risk measure calculation.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"The components can be used independently. However, they develop their full potential when combined together. ","category":"page"},{"location":"introduction/overview/#Scenario-Generation","page":"Overview","title":"Scenario Generation","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Scenario generation is based on Monte Carlo simulation of risk factors. Risk factors are represented by generic model state variables. The evolution of the model state variables is based on diffusion models.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"The diffusion models in the DiffFusion.jl framework represent market standard risk neutral valuation models. For details on the specific models, see the model section. A key objective of the framework is flexibility regarding the choice model. For example, you can combine multi-factor rates models for major currencies with single-factor rates models for other currencies.  ","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Component models for e.g. interest rates, exchange rates and equities are combined into a cross-asset hybrid model. The joint evolution of the hybrid model state variables is then calculated by Monte Carlo simulation.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"The Monte Carlo method in the DiffFusion.jl framework uses bias-free simulation of random variables whenever the model allows for. This approach provides flexibility on the chosen time grid and allows simulating long time-horizons without sacrificing simulation accuracy. Random numbers are drawn from efficient pseudo-random number generators or low-discrepancy sequences.","category":"page"},{"location":"introduction/overview/#Financial-Instrument-Pricing-and-Sensitivity-Calculation","page":"Overview","title":"Financial Instrument Pricing and Sensitivity Calculation","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Financial instruments in the DiffFusion.jl framework are represented as a layered composition of payoffs, cash flows and cash flow legs. Each layer adds a level of abstraction and common functionality. Cash flow legs are finally combined into products and portfolios.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"The layered design of portfolios and products allows for a very flexible extendability of the framework for new products and feature. Exotic products can easily be integrated since payoffs and payoff-scripting are integral functionalities by design.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Portfolios and products are agnostic to the simulation model and Monte Carlo method. The link between model, simulation and market data is established via a separate entity that holds the context details. This feature also contributes to the flexibility and extendability of the framework. ","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Future risk-neutral prices of portfolios and products are calculated using the simulated state variables and the corresponding models. We implement analytical pricing methods whenever available and appropriate. American Monte-Carlo methods will be available for complex products.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Sensitivities of future prices can be calculated efficiently using Algorithmic Differentiation (AD) methods. AD methods are directly available in the Julia language. For more details on AD in Julia, see the Julia section. ","category":"page"},{"location":"introduction/overview/#Risk-Measure-Calculation","page":"Overview","title":"Risk Measure Calculation","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Scenario prices for portfolios and products are stored in a three-dimensional scenario cube. The axes of the cube are simulated scenarios, future observation times and individual product legs. With these data we calculate risk measures like expected exposure and potential future exposure. New risk measures can easily be added to the framework. Alternatively, scenario cubes can also be processed by client applications or directly by the user.","category":"page"},{"location":"introduction/overview/#What-Models-and-Products-Are-Covered?","page":"Overview","title":"What Models and Products Are Covered?","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework covers models for interest rates, exchange rates, equities/indices, inflation, and commodity futures. All models can be combined into hybrid models for joint simulation.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Financial products are composed of cash flows. Cash flows for linear products and Vanilla options are directly available in the framework. New cash flow types can easily be added.","category":"page"},{"location":"introduction/overview/#Component-Models","page":"Overview","title":"Component Models","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"We make extensive use of the Heath-Jarrow-Morton (HJM) framework for the component models. This approach yields most analytical tractability for simulation, pricing and model calibration. More complex model variants can be easily added to the framework.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Interest rates are modelled as multi-factor Gaussian HJM models. Such models allow for a rich set of simulated yield curves involving curve shifts, slopes and curvatures. The models can be calibration to the full surface of at-the-money swaptions. In its single-factor form, the model reduces to the classical Hull-White interest rate model.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Exchange rates are modelled in a classical Black-Scholes-type model. Exchange rate models are linked to the corresponding domestic and foreign interest rate models. Calibration of the models takes into account the joint evolution of exchange rates as well as corresponding interest rates.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Equities and indices are modelled analogous to exchange rates. In that context, the foreign interest rate model is replaced by a dividend yield term structure. The framework allows for a modelling of discrete dividend and dividend yields.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Inflation models are designed following the foreign currency analogy. As a consequence, inflation models are also analogous to exchange rate models. This approach covers the classical Jarrow-Yildirim three-factor model as well as the two-factor Dodgson-Kainth model. Initial inflation forward curves are direct inputs to the model. This allows for modelling seasonality.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Commodity futures are modelled following the HJM framework applied for interest rates. As a consequence, we can cover single-factor models and multi-factor models. This allows for a modelling of futures volatility term structures. Initial futures curves are direct input to the model and can incorporate commodity-specific features like seasonality patterns.","category":"page"},{"location":"introduction/overview/#Cash-Flows-and-Legs","page":"Overview","title":"Cash Flows and Legs","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework already includes standard fixed income and interest rate cash flows for principal payments, fixed rates and floating rates. Options on forward-looking and backward-looking interest rates are also available.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Linear FX and cross currency instruments are covered by the interest rate cash flows and exchange rate conversion. Additional principal payments in mark-to-market cross currency swaps are handled by a specific leg type.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"European and Bermudan swaptions are are also modelled as cash flow legs. For European swaptions we use analytical scenario pricers. Bermudan swaptions scenario prices are calculated by means of American Monte Carlo methods.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Further cash flow typed and leg types will be added going forward.","category":"page"},{"location":"introduction/overview/#Why-Do-We-Use-Julia-Language?","page":"Overview","title":"Why Do We Use Julia Language?","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Risk factor simulation and scenario-based financial instrument pricing are computationally expensive calculations. Efficient implementation of such calculations requires fast compiled machine code, ability to parallelize and distribute calculations as well as support for high-performance computing hardware like GPU. The Julia language natively fulfils all these requirements.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Development in Julia language is lightweight and similar to languages like Python. As a result, new functionalities can easily be added within the framework or attached by client applications or user interaction.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"Sensitivity calculation is critical for risk management processes. For exposure simulations, sensitivity calculations can be particularly challenging from a computational perspective. These challenges are addressed by Automatic Differentiation (AD) methods. Julia language supports forward mode and reverse mode AD via operator overloading and source transformation. We leverage these language features and provide efficient and accurate Delta and Vega calculations.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework can be incorporated as package in Julia application and user code. Furthermore, the framework can be used e.g. in Jupyter notebooks, Python code and R code via Julia's interfaces to these environments.","category":"page"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework can also run fully independent, e.g. in a Docker container. A corresponding server application is implemented in the DiffFusionServer.jl project.","category":"page"},{"location":"introduction/overview/#label_literature_and_references","page":"Overview","title":"Related Literature and References","text":"","category":"section"},{"location":"introduction/overview/","page":"Overview","title":"Overview","text":"L. Andersen, V. Piterbarg. Interest Rate Modeling. 2010.\nR. Jarrow, Y. Yildirim. Pricing Treasury Inflation Protected Securities and Related Derivatives Using an Hjm Model. 2003.\nL. Andersen. Markov Models for Commodity Futures: Theory and Practice. 2008.\nA. Green. XVA. 2016.\nL. Andersen, M. Pykhtin, A. Sokol. Rethinking Margin Period of Risk. 2016.\nThe Julia Programming Language\nPyJulia - a Python interface to the Julia language\nJuliaCall - an R interface to the Julia language","category":"page"},{"location":"pricing_configuration/context/#Pricing-Context","page":"Pricing Context","title":"Pricing Context","text":"","category":"section"},{"location":"pricing_configuration/context/#DiffFusion.Context","page":"Pricing Context","title":"DiffFusion.Context","text":"struct Context\n    alias::String\n    numeraire::NumeraireEntry\n    rates::Dict{String, RatesEntry}\n    assets::Dict{String, AssetEntry}\n    forward_indices::Dict{String, ForwardIndexEntry}\n    future_indices::Dict{String, FutureIndexEntry}\n    fixings::Dict{String, FixingEntry}\nend\n\nA Context represents a mapping from market references (keys) to model and term structure references (aliases).\n\nLinks are represented as key/alias pairs. market references are used in the specification of payoffs and products. Model and term structure references are used to set up models and model parameters.\n\nIn simple settings there can be a one-to-one mapping between market references and model/term structure references. However, more realistic settings benefit from an additional mapping. For example, discount factors for two (or more) market reference (say EUR ESTR and EUR Euribor)  can be calculated from a single model (with model reference EUR) and two (or more) yield curves (with term structure reference ESTR and Euribor).\n\nA Context\n\nadds a layer of abstraction to disentangle models and products and\nlinks models and term structures according to business logic.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/context/#Context-Entries","page":"Pricing Context","title":"Context Entries","text":"","category":"section"},{"location":"pricing_configuration/context/#DiffFusion.ContextEntry","page":"Pricing Context","title":"DiffFusion.ContextEntry","text":"abstract type ContextEntry end\n\nA ContextEntry represents a mapping from a context key to model aliases and term structure aliases.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/context/#DiffFusion.NumeraireEntry","page":"Pricing Context","title":"DiffFusion.NumeraireEntry","text":"struct NumeraireEntry <: ContextEntry\n    context_key::String\n    model_alias::Union{String, Nothing}\n    termstructure_dict::Dict{String,String}\nend\n\nA NumeraireEntry represents a link to an interest rate model and yield curves used for numeraire calculation.\n\nWe opt to allow for different yield curves in numeraire application. This should allow e.g. AMC methods wih trade-specific discounting.\n\nAn empty model alias (nothing) represents a deterministic model.\n\nThe termstructure_dict maps term structure keys to term structure aliases.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/context/#DiffFusion.numeraire_entry","page":"Pricing Context","title":"DiffFusion.numeraire_entry","text":"numeraire_entry(\n    context_key::String,\n    model_alias::Union{String, Nothing} = nothing,\n    termstructure_dict::Union{AbstractDict, Nothing} = nothing,\n    )\n\nSimplify NumeraireEntry setup.\n\n\n\n\n\nnumeraire_entry(\n    context_key::String,\n    model_alias::Union{String, Nothing},\n    termstructure_alias::String,\n    )\n\nSimplify NumeraireEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/context/#DiffFusion.RatesEntry","page":"Pricing Context","title":"DiffFusion.RatesEntry","text":"struct RatesEntry <: ContextEntry\n    context_key::String\n    model_alias::Union{String, Nothing}\n    termstructure_dict::Dict{String,String}\nend\n\nA RatesEntry represents a link to an interest rate model and yield curves used for zero coupon bond calculation.\n\nAn empty model alias (nothing) represents a deterministic model.\n\nThe termstructure_dict maps term structure keys to term structure aliases.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/context/#DiffFusion.rates_entry","page":"Pricing Context","title":"DiffFusion.rates_entry","text":"rates_entry(\n    context_key::String,\n    model_alias::Union{String, Nothing} = nothing,\n    termstructure_dict::Union{AbstractDict, Nothing} = nothing,\n    )\n\nSimplify RatesEntry setup.\n\n\n\n\n\nratesentry(         contextkey::String,         modelalias::Union{String, Nothing},         termstructurealias::String,         )\n\nSimplify RatesEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/context/#DiffFusion.AssetEntry","page":"Pricing Context","title":"DiffFusion.AssetEntry","text":"struct AssetEntry <: ContextEntry\n    context_key::String\n    asset_model_alias::Union{String, Nothing}\n    domestic_model_alias::Union{String, Nothing}\n    foreign_model_alias::Union{String, Nothing}\n    asset_spot_alias::String\n    domestic_termstructure_dict::Dict{String,String}\n    foreign_termstructure_dict::Dict{String,String}\nend\n\nAn AssetEntry represents a link to an asset model, two interest rate models and yield curves. This entry is used to calculate future simulated asset values.\n\nWe use the foreign currency analogy to represent tradeable assets.\n\nAn empty model alias (nothing) represents a deterministic model.\n\ndomestic_termstructure_dict and foreign_termstructure_dict map term structure keys to term structure aliases.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/context/#DiffFusion.asset_entry","page":"Pricing Context","title":"DiffFusion.asset_entry","text":"asset_entry(\n    context_key::String,\n    asset_model_alias::Union{String, Nothing} = nothing,\n    domestic_model_alias::Union{String, Nothing} = nothing,\n    foreign_model_alias::Union{String, Nothing} = nothing,\n    asset_spot_alias::Union{String, Nothing} = nothing,\n    domestic_termstructure_dict::Union{AbstractDict, Nothing} = nothing,\n    foreign_termstructure_dict::Union{AbstractDict, Nothing} = nothing,\n    )\n\nSimplify AssetEntry setup.\n\n\n\n\n\nasset_entry(\n    context_key::String,\n    asset_model_alias::Union{String, Nothing} = nothing,\n    domestic_model_alias::Union{String, Nothing} = nothing,\n    foreign_model_alias::Union{String, Nothing} = nothing,\n    asset_spot_alias::Union{String, Nothing} = nothing,\n    domestic_termstructure_alias::String,\n    foreign_termstructure_alias::String,\n    )\n\nSimplify AssetEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/context/#DiffFusion.ForwardIndexEntry","page":"Pricing Context","title":"DiffFusion.ForwardIndexEntry","text":"struct ForwardIndexEntry <: ContextEntry\n    context_key::String\n    asset_model_alias::Union{String, Nothing}\n    domestic_model_alias::Union{String, Nothing}\n    foreign_model_alias::Union{String, Nothing}\n    forward_index_alias::String\nend\n\nA ForwardIndexEntry represents a link to an asset model, two interest rate models and a forward index curves. This entry is used to calculate future simulated forward asset prices.\n\nWe use the foreign currency analogy to represent tradeable assets.\n\nAn empty model alias (nothing) represents a deterministic model.\n\nforward_index_alias represents the link to the forward index curve.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/context/#DiffFusion.forward_index_entry","page":"Pricing Context","title":"DiffFusion.forward_index_entry","text":"forward_index_entry(\n    context_key::String,\n    asset_model_alias::Union{String, Nothing} = nothing,\n    domestic_model_alias::Union{String, Nothing} = nothing,\n    foreign_model_alias::Union{String, Nothing} = nothing,\n    forward_index_alias::Union{String, Nothing} = nothing,\n    )\n\nSimplify ForwardIndexEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/context/#DiffFusion.FutureIndexEntry","page":"Pricing Context","title":"DiffFusion.FutureIndexEntry","text":"struct FutureIndexEntry <: ContextEntry\n    context_key::String\n    future_model_alias::Union{String, Nothing}\n    future_index_alias::String\nend\n\nA FutureIndexEntry represents a link to a Futures model and a future index curve. This entry is used to calculate future simulated Future prices.\n\nKey proposition is that the Future price is a martingale in the corresponding domestic risk-neutral measure.\n\nAn empty model alias (nothing) represents a deterministic model.\n\nfuture_index_alias represents the link to the Future index curve.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/context/#DiffFusion.future_index_entry","page":"Pricing Context","title":"DiffFusion.future_index_entry","text":"future_index_entry(\n    context_key::String,\n    future_model_alias::Union{String, Nothing} = nothing,\n    future_index_alias::String = nothing,\n    )\n\nSimplify FutureIndexEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/context/#DiffFusion.FixingEntry","page":"Pricing Context","title":"DiffFusion.FixingEntry","text":"struct FixingEntry <: ContextEntry\n    context_key::String\n    termstructure_alias::String\nend\n\nA FixingEntry represents a link to a parameter term structure used to obtain fixings for indices etc.\n\n\n\n\n\n","category":"type"},{"location":"pricing_configuration/context/#DiffFusion.fixing_entry","page":"Pricing Context","title":"DiffFusion.fixing_entry","text":"fixing_entry(\n    context_key::String,\n    termstructure_alias::Union{String, Nothing} = nothing,\n    )\n\nSimplify FixingEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/context/#DiffFusion.key-Tuple{DiffFusion.ContextEntry}","page":"Pricing Context","title":"DiffFusion.key","text":"key(ce::ContextEntry)\n\nReturn the context key of a context entry.\n\n\n\n\n\n","category":"method"},{"location":"pricing_configuration/context/#Context-Creation","page":"Pricing Context","title":"Context Creation","text":"","category":"section"},{"location":"pricing_configuration/context/#DiffFusion.context","page":"Pricing Context","title":"DiffFusion.context","text":"context(\n    alias::String,\n    num_entry::NumeraireEntry,\n    rates_entries::Union{AbstractVector, Nothing} = nothing,\n    asset_entries::Union{AbstractVector, Nothing} = nothing,\n    forward_index_entries::Union{AbstractVector, Nothing} = nothing,\n    future_index_entries::Union{AbstractVector, Nothing} = nothing,\n    fixing_entries::Union{AbstractVector, Nothing} = nothing,\n    )\n\nSimplify Context setup.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/context/#DiffFusion.simple_context","page":"Pricing Context","title":"DiffFusion.simple_context","text":"simple_context(alias::String, alias_list::AbstractVector)\n\nGenerate a simple Context based on a list of currency aliases.\n\nUser must ensure that aliases can be referenced as normalised keys.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/context/#DiffFusion.deterministic_model_context","page":"Pricing Context","title":"DiffFusion.deterministic_model_context","text":"deterministic_model_context(alias::String, alias_list::AbstractVector)\n\nGenerate a simple Context for fully deterministic modelling based on a list of currency aliases.\n\nUser must ensure that aliases can be referenced as normalised keys.\n\n\n\n\n\n","category":"function"},{"location":"pricing_configuration/context/#DiffFusion.context_keys","page":"Pricing Context","title":"DiffFusion.context_keys","text":"context_keys(key::String)\n\nParse the context entry key and term structure keys from an input key string.\n\nWe implement a simple syntax for input key strings:\n\ncontext_key:[ts_key_1][-,+][ts_key_2]\n\nResult is a tuple of the form\n\n(context_key, ts_key_1, ts_key_2, [-,+])\n\nElements that are not found are returned as emptycontextkey value.\n\nWe apply normalisation of keys to mitigate risk of key errors by the user.\n\n\n\n\n\n","category":"function"},{"location":"sensitivities/sensitivities/#Sensitivities","page":"Sensitivities","title":"Sensitivities","text":"","category":"section"},{"location":"sensitivities/sensitivities/","page":"Sensitivities","title":"Sensitivities","text":"In this section we document sensitivity calculation via Automatic Differentiation (AD).","category":"page"},{"location":"sensitivities/sensitivities/#DiffFusion.model_price","page":"Sensitivities","title":"DiffFusion.model_price","text":"model_price(\n    payoffs::AbstractVector,\n    path_obj::Path,\n    pay_time::Union{ModelTime, Nothing} = nothing,\n    discount_curve_key::Union{String,Nothing} = nothing\n    )\n\nCalculate model price for a vector of Payoff objects.\n\n\n\n\n\n","category":"function"},{"location":"sensitivities/sensitivities/#DiffFusion.model_price_and_deltas","page":"Sensitivities","title":"DiffFusion.model_price_and_deltas","text":"model_price_and_deltas(\n    payoffs::AbstractVector,\n    path_obj::Path,\n    pay_time::Union{ModelTime, Nothing} = nothing,\n    discount_curve_key::Union{String,Nothing} = nothing\n    )\n\nCalculate model price and curve sensitivities.\n\nHere, payoffs is a vector of Payoff objects and path_obj is a simulated Path.\n\npay_time and discount_curve_key control payoff discounting via numeraire calculation.\n\n\n\n\n\n","category":"function"},{"location":"sensitivities/sensitivities/#DiffFusion.model_price_and_vegas","page":"Sensitivities","title":"DiffFusion.model_price_and_vegas","text":"model_price_and_vegas(\n    payoffs::AbstractVector,\n    model::CompositeModel,\n    simulation::Function,\n    ts_list::AbstractVector,\n    context::Context,\n    pay_time::Union{ModelTime, Nothing} = nothing,\n    discount_curve_key::Union{String,Nothing} = nothing\n    )\n\nCalculate model price and model sensitivities.\n\nHere, payoffs is a vector of Payoff objects, model is a full hybrid model.\n\nsimulation is a short cut for a Simulation constructor with the signature simulation(model::Model, ch::CorrelationHolder).\n\nts_list is a list of TermStructure objects for pricing and context is a Context for valuation.\n\npay_time and discount_curve_key control payoff discounting via numeraire calculation.\n\n\n\n\n\n","category":"function"},{"location":"sensitivities/sensitivities/#DiffFusion.model_price_and_deltas_vector","page":"Sensitivities","title":"DiffFusion.model_price_and_deltas_vector","text":"model_price_and_deltas_vector(\n    payoffs::AbstractVector,\n    path_obj::Path,\n    pay_time::Union{ModelTime, Nothing} = nothing,\n    discount_curve_key::Union{String,Nothing} = nothing,\n    ad_module::Module = ForwardDiff,\n    )\n\nCalculate model price and curve sensitivities. Sensitivities are calculated as vector together with a vector of labels.\n\nHere, payoffs is a vector of Payoff objects and path_obj is a simulated Path.\n\npay_time and discount_curve_key control payoff discounting via numeraire calculation.\n\nad_module can be Zygote or ForwardDiff.\n\nFor AMC payoffs we need to update the regression path and trigger a recalibration. For sensitivity calculation, we impose the constraint that regression calibration uses the same paths as valuation.\n\n\n\n\n\n","category":"function"},{"location":"sensitivities/sensitivities/#DiffFusion.model_price_and_vegas_vector","page":"Sensitivities","title":"DiffFusion.model_price_and_vegas_vector","text":"model_price_and_vegas_vector(\n    payoffs::AbstractVector,\n    model::CompositeModel,\n    simulation::Function,\n    ts_list::AbstractVector,\n    context::Context,\n    pay_time::Union{ModelTime, Nothing} = nothing,\n    discount_curve_key::Union{String,Nothing} = nothing,\n    ad_module::Module = ForwardDiff,\n    )\n\nCalculate model price and model sensitivities. Sensitivities are calculated as vector together with a vector of labels.\n\nHere, payoffs is a vector of Payoff objects, model is a full hybrid model.\n\nsimulation is a short cut for a Simulation constructor with the signature simulation(model::Model, ch::CorrelationHolder).\n\nts_list is a list of TermStructure objects for pricing and context is a Context for valuation.\n\npay_time and discount_curve_key control payoff discounting via numeraire calculation.\n\nad_module can be Zygote or ForwardDiff.\n\nFor AMC payoffs we need to update the regression path and trigger a recalibration. For sensitivity calculation, we impose the constraint that regression calibration uses the same paths as valuation.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/parameters/#Model-Parameters","page":"Model Parameters","title":"Model Parameters","text":"","category":"section"},{"location":"termstructures/parameters/#Parameter-Term-Structure-Types","page":"Model Parameters","title":"Parameter Term Structure Types","text":"","category":"section"},{"location":"termstructures/parameters/#DiffFusion.ParameterTermstructure","page":"Model Parameters","title":"DiffFusion.ParameterTermstructure","text":"abstract type ParameterTermstructure <: Termstructure end\n\nAn abstract generic parameter term structure that provides methods to retrieve parameter values for various incarnations of signatures.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/parameters/#DiffFusion.PiecewiseFlatParameter","page":"Model Parameters","title":"DiffFusion.PiecewiseFlatParameter","text":"abstract type PiecewiseFlatParameter <: ParameterTermstructure end\n\nA generic vector-valued model parameter term structure with piece-wise constant interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/parameters/#DiffFusion.BackwardFlatParameter","page":"Model Parameters","title":"DiffFusion.BackwardFlatParameter","text":"struct BackwardFlatParameter <: PiecewiseFlatParameter\n    alias::String\n    times::AbstractVector\n    values::AbstractMatrix\nend\n\nA generic vector-valued model parameter term structure with piece-wise constant backward-flat interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/parameters/#DiffFusion.backward_flat_parameter","page":"Model Parameters","title":"DiffFusion.backward_flat_parameter","text":"backward_flat_parameter(\n     alias::String,\n     times::AbstractVector,\n     values::AbstractMatrix,\n     )\n\nCreate a BackwardFlatParameter object for vector-valued parameters.\n\n\n\n\n\nbackward_flat_parameter(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a BackwardFlatParameter object for scalar parameters.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/parameters/#DiffFusion.flat_parameter","page":"Model Parameters","title":"DiffFusion.flat_parameter","text":"flat_parameter(value::ModelValue)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\nflat_parameter(alias::String, value::ModelValue)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\nflat_parameter(value::AbstractVector)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\nflat_parameter(alias::String, value::AbstractVector)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/parameters/#DiffFusion.ForwardFlatParameter","page":"Model Parameters","title":"DiffFusion.ForwardFlatParameter","text":"struct ForwardFlatParameter <: PiecewiseFlatParameter\n    alias::String\n    times::AbstractVector\n    values::AbstractMatrix\nend\n\nA generic vector-valued model parameter term structure with piece-wise constant forward-flat interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/parameters/#DiffFusion.forward_flat_parameter","page":"Model Parameters","title":"DiffFusion.forward_flat_parameter","text":"forward_flat_parameter(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractMatrix,\n    )\n\nCreate a ForwardFlatParameter object for vector-valued parameters.\n\n\n\n\n\nforward_flat_parameter(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a ForwardFlatParameter object for scalar parameters.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/parameters/#DiffFusion.time_idx-Tuple{DiffFusion.BackwardFlatParameter, Any}","page":"Model Parameters","title":"DiffFusion.time_idx","text":"time_idx(ts::BackwardFlatParameter, t)\n\nFind the index such that T[idx-1] < t <= T[idx]. If t is larger than the last (or all) times T then return length(T)+1.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/parameters/#Functions","page":"Model Parameters","title":"Functions","text":"","category":"section"},{"location":"termstructures/parameters/","page":"Model Parameters","title":"Model Parameters","text":"Call operator for ParameterTermstructure is defined as","category":"page"},{"location":"termstructures/parameters/","page":"Model Parameters","title":"Model Parameters","text":"(ts::ParameterTermstructure)(args...) = value(ts, args...)","category":"page"},{"location":"termstructures/parameters/#DiffFusion.value","page":"Model Parameters","title":"DiffFusion.value","text":"value(ts::ParameterTermstructure, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for constant/time-homogeneous parameters.\n\n\n\n\n\nvalue(ts::ParameterTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for a given observation time t.\n\n\n\n\n\nvalue(ts::PiecewiseFlatParameter, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for constant/time-homogeneous parameters.\n\n\n\n\n\nvalue(ts::PiecewiseFlatParameter, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/parameters/#DiffFusion.time_idx-Tuple{DiffFusion.ForwardFlatParameter, Any}","page":"Model Parameters","title":"DiffFusion.time_idx","text":"time_idx(ts::ForwardFlatParameter, t)\n\nFind the index such that T[idx] >= t > T[idx+1]. If t is smaller than the first (or all) times T then return 0.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#Term-Structures-Functions","page":"Term Structures Functions","title":"Term Structures Functions","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures Functions","title":"Term Structures Functions","text":"In this section we document term structures.","category":"page"},{"location":"termstructures/termstructures/#Term-Structure-Type-and-Methods","page":"Term Structures Functions","title":"Term Structure Type and Methods","text":"","category":"section"},{"location":"termstructures/termstructures/#DiffFusion.Termstructure","page":"Term Structures Functions","title":"DiffFusion.Termstructure","text":"abstract type Termstructure end\n\nAn abstract term structure that provides an alias for identification.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/#DiffFusion.alias-Tuple{DiffFusion.Termstructure}","page":"Term Structures Functions","title":"DiffFusion.alias","text":"alias(ts::Termstructure)\n\nReturn the term structure's alias.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#DiffFusion.TermstructureResultSize","page":"Term Structures Functions","title":"DiffFusion.TermstructureResultSize","text":"@enum(\n    TermstructureResultSize,\n    TermstructureVector,\n    TermstructureScalar\n)\n\nSpecify the dimensions/shape of the values modelled by a term structure.\n\nFor some term structures (e.g. ParameterTermstructure and VolatilityTermstructure) the result may be either a vector or a scalar.\n\n\n\n\n\n","category":"type"},{"location":"scenarios/collateral_simulation/#Collateral-Modelling","page":"Collateral Modelling","title":"Collateral Modelling","text":"","category":"section"},{"location":"scenarios/collateral_simulation/","page":"Collateral Modelling","title":"Collateral Modelling","text":"This section contains methods for collateralised exposure calculation.","category":"page"},{"location":"scenarios/collateral_simulation/","page":"Collateral Modelling","title":"Collateral Modelling","text":"We follow the approaches in A. Green, XVA, 2016.","category":"page"},{"location":"scenarios/collateral_simulation/#DiffFusion.collateral_call_times","page":"Collateral Modelling","title":"DiffFusion.collateral_call_times","text":"collateral_call_times(\n    Δt::ModelTime,\n    first_call_time::ModelTime,\n    last_call_time::ModelTime,\n    )\n\nCalculate margin call times. \n\nMargin frequency is represented as time difference between margin call times, Δt.\n\nfirst_call_time is the first margin time greater/equal time-0 and last_call_time is the last modelled margin call time.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/collateral_simulation/#DiffFusion.market_values_for_csa","page":"Collateral Modelling","title":"DiffFusion.market_values_for_csa","text":"market_values_for_csa(\n    portfolio::ScenarioCube,\n    obs_times::AbstractVector,\n    fx_rates::Union{ScenarioCube, Nothing} = nothing\n    )\n\nCalculate future market values of a given portfolio in CSA currency. Result is represented as ScenarioCube.\n\nMarket values of the portfolio are assumed in numeraire currency from a simulation.\n\nfx_rates are simulated FOR-DOM exchange rates where FOR currency represents the CSA currency and DOM currency represents the numeraire currency of the simulation.\n\nobs_times represent the margin call times for which market values are required. We implement linear interpolation of available market values.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/collateral_simulation/#DiffFusion.collateral_values_for_csa","page":"Collateral Modelling","title":"DiffFusion.collateral_values_for_csa","text":"collateral_values_for_csa(\n   portfolio::ScenarioCube,\n   initial_collateral_balance::ModelValue,\n   minimum_transfer_amount::ModelValue,\n   threshold_amount::ModelValue,\n   independent_amount::ModelValue,\n   )\n\nCalculate the collateral balance based on CSA parameters.\n\nportfolio is assumed to be aggregated over legs and represents un-discounted market values in CSA currency.\n\nCSA parameters are all denominated in CSA currency (or base currency).\n\ninitial_collateral_balance is the (net-)balance of posted/received collateral at time-0.\n\nminimum_transfer_amount (MTA) is the minimum amount of collateral that is exchanged at a collateral call time. Here, MTA is assumed equal for bank and counterparty.\n\nthreshold_amount (TA) represents the maximum exposure of the portfolio below which no collateral is posted. Here, TA is assumed equal for bank and counterparty.\n\nindependent_amount represents a (net-)amount of collateral that is posted/received independent of the portfolio market value.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/collateral_simulation/#DiffFusion.effective_collateral_values","page":"Collateral Modelling","title":"DiffFusion.effective_collateral_values","text":"effective_collateral_values(\n    obs_times::AbstractVector,\n    collateral_balance::ScenarioCube,\n    margin_period_of_risk::ModelTime,\n    )\n\nCalculate the effective collateral balance per observation times.\n\nThe effective effective collateral balance is modelled as an additional ScenarioCube which can be joined with the original portfolio ScenarioCube. The resulting combined ScenarioCube represents the collateralised portfolio.\n\nPortfolio observation times obs_times represent termination times following a potential default.\n\ncollateral_balance represent un-discounted market values of the collateral account from bank's perspective in CSA currency. Collateral observation times are margin call times.\n\nmargin_period_of_risk (MPR) represents the modelled time between default time τ and observation time t.\n\nWe make the following assumptions:\n\nNo margin flows are paid during MPR.\nAll trade flows are paid during MPR.\n\nThe modelled approach refers to the \"Classical+\" approach in Andersen/Pykhtin/Sokol, 2016.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/collateral_simulation/#DiffFusion.collateralised_portfolio","page":"Collateral Modelling","title":"DiffFusion.collateralised_portfolio","text":"collateralised_portfolio(\n    portfolio::ScenarioCube,\n    fx_rates::Union{ScenarioCube, Nothing},\n    margin_call_times::AbstractVector,\n    initial_collateral_balance::ModelValue,\n    minimum_transfer_amount::ModelValue,\n    threshold_amount::ModelValue,\n    independent_amount::ModelValue,\n    margin_period_of_risk::ModelTime,\n    )\n\nCalculate a collateralised portfolio by joining the effective collateral balance.\n\n\n\n\n\n","category":"function"},{"location":"function_index/function_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"function_index/function_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"products/swaptions/#Swaptions","page":"Swaptions","title":"Swaptions","text":"","category":"section"},{"location":"products/swaptions/","page":"Swaptions","title":"Swaptions","text":"European and Brmudan Swaptions are also represented as specific cash flow legs.","category":"page"},{"location":"products/swaptions/#European-Swaption","page":"Swaptions","title":"European Swaption","text":"","category":"section"},{"location":"products/swaptions/#DiffFusion.SwaptionSettlement","page":"Swaptions","title":"DiffFusion.SwaptionSettlement","text":"@enum(\n    SwaptionSettlement,\n    SwaptionCashSettlement,\n    SwaptionPhysicalSettlement,\n)\n\nSwaptionSettlement specifies whether swaption terminates at settlement time or whether it is converted into a physicl swap.\n\nFor SwaptionCashSettlement the cash price is calculated as model price, i.e. physical price at expiry.\n\n\n\n\n\n","category":"type"},{"location":"products/swaptions/#DiffFusion.SwaptionLeg","page":"Swaptions","title":"DiffFusion.SwaptionLeg","text":"struct SwaptionLeg <: CashFlowLeg\n    alias::String\n    #\n    expiry_time::ModelTime\n    settlement_time::ModelTime\n    float_coupons::AbstractVector\n    fixed_coupons::AbstractVector\n    payer_receiver::ModelValue\n    swap_disc_curve_key::String\n    settlement_type::SwaptionSettlement\n    #\n    notional::ModelValue\n    swpt_disc_curve_key::String\n    swpt_fx_key::Union{String, Nothing}\n    swpt_long_short::ModelValue\n    #\n    fixed_times::AbstractVector\n    fixed_weights::AbstractVector\n    fixed_rate::ModelValue\n    exercise_indicator::Payoff\nend\n\nA European swaption referencing a Vanilla swap with forward looking or backward looking rates.\n\n\n\n\n\n","category":"type"},{"location":"products/swaptions/#DiffFusion.SwaptionLeg-2","page":"Swaptions","title":"DiffFusion.SwaptionLeg","text":"SwaptionLeg(\n    alias::String,\n    #\n    expiry_time::ModelTime,\n    settlement_time::ModelTime,\n    float_coupons::AbstractVector,\n    fixed_coupons::AbstractVector,\n    payer_receiver::ModelValue,\n    swap_disc_curve_key::String,\n    settlement_type::SwaptionSettlement,\n    #\n    notional::ModelValue,\n    swpt_disc_curve_key::String = swap_disc_curve_key,\n    swpt_fx_key::Union{String, Nothing} = nothing,\n    swpt_long_short::ModelValue = +1.0,\n    )\n\nCreate a swaption object.\n\n\n\n\n\n","category":"type"},{"location":"products/swaptions/#DiffFusion.future_cashflows-Tuple{DiffFusion.SwaptionLeg, Number}","page":"Swaptions","title":"DiffFusion.future_cashflows","text":"future_cashflows(leg::SwaptionLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/swaptions/#DiffFusion.discounted_cashflows-Tuple{DiffFusion.SwaptionLeg, Number}","page":"Swaptions","title":"DiffFusion.discounted_cashflows","text":"discounted_cashflows(leg::SwaptionLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/swaptions/#Bermudan-Swaption","page":"Swaptions","title":"Bermudan Swaption","text":"","category":"section"},{"location":"products/swaptions/#DiffFusion.BermudanExercise","page":"Swaptions","title":"DiffFusion.BermudanExercise","text":"struct BermudanExercise\n    exercise_time::ModelTime\n    cashflow_legs::AbstractVector\n    make_regression_variables::Function\nend\n\nA container holding the information about an exercise event of a BermudanSwaptionLeg.\n\nHere, exercise_time is the individual option exercise time and cashflow_legs is a list of CashFlowLegs.\n\nThe cash flows in the cash flow legs are supposed to start after exercise_time. That is, the BermudanExercise manages the lag between option exercise and option settlement.\n\nmake_regression_variables is a function with signature\n\n(exercise_time) -> [ regr_payoff_1, ..., regr_payoff_N ].\n\nThe function takes observation time as input to allow for re-usable fuctions. It returns a list of regression payoffs used for this particular exercise.\n\nThe result of the function is passed on to the AmcPayoff creation.\n\n\n\n\n\n","category":"type"},{"location":"products/swaptions/#DiffFusion.bermudan_exercise-Tuple{Number, AbstractVector, Function}","page":"Swaptions","title":"DiffFusion.bermudan_exercise","text":"bermudan_exercise(\n    exercise_time::ModelTime,\n    cashflow_legs::AbstractVector,\n    make_regression_variables::Function,\n    )\n\nCreate a BermudanExercise and check for valid inputs.\n\n\n\n\n\n","category":"method"},{"location":"products/swaptions/#DiffFusion.make_bermudan_exercises","page":"Swaptions","title":"DiffFusion.make_bermudan_exercises","text":"make_bermudan_exercises(\n    fixed_leg::DeterministicCashFlowLeg,\n    float_leg::DeterministicCashFlowLeg,\n    exercise_time::AbstractVector,\n    )\n\nCreate a list of BermudanExercises from Vanilla swap legs.\n\n\n\n\n\n","category":"function"},{"location":"products/swaptions/#DiffFusion.BermudanSwaptionLeg","page":"Swaptions","title":"DiffFusion.BermudanSwaptionLeg","text":"A Bermudan swaption implemented as a CashFlowLeg.\n\nalias is the leg alias.\n\nbermudan_exercises is a list of BermudanExercises in ascending order.\n\noption_long_short is +1 for a long option position (buy) and -1 for a short option position (sell).\n\nnumeraire_curve_key is a discount curve key used for numeraie calculation in AmcPayoffs.\n\nhold_values is a list of Payoffs per BermudanExercise that represent the option prices if not exercised.\n\nexercise_triggers is a list of Payoffs per BermudanExercise that represent the indicator whether option was not exercised at respective exercise time.\n\nmake_regression_variables is a function with signature\n\n(obs_time) -> [ regr_payoff_1, ..., regr_payoff_N ].\n\nThe function takes observation time as input to allow for re-usable fuctions. It returns a list of regression payoffs used for regression to current observation time.\n\nThe result of the function make_regression_variables is passed on to the AmcPayoff creation.\n\nregression_data holds function to create a regression and a Path to calibrate the regression. Details are passed on to AmcPayoff at creation. The elements are supposed to be updated subsequent to BermudanSwaptionLeg creation. This should allow decoupling of leg creation and usage. \n\n\n\n\n\n","category":"type"},{"location":"products/swaptions/#DiffFusion.bermudan_swaption_leg","page":"Swaptions","title":"DiffFusion.bermudan_swaption_leg","text":"bermudan_swaption_leg(\n    alias::String,\n    bermudan_exercises::AbstractVector,\n    option_long_short::ModelValue,\n    numeraire_curve_key::String,\n    make_regression_variables::Function,\n    path::Union{AbstractPath, Nothing},\n    make_regression::Union{Function, Nothing},\n    )\n\nCreate a BermudanSwaptionLeg.\n\nCalculate hold value payoffs and exercise trigger payoffs and setup the BermudanSwaptionLeg object. \n\nalias, bermudan_exercises, option_long_short, numeraire_curve_key, and make_regression_variables are passed on to BermudanSwaptionLeg.\n\npath and make_regression are used to create an AmcPayoffRegression object for  AmcPayoffs. This data is supposed to be updated subsequent to leg cretion.\n\nregression_on_exercise_trigger = true specifies AMC regression strategy. If regression_on_exercise_trigger = then then regression on regression is used. regression_on_exercise_trigger = true is recommended for accurate sensitivity calculation.\n\n\n\n\n\nbermudan_swaption_leg(\n    alias::String,\n    fixed_leg::DeterministicCashFlowLeg,\n    float_leg::DeterministicCashFlowLeg,\n    exercise_times::AbstractVector,\n    option_long_short::ModelValue,\n    numeraire_curve_key::String,\n    regression_on_exercise_trigger = true,\n    )\n\nCreate a BermudanSwaptionLeg using simplified interface.\n\nregression_on_exercise_trigger = true specifies AMC regression strategy. If regression_on_exercise_trigger = then then regression on regression is used. regression_on_exercise_trigger = true is recommended for accurate sensitivity calculation.\n\n\n\n\n\n","category":"function"},{"location":"products/swaptions/#DiffFusion.reset_regression!","page":"Swaptions","title":"DiffFusion.reset_regression!","text":"reset_regression!(\n    leg::BermudanSwaptionLeg,\n    path::Union{AbstractPath, Nothing} = nothing,\n    make_regression::Union{Function, Nothing}  = nothing,\n    )\n\nReset the regression properties for the AMC payoffs of the BermudanSwaptionLeg.\n\nThis method is used to allow setting and updating AMC regression after leg creation.\n\n\n\n\n\n","category":"function"},{"location":"products/swaptions/#DiffFusion.discounted_cashflows-Tuple{DiffFusion.BermudanSwaptionLeg, Number}","page":"Swaptions","title":"DiffFusion.discounted_cashflows","text":"discounted_cashflows(leg::BermudanSwaptionLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\nCritical aspect is to consider the path-dependent exercise into the option underlying.\n\nConsider an obs_time after a given BermudanExercise (last exercise). For this implementation, we make the assumption that exercise at obs_time will only be into the underlying of the last exercise.\n\nAbove assumption is does not pose a limitation if all underlyings are the same, i.e. standard Bermudans. \n\nAbove assumption is a limitation if the Bermudan can be exercised into different underlyings per exercise time. This corresponds to a more complex trigger option.\n\nAbove assumption can be relaxed at the expense of calculating discounted cash flows for all (earlier) underlyings.\n\n\n\n\n\n","category":"method"},{"location":"scenarios/scenario_generation/#Scenarios","page":"Scenarios","title":"Scenarios","text":"","category":"section"},{"location":"scenarios/scenario_generation/#Scenario-Cube","page":"Scenarios","title":"Scenario Cube","text":"","category":"section"},{"location":"scenarios/scenario_generation/#DiffFusion.ScenarioCube","page":"Scenarios","title":"DiffFusion.ScenarioCube","text":"struct ScenarioCube\n    X::AbstractArray\n    times::AbstractVector\n    leg_aliases::AbstractVector\n    numeraire_context_key::String\n    discount_curve_key::Union{String,Nothing}\nend\n\nA ScenarioCube represents the result of MC pricing results of a list of product legs and is calculated for a list of observation times.\n\nElements are\n\nX - tensor of size (N_1, N_2, N_3) and type ModelValue where\nN_1 is number of Monte Carlo paths,\nN_2 is number of time steps,\nN_3 is number of legs.\ntimes - a vector representing observation times.\nleg_aliases - a list of aliases (identifiers) corresponding to each leg\nnumeraire_context_key - the context_key of the NumeraireEntry; this label should indicate the cash flow currency.\ndiscount_curve_key - a flag specifying whether prices in X are discounted prices (for XVA) or undiscounted prices (for CCR).\n\n\n\n\n\n","category":"type"},{"location":"scenarios/scenario_generation/#Pricing-Scenarios","page":"Scenarios","title":"Pricing Scenarios","text":"","category":"section"},{"location":"scenarios/scenario_generation/#DiffFusion.scenarios","page":"Scenarios","title":"DiffFusion.scenarios","text":"scenarios(\n    legs::AbstractVector,\n    times::AbstractVector,\n    path::Path,\n    discount_curve_key::Union{String,Nothing};\n    with_progress_bar::Bool = true,\n    )\n\nCalculate ScenarioCube for a vector of CashFlowLeg objects and a vector of scenario observation times.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/scenario_generation/#Scenario-Cube-Operations","page":"Scenarios","title":"Scenario Cube Operations","text":"","category":"section"},{"location":"scenarios/scenario_generation/#DiffFusion.join_scenarios","page":"Scenarios","title":"DiffFusion.join_scenarios","text":"join_scenarios(cube1::ScenarioCube, cube2::ScenarioCube)\n\nJoin two scenario cubes along leg-axis.\n\n\n\n\n\njoin_scenarios(cubes::AbstractVector{ScenarioCube})\n\nJoin a list of scenario cubes along leg-axis.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/scenario_generation/#DiffFusion.interpolate_scenarios","page":"Scenarios","title":"DiffFusion.interpolate_scenarios","text":"interpolate_scenarios(\n    t::ModelTime,\n    cube::ScenarioCube,\n    )\n\nInterpolation scenarios along time axis.\n\nWe implement linear interpolation with flat extrapolation.\n\nOther interpolations, e.g., piece-wise flat or Brownian Bridge should be incorporated here.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/scenario_generation/#DiffFusion.concatenate_scenarios","page":"Scenarios","title":"DiffFusion.concatenate_scenarios","text":"concatenate_scenarios(cubes::AbstractVector{ScenarioCube})\n\nConcatenate a list of scenarios along time axis.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/scenario_generation/#DiffFusion.aggregate","page":"Scenarios","title":"DiffFusion.aggregate","text":"aggregate(\n    scens::ScenarioCube,\n    average_paths::Bool=true,\n    aggregate_legs::Bool=true,\n    )\n\nAverage paths and aggregate legs in ScenarioCube.\n\nscens is the input ScenarioCube.\n\nIf average_paths is true then reduce scenario cube along path axis. Otherwise, keep individual paths.\n\nIf aggregate_legs is true then reduce scenario cube along the axis of legs. Otherwise, keep individual legs.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/scenario_generation/#Scenario-Generation-Using-Parallel-Computations","page":"Scenarios","title":"Scenario Generation Using Parallel Computations","text":"","category":"section"},{"location":"scenarios/scenario_generation/","page":"Scenarios","title":"Scenarios","text":"We implement various strategies for parallelisation of scenario generation: multi-threading multi-processing and a mixed approach.","category":"page"},{"location":"scenarios/scenario_generation/","page":"Scenarios","title":"Scenarios","text":"It turns out that Julia's garbage collection impedes scaling properties of multi-threaded scenario generation. Parallel garbage collection introduced with Julia 1.10 does not seem to help.","category":"page"},{"location":"scenarios/scenario_generation/","page":"Scenarios","title":"Scenarios","text":"Fortunately, multi-processing can be used efficiently for scenario generation. This circumvents the garbage collection limitation.","category":"page"},{"location":"scenarios/scenario_generation/","page":"Scenarios","title":"Scenarios","text":"We also find that a combination of multi-processing and multi-threading can be most efficient. With such a mixed approach we can leverage the lower overhead from multi-threading and mitigate the impact of single-threaded garbage collection.","category":"page"},{"location":"scenarios/scenario_generation/#DiffFusion.scenarios_parallel","page":"Scenarios","title":"DiffFusion.scenarios_parallel","text":"scenarios_parallel(\n    legs::AbstractVector,\n    times::AbstractVector,\n    path::DiffFusion.Path,\n    discount_curve_key::Union{String,Nothing},\n    )\n\nCombined multi-processing (distributed) and multi-threaded calculation of ScenarioCube for a vector of CashFlowLeg objects and a vector of scenario observation times.\n\nMulti-processing is implemented via Distributed module. The number of processes can be controlled via -p argument when calling julia.\n\nFor each distributed process, multi-threading is implemented via Threads.@threads.\n\nNumber of threads used for parallel calculation is specified by the environment variable JULIA_NUM_THREADS or the -t argument when calling julia.\n\nIt is recommended to use this method in conjunction with thread pinning via ThreadPinning.jl and pinthreads(:cores).\n\nMoreover, to avoid over-subscription in conjunction with BLAS it is recommended to set LinearAlgebra.BLAS.set_num_threads(1).\n\n\n\n\n\n","category":"function"},{"location":"scenarios/scenario_generation/#DiffFusion.scenarios_multi_threaded","page":"Scenarios","title":"DiffFusion.scenarios_multi_threaded","text":"scenarios_multi_threaded(\n    legs::AbstractVector,\n    times::AbstractVector,\n    path::Path,\n    discount_curve_key::Union{String,Nothing};\n    with_progress_bar::Bool = true,\n    )\n\nMulti-threaded calculation of ScenarioCube for a vector of CashFlowLeg objects and a vector of scenario observation times.\n\nMulti-threading is implemented via Base.Threads and the Threads.@threads macro.\n\nNumber of threads used for parallel calculation is specified by the environment variable JULIA_NUM_THREADS or the -t argument when calling julia.\n\nIt is recommended to use this method in conjunction with thread pinning via ThreadPinning.jl and pinthreads(:cores).\n\nMoreover, to avoid over-subscription in conjunction with BLAS it is recommended to set LinearAlgebra.BLAS.set_num_threads(1).\n\n\n\n\n\n","category":"function"},{"location":"scenarios/scenario_generation/#DiffFusion.scenarios_distributed","page":"Scenarios","title":"DiffFusion.scenarios_distributed","text":"scenarios_distributed(\n    legs::AbstractVector,\n    times::AbstractVector,\n    path::DiffFusion.Path,\n    discount_curve_key::Union{String,Nothing},\n    )\n\nMulti-processing (distributed) calculation of ScenarioCube for a vector of CashFlowLeg objects and a vector of scenario observation times.\n\nMulti-processing is implemented via Distributed module. The number of processes can be controlled via -p argument when calling julia.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/volatilities/#Volatilities","page":"Volatilities","title":"Volatilities","text":"","category":"section"},{"location":"termstructures/volatilities/#Volatility-Term-Structure-Types","page":"Volatilities","title":"Volatility Term Structure Types","text":"","category":"section"},{"location":"termstructures/volatilities/#DiffFusion.VolatilityTermstructure","page":"Volatilities","title":"DiffFusion.VolatilityTermstructure","text":"abstract type VolatilityTermstructure <: Termstructure end\n\nAn abstract volatility term structure that provides methods to calculate volatility values for various incarnations of signatures.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/volatilities/#DiffFusion.BackwardFlatVolatility","page":"Volatilities","title":"DiffFusion.BackwardFlatVolatility","text":"struct BackwardFlatVolatility <: VolatilityTermstructure\n    alias::String\n    times::AbstractVector\n    values::AbstractMatrix\nend\n\nA vector-valued volatility term structure with piece-wise constant (backward-flat) interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/volatilities/#DiffFusion.backward_flat_volatility","page":"Volatilities","title":"DiffFusion.backward_flat_volatility","text":"backward_flat_volatility(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractMatrix,\n    )\n\nCreate a BackwardFlatVolatility object for vector-valued volatility.\n\nVolatility values are of size (nvols, ntimes).\n\n\n\n\n\nbackward_flat_volatility(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a BackwardFlatVolatility object for scalar volatility.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/volatilities/#DiffFusion.flat_volatility","page":"Volatilities","title":"DiffFusion.flat_volatility","text":"flat_volatility(alias::String, value)\n\nCreate a BackwardFlatVolatility object for a flat volatility.\n\n\n\n\n\nflat_volatility(alias::String, value)\n\nCreate a BackwardFlatVolatility object for a flat volatility.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/volatilities/#Functions","page":"Volatilities","title":"Functions","text":"","category":"section"},{"location":"termstructures/volatilities/","page":"Volatilities","title":"Volatilities","text":"Call operator for VolatilityTermstructure is defined as","category":"page"},{"location":"termstructures/volatilities/","page":"Volatilities","title":"Volatilities","text":"(ts::VolatilityTermstructure)(args...) = volatility(ts, args...)","category":"page"},{"location":"termstructures/volatilities/#DiffFusion.volatility","page":"Volatilities","title":"DiffFusion.volatility","text":"volatility(ts::VolatilityTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a volatility for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/volatilities/#DiffFusion.volatility-Tuple{DiffFusion.VolatilityTermstructure, Number, Number}","page":"Volatilities","title":"DiffFusion.volatility","text":"volatility(ts::VolatilityTermstructure, t::ModelTime, x::ModelValue)\n\nReturn a scalar volatility for a given observation time t and underlying or strike value x.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/volatilities/#DiffFusion.volatility-2","page":"Volatilities","title":"DiffFusion.volatility","text":"volatility(ts::BackwardFlatVolatility, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a vector of volatilities for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/volatilities/#DiffFusion.time_idx-Tuple{DiffFusion.BackwardFlatVolatility, Any}","page":"Volatilities","title":"DiffFusion.time_idx","text":"time_idx(ts::BackwardFlatVolatility, t)\n\nFind the index such that T[idx-1] < t <= T[idx]. If t is larger than the last (or all) times T then return length(T)+1.\n\n\n\n\n\n","category":"method"},{"location":"scenarios/exposure_calculation/#CCR/XVA-Calculations","page":"CCR/XVA Calculations","title":"CCR/XVA Calculations","text":"","category":"section"},{"location":"scenarios/exposure_calculation/#DiffFusion.expected_exposure","page":"CCR/XVA Calculations","title":"DiffFusion.expected_exposure","text":"expected_exposure(\n    scens::ScenarioCube,\n    gross_leg::Bool = false,\n    average_paths::Bool = true,\n    aggregate_legs::Bool = true,\n    )\n\nCalculate expected positive exposure (EPE or EE).\n\nscens is the input ScenarioCube.\n\nIf gross_leg is true then calculate positive floor on trade level. Otherwise, use netted portfolio to determine positive floor.\n\nIf average_paths is true then reduce scenario cube along path axis. Otherwise, keep individual paths.\n\nIf aggregate_legs is true then reduce scenario cube along the axis of legs. Otherwise, keep individual legs.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/exposure_calculation/#DiffFusion.potential_future_exposure","page":"CCR/XVA Calculations","title":"DiffFusion.potential_future_exposure","text":"potential_future_exposure(\n    scens::ScenarioCube,\n    quantile_::ModelValue,\n    gross_leg::Bool = false,\n    )\n\nCalculate the potential future exposure (PFE).\n\nscens is the input ScenarioCube.\n\nquantile_ is the desired quantile for PFE calculation.\n\nIf gross_leg is true then calculate positive floor on trade level. Otherwise, use netted portfolio to determine positive floor.\n\n\n\n\n\n","category":"function"},{"location":"scenarios/exposure_calculation/#DiffFusion.valuation_adjustment","page":"CCR/XVA Calculations","title":"DiffFusion.valuation_adjustment","text":"valuation_adjustment(\n    credit_ts::CreditDefaultTermstructure,\n    recovery_rate::ModelValue,\n    cva_dva::ModelValue,\n    scens::ScenarioCube,\n    gross_leg::Bool = false,\n    average_paths::Bool = true,\n    aggregate_legs::Bool = true,\n    rho::ModelValue = 0.5,\n    )\n\nCalculate unilateral CVA and DVA for a given ScenarioCube. Result is a ScenarioCube with non-negative XVA contributions along the time axis.\n\ncredit_ts is the credit spread curve to calculate survival probabilities. recovery_rate is the corresponding constant recovery rate value (typicall 0.40).\n\ncva_dva is a binary flag to model CVA (+1.0) and DVA (-1.0).\n\nscens is the input ScenarioCube. Values are assumed to be discounted prices in the corresponding portfolio currency.\n\nParameters gross_leg, average_paths and aggregate_legs are used as in function expected_exposure.\n\nrho specifies how to integrate discounted prices. rho=0.5 uses trapezoidal rule. This choice is used in BCBS paper Basel III: A global regulatory framework for more resilient banks and banking systems (2011). rho=0.0 uses prices at the start of period and is proposed in Green, XVA (2016).\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"In this section we document commonly used utility structures methods.","category":"page"},{"location":"utils/utils/#Interpolation-Methods","page":"Utilities","title":"Interpolation Methods","text":"","category":"section"},{"location":"utils/utils/#DiffFusion.interpolation_methods","page":"Utilities","title":"DiffFusion.interpolation_methods","text":"const interpolation_methods = Dict{String, Function}(...)\n\nSpecify names for available interpolation methods.\n\nDictionary values are constructors with signature (x,y) -> interpolation\n\nAvailable interpolation strings (i.e. keys) are\n\nLINEAR,\nCUBIC,\nAKIMA,\nFRITSCHCARLSON,\nSTEFFEN.\n\nSee package Interpolations for details.\n\n\n\n\n\n","category":"constant"},{"location":"utils/utils/#Polynomial-Regression-Methods","page":"Utilities","title":"Polynomial Regression Methods","text":"","category":"section"},{"location":"utils/utils/#DiffFusion.PolynomialRegression","page":"Utilities","title":"DiffFusion.PolynomialRegression","text":"struct PolynomialRegression\n    V::Matrix{Int}\n    beta::AbstractVector\nend\n\nA PolynomialRegression holds allows to predict values of a multi-variate function. The polynomial degrees are encoded in the multi-index matrix V. The polynomial coefficients are stored in the vector beta.\n\n\n\n\n\n","category":"type"},{"location":"utils/utils/#DiffFusion.polynomial_regression","page":"Utilities","title":"DiffFusion.polynomial_regression","text":"polynomial_regression(\n    C::AbstractMatrix,\n    O::AbstractVector,\n    max_degree::Int,\n    )\n\nCalibrate a PolynomialRegression object from a matrix of controls C of size (n,p) and a vector of observations O of size (p,). The maximum polynomial degree is given by max_degree. \n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.predict-Tuple{DiffFusion.PolynomialRegression, AbstractMatrix}","page":"Utilities","title":"DiffFusion.predict","text":"predict(reg::PolynomialRegression, C::AbstractMatrix)\n\nUse a calibrated polynomial regression to predict function values. Input is a matrix of controls C of size (n,p). Result is a vector of size (p,).\n\n\n\n\n\n","category":"method"},{"location":"utils/utils/#DiffFusion.multi_index-Tuple{Int64, Int64}","page":"Utilities","title":"DiffFusion.multi_index","text":"multi_index(n::Int, k::Int)\n\nCalculate an Int matrix as Vector{Vector{Int}} of size (m,n) where each row represents an n-dimensional multi-index α with degree |α| < k.\n\n\n\n\n\n","category":"method"},{"location":"utils/utils/#DiffFusion.monomials-Tuple{AbstractMatrix, AbstractMatrix}","page":"Utilities","title":"DiffFusion.monomials","text":"monomials(C::AbstractMatrix, V::AbstractMatrix)\n\nCalculate monomials M of size (m,p) for a matrix of controls C of size (n,p) and a matrix V of multi-indices α. V is of size (m,n).\n\n\n\n\n\n","category":"method"},{"location":"utils/utils/#Pice-wise-Polynomial-Regression-Methods","page":"Utilities","title":"Pice-wise Polynomial Regression Methods","text":"","category":"section"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"We implement a piece-wise polynomial multivariate regression.","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"The method represents a combination of a simple decision tree model with polynomial regression on the leaf nodes.","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"For reference and motivation, see the following blog post.","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"We consider a data set of controls C of size (n,p). Here, n represents the number of features and p represents the number of observations.","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"A partitioning is represented by a multi-index π = (π1, ..., πn) with πk > 0. Each πk represents the number of partitions for the k-th feature.","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"The idea is to sort C by the values of the first feature. Then, we split the data set into π_1 partitions. For each partition the procedure is repeated with the second feature and following features.","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"As a result, we get a split of the full data set into π1 * ... * πn subsets. For each subset of data we calculate a polynomial regression.","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"For model prediction have a given data point c. We need to identify the subset and regression which is to be used with c. This step is split into the following sub-steps:","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"Determine a multi-index α that identifies the subset.\nDetermine a scalar index r via a total ordering of multi- indices.","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"The elements of α in step 1 are determined successively by means of a branching matrix Q. A branching matrix is of size (πk - 1, mk). Each column in Q represents quantiles that evenly split the calibration data set for the k-th feature.","category":"page"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"In order to determine an element αk from ck in step 1 we determine the relevant column from the k-th branching matrix and compare c_k against the quantile values.","category":"page"},{"location":"utils/utils/#DiffFusion.PiecewiseRegression","page":"Utilities","title":"DiffFusion.PiecewiseRegression","text":"struct PiecewiseRegression\n    π::Vector{Int}\n    Qs::Vector{AbstractMatrix}\n    regs::Vector{PolynomialRegression}\nend\n\nA PiecewiseRegression holds the information on the partitioning of the training data set and a list of regressions. The information on the partitioning is encoded in the partitioning vector π, the list of branching matrices Qs and the list of polynomial regressions.\n\n\n\n\n\n","category":"type"},{"location":"utils/utils/#DiffFusion.piecewise_regression","page":"Utilities","title":"DiffFusion.piecewise_regression","text":"piecewise_regression(\n    C::AbstractMatrix,\n    O::AbstractVector,\n    max_degree::Int,\n    π::Vector{Int},\n    )\n\nCreate a PiecewiseRegression from a matrix of features (or controls) C, a vector of labels (or observations) O, a maximum polynomial degree (max_degree), and a partitioning vector π.\n\nC is of size (n,p), O is of length p, max_degree should be 2 (or 3) and π is of length n. The entries of π should be between 2 and 4; depending on the number of observations p and the number of dimensions n.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.predict-Tuple{DiffFusion.PiecewiseRegression, AbstractMatrix}","page":"Utilities","title":"DiffFusion.predict","text":"predict(reg::PiecewiseRegression, C::AbstractMatrix)\n\nUse a calibrates piecewise polynomial regression to predict function values. Input is a matrix of controls C of size (n,p). Result is a vector of size (p,).\n\n\n\n\n\n","category":"method"},{"location":"utils/utils/#DiffFusion.partition_index-Tuple{Vector{Int64}, Vector{Int64}}","page":"Utilities","title":"DiffFusion.partition_index","text":"partition_index(π::Vector{Int}, α::Vector{Int})\n\nCalculate a scalar index r from a multi-index α and a partitioning π.\n\nThis method implements a total ordering of multi-indices.\n\n\n\n\n\n","category":"method"},{"location":"utils/utils/#DiffFusion.sub_index-Tuple{Number, Vector{Int64}, Vector{Int64}, AbstractMatrix}","page":"Utilities","title":"DiffFusion.sub_index","text":"sub_index(c_k::ModelValue, π::Vector{Int}, α::Vector{Int}, Q::AbstractMatrix)\n\nCalculate the k-th index αk for a scalar feature ck, earlier indices α = (α1, ..., αk-1), partitioning π = (π1, ..., πk) up to index k and a branching matrix Q.\n\n\n\n\n\n","category":"method"},{"location":"utils/utils/#DiffFusion.multi_index-Tuple{AbstractVector, Vector{Int64}, AbstractVector}","page":"Utilities","title":"DiffFusion.multi_index","text":"multi_index(c::AbstractVector, π::Vector{Int}, Qs::AbstractVector)\n\nCalculate a multi-index α = (α1, ..., αn). For the elements we have 1 ≤ αk ≤ πk. An element αk represents the index of the subset to which the k-th feature ck belongs (all conditional on earlier features).\n\n\n\n\n\n","category":"method"},{"location":"utils/utils/#DiffFusion.branching_matrix-Tuple{Vector{Int64}, Matrix{Int64}, AbstractVector}","page":"Utilities","title":"DiffFusion.branching_matrix","text":"branching_matrix(π::Vector{Int}, Alpha::Matrix{Int}, C_k::AbstractVector)\n\nCalculate a branching matrix Qk of quantiles for a vector of features (ck,j)j=1,..,p. Calculation also depends on earlier multi-indices α = (α1, ..., αk-1) for each ck,j and partitions π = (π1, ..., πk-1).\n\n\n\n\n\n","category":"method"},{"location":"utils/utils/#DiffFusion.partitioning-Tuple{AbstractMatrix, Vector{Int64}}","page":"Utilities","title":"DiffFusion.partitioning","text":"partitioning(C::AbstractMatrix, π::Vector{Int})\n\nCalculate branching matrices and indices for a matrix of features C and a partitioning vector π. The matrix C is of size (n,p) where n is the number of scalar features (per observation) and p is the number observations/samples.\n\nThe method returns a vector (or list) of branching matrices Qs, a matrix of multi-indices Alpha, and the corresponding partition index R. Qs is of length n, Alpha is of size (n,p) and R is of length p.\n\n\n\n\n\n","category":"method"},{"location":"utils/utils/#Black-Formula-Methods","page":"Utilities","title":"Black Formula Methods","text":"","category":"section"},{"location":"utils/utils/#DiffFusion.black_price","page":"Utilities","title":"DiffFusion.black_price","text":"black_price(strike, forward, nu, call_put)\n\nCalculate Vanilla option price V in Black model.\n\nArgument strike (K) represents the option strike, forward (F) is the forward price of the underlying S, i.e. F = ES(T) in the respective pricing measure.\n\nArgument nu represents the standard deviation of the forward price. For annualised lognormal volatility σ, we have ν = σ T. Finally, call_put is the call (+1) or put (-1) option flag.\n\nWe allow broadcasting for arguments.\n\n\n\n\n\nblack_price(strike, forward, σ, T, call_put)\n\nCalculate Vanilla option price V in Black model with volatility parameter.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.black_delta","page":"Utilities","title":"DiffFusion.black_delta","text":"black_delta(strike, forward, nu, call_put)\n\nCalculate Vanilla option Delta in Black model.\n\n\n\n\n\nblack_delta(strike, forward, σ, T, call_put)\n\nCalculate Vanilla option Delta in Black model with volatility parameter.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.black_gamma","page":"Utilities","title":"DiffFusion.black_gamma","text":"black_gamma(strike, forward, nu)\n\nCalculate Vanilla option Gamma in Black model.\n\n\n\n\n\nblack_gamma(strike, forward, σ, T)\n\nCalculate Vanilla option Gamma in Black model with volatility parameter.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.black_theta","page":"Utilities","title":"DiffFusion.black_theta","text":"black_theta(strike, forward, σ, T)\n\nCalculate Vanilla option Theta in Black model.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.black_vega","page":"Utilities","title":"DiffFusion.black_vega","text":"black_vega(strike, forward, nu)\n\nCalculate Vanilla option Vega in Black model.\n\nHere, Vega is calculated as dV  d ν.\n\n\n\n\n\nblack_vega(strike, forward, σ, T)\n\nCalculate Vanilla option Vega in Black model with volatility parameter..\n\nHere, Vega is calculated as dV  dσ.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.black_implied_stdev","page":"Utilities","title":"DiffFusion.black_implied_stdev","text":"black_implied_stdev(price, strike, forward, call_put, min_max = (0.01, 3.00))\n\nCalculate the implied log-normal standard deviation ν from a Black model price.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.black_implied_volatility","page":"Utilities","title":"DiffFusion.black_implied_volatility","text":"black_implied_volatility(price, strike, forward, T, call_put, min_max = (0.01, 1.00))\n\nCalculate the implied log-normal volatility σ from a Black model price.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#Bachelier-Formula-Methods","page":"Utilities","title":"Bachelier Formula Methods","text":"","category":"section"},{"location":"utils/utils/#DiffFusion.bachelier_price","page":"Utilities","title":"DiffFusion.bachelier_price","text":"bachelier_price(strike, forward, nu, call_put)\n\nCalculate Vanilla option price V in Bachelier model.\n\nArgument strike (K) represents the option strike, forward (F) is the forward price of the underlying S, i.e. F = ES(T) in the respective pricing measure.\n\nArgument nu represents the standard deviation of the forward price. For annualised normal volatility σ, we have ν = σ √T. Finally, call_put is the call (+1) or put (-1) option flag.\n\n\n\n\n\nbachelier_price(strike, forward, σ, T, call_put)\n\nCalculate Vanilla option price V in Bachelier model with volatility parameter.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.bachelier_vega","page":"Utilities","title":"DiffFusion.bachelier_vega","text":"bachelier_vega(strike, forward, nu)\n\nCalculate Vanilla option Vega in Bachelier model.\n\nHere, Vega is calculated as dV  d ν.\n\n\n\n\n\nbachelier_vega(strike, forward, σ, T)\n\nCalculate Vanilla option Vega in Bachelier model with volatility parameter.\n\nHere, Vega is calculated as dV  dσ.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.bachelier_implied_stdev","page":"Utilities","title":"DiffFusion.bachelier_implied_stdev","text":"bachelier_implied_stdev(price, strike, forward, call_put, min_max = (1.0e-4, 6.0e-2))\n\nCalculate the implied normal standard deviation ν from a Bachelier model price.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.bachelier_implied_volatility","page":"Utilities","title":"DiffFusion.bachelier_implied_volatility","text":"bachelier_implied_volatility(price, strike, forward, T, call_put, min_max = (0.0001, 0.02))\n\nCalculate the implied normal volatility σ from a Bachelier model price.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#Barrier-Pricing-Formulas","page":"Utilities","title":"Barrier Pricing Formulas","text":"","category":"section"},{"location":"utils/utils/#DiffFusion.black_scholes_vanilla_price","page":"Utilities","title":"DiffFusion.black_scholes_vanilla_price","text":"black_scholes_vanilla_price(X, ϕ, S, DF_r, DF_b, ν)\n\nVanilla option pricing formula for calls and puts.\n\nNotation:\n\nX option strike\nϕ = 1 (call), -1 (put); option type\nS underlying spot\nDF_r = exp(-r T), r is (domestic) risk-free rate\nDF_b = exp(-b T), b is cost-of-carry, i.e. b = r - q (see Haug, sec. 1.2.1)\nν = σ √T, σ option volatility, T time to option expiry.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.black_scholes_barrier_price","page":"Utilities","title":"DiffFusion.black_scholes_barrier_price","text":"black_scholes_barrier_price(X, H, K, η, χ, ϕ, S, DF_r, DF_b, σ, T)\n\nBarrier option pricing formulas following Haug, \"The Complete Guide to Option Pricing Formulas\".\n\nNotation:\n\nr is (domestic) risk-free rate\nb is cost-of-carry, see Haug, sec. 1.2.1:\nb = r - q, where q is a continuous dividend yield,\nb = r - rf, where rf is a foreign currency rate,\nb = 0 for options on futures.\nDF_r = exp(-r T)\nDF_b = exp(-b T)\nσ option volatility\nT time to option expiry\nν = σ √T\nS underlying spot\nX option strike\nH option barrier\nK option rebate\nη = 1 (down), -1 (up); barrier direction\nχ = 1 (out), -1 (in); barrier type\nϕ = 1 (call), -1 (put); option type\n\n\n\n\n\nblack_scholes_barrier_price(X, H, K, option_type::String, S, DF_r, DF_b, σ, T)\n\nBarrier option pricing formulas following Haug.\n\nString option_type is of the form\n\n[D|U][O|I][C|P]\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.up_hit_probability","page":"Utilities","title":"DiffFusion.up_hit_probability","text":"up_hit_probability(u, w0, w1, ν²)\n\nReturn the probablity that a Brownian motion W(t) hits an upper barrer level u given that W(t0) = w0, w(t1) = w1 and variance of W(t1) conditional on W(T0) is ν².\n\nFormula is derived from S. Shreve, Stochastic Calculus for Finance II, Corollary 3.7.4.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.down_hit_probability","page":"Utilities","title":"DiffFusion.down_hit_probability","text":"down_hit_probability(d, w0, w1, ν²)\n\nReturn the probablity that a Brownian motion W(t) hits a lower barrer level d given that W(t0) = w0, w(t1) = w1 and variance of W(t1) conditional on W(T0) is ν².\n\nFormula is derived from S. Shreve, Stochastic Calculus for Finance II, Corollary 3.7.4. and applied to -W(t).\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#DiffFusion.barrier_no_hit_probability","page":"Utilities","title":"DiffFusion.barrier_no_hit_probability","text":"barrier_no_hit_probability(\n    barrier_level,\n    barrier_direction,\n    brownian_levels::AbstractMatrix,\n    brownian_variances::AbstractMatrix,\n    )\n\nCalculate the (path-wise) probability that a Brownian motion W(t) does not hit an upper or lower barrier level given a list of observations.\n\nbarrier_level is a scalar value.\n\nbarrier_direction is +1 for down-barrier and -1 for up-barrier.\n\nbrownian_levels is of size (p, n). Here, p is the number of simulated Brownian motion paths and n is the number of discrete observations.\n\nbrownian_variances is of size (p, n-1). That is, we allow path- dependent variance. For non-path-dependence variance, use a matrix with p=1.\n\n\n\n\n\n","category":"function"},{"location":"payoffs/asset_payoffs/#Assets-and-Futures","page":"Assets and Futures","title":"Assets and Futures","text":"","category":"section"},{"location":"payoffs/asset_payoffs/","page":"Assets and Futures","title":"Assets and Futures","text":"The following payoffs are used to model FX, Equity, Inflation and Futures instruments.","category":"page"},{"location":"payoffs/asset_payoffs/#DiffFusion.Asset","page":"Assets and Futures","title":"DiffFusion.Asset","text":"struct Asset <: Leaf\n    obs_time::ModelTime\n    key::String\nend\n\nThe price of a tradeable asset S(t) at observation time t.\n\nA tradeable asset is typically an FX rate, equity/index price or spot inflation index.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/asset_payoffs/#DiffFusion.ForwardAsset","page":"Assets and Futures","title":"DiffFusion.ForwardAsset","text":"struct ForwardAsset <: Leaf\n    obs_time::ModelTime\n    maturity_time::ModelTime\n    key::String\nend\n\nThe forward price E_t[S(T)] of a tradeable asset S at observation time t and with maturity time T. Expectation is calculated in T-forward measure.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/asset_payoffs/#DiffFusion.ForwardIndex","page":"Assets and Futures","title":"DiffFusion.ForwardIndex","text":"struct ForwardIndex <: Leaf\n    obs_time::ModelTime\n    maturity_time::ModelTime\n    key::String\nend\n\nExpectation Et^T[ST] of a tradeable asset.\n\nThis is used in particular for inflation modelling.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/asset_payoffs/#DiffFusion.FutureIndex","page":"Assets and Futures","title":"DiffFusion.FutureIndex","text":"struct FutureIndex <: Leaf\n    obs_time::ModelTime\n    maturity_time::ModelTime\n    key::String\nend\n\nRisk-neutral expectation Et^T[ST] of a price index.\n\nThis is used in particular for Future modelling.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/asset_payoffs/#Convexity-Adjustment","page":"Assets and Futures","title":"Convexity Adjustment","text":"","category":"section"},{"location":"payoffs/asset_payoffs/#DiffFusion.AssetConvexityAdjustment","page":"Assets and Futures","title":"DiffFusion.AssetConvexityAdjustment","text":"struct AssetConvexityAdjustment <: Leaf\n    obs_time::ModelTime\n    first_time::ModelTime\n    second_time::ModelTime\n    pay_time::ModelTime\n    key::String\nend\n\nConvexity adjustment factor for YoY asset payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/asset_payoffs/#DiffFusion.IndexConvexityAdjustment","page":"Assets and Futures","title":"DiffFusion.IndexConvexityAdjustment","text":"struct IndexConvexityAdjustment <: Leaf\n    obs_time::ModelTime\n    first_time::ModelTime\n    second_time::ModelTime\n    pay_time::ModelTime\n    key::String\nend\n\nConvexity adjustment factor for YoY index payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/asset_payoffs/#Asset-Option-Payoffs","page":"Assets and Futures","title":"Asset Option Payoffs","text":"","category":"section"},{"location":"payoffs/asset_payoffs/#DiffFusion.VanillaAssetOption","page":"Assets and Futures","title":"DiffFusion.VanillaAssetOption","text":"struct VanillaAssetOption <: Payoff\n    obs_time::ModelTime\n    expiry_time::ModelTime\n    forward_price::ForwardAsset\n    strike_price::Payoff\n    call_put::ModelValue\nend\n\nThe time-t forward price of an option paying [ϕ(F-K)]^+. Forward asset price F is determined at expiry_time.\n\nOption forward price is calculated as expectation in T-forward measure where T corresponds to the expiry time. Conditioning (for time-t price) is on information at obs_time.\n\nStrike price strike_price must be time-t (obs_time) measurable. Otherwise, we look into the future.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/asset_payoffs/#DiffFusion.BarrierAssetOption","page":"Assets and Futures","title":"DiffFusion.BarrierAssetOption","text":"struct BarrierAssetOption <: Payoff\n    obs_time::ModelTime\n    expiry_time::ModelTime\n    forward_price::ForwardAsset\n    strike_price::Payoff\n    call_put::ModelValue\n    barrier_level::Payoff\n    barrier_direction::ModelValue\n    barrier_type::ModelValue\n    rebate_price::ModelValue\n    no_hit_times::AbstractVector\nend\n\nThe time-t forward price of an option paying [ϕ(F-K)]^+. Forward asset price F is determined at expiry_time.\n\nOption forward price is calculated as expectation in T-forward measure where T corresponds to the expiry time. Conditioning (for time-t price) is on information at obs_time. This requires particular care when using Black-Scholes pricing functions.\n\nStrike price strike_price and barrier level barrier_level must be time-t (obs_time) measurable. Otherwise, we look into the future.\n\nbarrier_direction is -1 for up-barrier and +1 for down-barrier. barrier_type is -1 for in-barrier and +1 for out-barrier. See also black_scholes_barrier_price.\n\nno_hit_times is a list of times where past hit events are observed and with which no-hit probability is estimated. First time is zero and last time is obs_time. Must be of length 2 or more.\n\n\n\n\n\n","category":"type"},{"location":"products/products/#Basic-Products","page":"Basic Products","title":"Basic Products","text":"","category":"section"},{"location":"products/products/","page":"Basic Products","title":"Basic Products","text":"Financial instruments are decomposed into legs.","category":"page"},{"location":"products/products/","page":"Basic Products","title":"Basic Products","text":"A product is a collection of one or more legs.","category":"page"},{"location":"products/products/#Basic-Cash-Flow-Legs","page":"Basic Products","title":"Basic Cash Flow Legs","text":"","category":"section"},{"location":"products/products/#DiffFusion.CashFlowLeg","page":"Basic Products","title":"DiffFusion.CashFlowLeg","text":"abstract type CashFlowLeg end\n\nA CashFlowLeg combines CashFlow objects in a single currency and adds notional and payer/receiver information and discounting.\n\nWe apply the convention that notionals are non-negative and cash flows are modelled from the receiving counter party perspective. This does include the exceptions of negative spread cash flows or negative notional exchange cash flows.\n\n\n\n\n\n","category":"type"},{"location":"products/products/#DiffFusion.DeterministicCashFlowLeg","page":"Basic Products","title":"DiffFusion.DeterministicCashFlowLeg","text":"struct DeterministicCashFlowLeg <: CashFlowLeg\n    alias::String\n    cashflows::AbstractVector\n    notionals::AbstractVector\n    curve_key::String\n    fx_key::Union{String, Nothing}\n    payer_receiver::ModelValue\nend\n\nA DeterministicCashFlowLeg models legs with deterministic notionals.\n\n\n\n\n\n","category":"type"},{"location":"products/products/#DiffFusion.cashflow_leg","page":"Basic Products","title":"DiffFusion.cashflow_leg","text":"cashflow_leg(\n    alias::String,\n    cashflows::AbstractVector,\n    notionals::AbstractVector,\n    curve_key::Union{String, Nothing} = nothing,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a DeterministicCashFlowLeg.\n\n\n\n\n\ncashflow_leg(\n    alias::String,\n    cashflows::AbstractVector,\n    notional::ModelValue,\n    curve_key::Union{String, Nothing} = nothing,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a constant notional CashFlowLeg.\n\n\n\n\n\n","category":"function"},{"location":"products/products/#Cross-Currency-Swap-Legs","page":"Basic Products","title":"Cross Currency Swap Legs","text":"","category":"section"},{"location":"products/products/#DiffFusion.MtMCashFlowLeg","page":"Basic Products","title":"DiffFusion.MtMCashFlowLeg","text":"struct MtMCashFlowLeg <: CashFlowLeg\n    alias::String\n    cashflows::AbstractVector\n    intitial_notional::ModelValue\n    curve_key_dom::String\n    curve_key_for::String\n    fx_key_dom::Union{String, Nothing}\n    fx_key_for::Union{String, Nothing}\n    fx_reset_times::AbstractVector\n    fx_pay_times::AbstractVector\n    payer_receiver::ModelValue\nend\n\nA mark-to-market (MtM) cross currency cash flow leg adds notional resets to the cash flow payments.\n\nNotional resets are calculated from FX rates at reset times.\n\nWe consider a setting with numeraire currency, domestic currency and foreign currency.\n\nCash flows are denominated in domestic currency. Initial notional is expressed in foreign currency and simulation is modelled in numeraire currency.\n\nWe denote fx_key_for the FOR-NUM asset key and fx_key_dom the DOM-NUM asset key.\n\nFX rates for notional exchange are fixed at fx_reset_times and notional cash flows are exchanged at fx_pay_times. The very first notional exchange is not modelled because it is either in the past or foreign and domestic notional exchange offset each other.\n\nAs a consequence, we have one fx_reset_time and one fx_pay_time per cash flow. The fx_reset_time is at (or before) the start of the coupon period and fx_pay_time is at (or after) the end of the coupon period.\n\n\n\n\n\n","category":"type"},{"location":"products/products/#DiffFusion.mtm_cashflow_leg","page":"Basic Products","title":"DiffFusion.mtm_cashflow_leg","text":"mtm_cashflow_leg(\n    alias::String,\n    cashflows::AbstractVector,\n    intitial_notional::ModelValue,\n    curve_key_dom::String,\n    curve_key_for::String,\n    fx_key_dom::Union{String, Nothing},\n    fx_key_for::Union{String, Nothing},\n    fx_reset_times::AbstractVector,\n    fx_pay_times::AbstractVector,\n    payer_receiver::ModelValue,\n    )\n\nCreate a MTM cash flow leg.\n\n\n\n\n\nmtm_cashflow_leg(\n    alias::String,\n    leg::DeterministicCashFlowLeg,\n    intitial_notional::ModelValue,  # in foreign currency\n    initial_reset_time::ModelValue,\n    curve_key_for::String,\n    fx_key_for::Union{String, Nothing},\n    )\n\nCreate a MtM cash flow leg from a deterministic leg.\n\n\n\n\n\n","category":"function"},{"location":"products/products/#Cash-and-Assets","page":"Basic Products","title":"Cash and Assets","text":"","category":"section"},{"location":"products/products/#DiffFusion.CashBalanceLeg","page":"Basic Products","title":"DiffFusion.CashBalanceLeg","text":"struct CashBalance <: CashFlowLeg\n    alias::String\n    notional::ModelValue\n    fx_key::Union{String, Nothing}\n    payer_receiver::ModelValue\n    maturity_time::Union{Nothing, ModelTime}\nend\n\nA CashLeg represents a constant cash balance in domestic or foreign corrency.\n\n\n\n\n\n","category":"type"},{"location":"products/products/#DiffFusion.cash_balance_leg","page":"Basic Products","title":"DiffFusion.cash_balance_leg","text":"cash_balance_leg(\n    alias::String,\n    notional::ModelValue,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver::ModelValue = +1.0,\n    maturity_time::Union{Nothing, ModelTime} = nothing\n    )\n\nCreate a CashBalance object.\n\n\n\n\n\n","category":"function"},{"location":"products/products/#DiffFusion.AssetLeg","page":"Basic Products","title":"DiffFusion.AssetLeg","text":"An AssetLeg represents a position in a tradeable asset. Such tradeable asset can be, e.g., a share price, index price or an (FOR-DOM) FX rate where DOM currency differs from numeraire currency. \n\n\n\n\n\n","category":"type"},{"location":"products/products/#Cash-Flow-Leg-Functions","page":"Basic Products","title":"Cash Flow Leg Functions","text":"","category":"section"},{"location":"products/products/#Future-Cash-Flows-(Undiscounted)","page":"Basic Products","title":"Future Cash Flows (Undiscounted)","text":"","category":"section"},{"location":"products/products/#DiffFusion.future_cashflows-Tuple{DiffFusion.CashFlowLeg, Number}","page":"Basic Products","title":"DiffFusion.future_cashflows","text":"future_cashflows(leg::CashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#DiffFusion.future_cashflows-Tuple{DiffFusion.DeterministicCashFlowLeg, Number}","page":"Basic Products","title":"DiffFusion.future_cashflows","text":"future_cashflows(leg::DeterministicCashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#DiffFusion.future_cashflows-Tuple{DiffFusion.MtMCashFlowLeg, Number}","page":"Basic Products","title":"DiffFusion.future_cashflows","text":"future_cashflows(leg::MtMCashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#DiffFusion.future_cashflows-Tuple{DiffFusion.AssetLeg, Number}","page":"Basic Products","title":"DiffFusion.future_cashflows","text":"future_cashflows(leg::AssetLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#DiffFusion.future_cashflows-Tuple{DiffFusion.CashBalanceLeg, Number}","page":"Basic Products","title":"DiffFusion.future_cashflows","text":"future_cashflows(leg::CashBalanceLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#Discounted-Cash-Flows","page":"Basic Products","title":"Discounted Cash Flows","text":"","category":"section"},{"location":"products/products/#DiffFusion.discounted_cashflows-Tuple{DiffFusion.CashFlowLeg, Number}","page":"Basic Products","title":"DiffFusion.discounted_cashflows","text":"discounted_cashflows(leg::CashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#DiffFusion.discounted_cashflows-Tuple{DiffFusion.DeterministicCashFlowLeg, Number}","page":"Basic Products","title":"DiffFusion.discounted_cashflows","text":"discounted_cashflows(leg::DeterministicCashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#DiffFusion.discounted_cashflows-Tuple{DiffFusion.MtMCashFlowLeg, Number}","page":"Basic Products","title":"DiffFusion.discounted_cashflows","text":"discounted_cashflows(leg::MtMCashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#DiffFusion.discounted_cashflows-Tuple{DiffFusion.AssetLeg, Number}","page":"Basic Products","title":"DiffFusion.discounted_cashflows","text":"discounted_cashflows(leg::AssetLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#DiffFusion.discounted_cashflows-Tuple{DiffFusion.CashBalanceLeg, Number}","page":"Basic Products","title":"DiffFusion.discounted_cashflows","text":"discounted_cashflows(leg::CashBalanceLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"#DiffFusion.jl-[F]","page":"Home","title":"DiffFusion.jl [∂F]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DiffFusion.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The DiffFusion.jl package implements a framework for joint simulation of financial risk factors, risk-neutral valuation of financial instruments and calculation of portfolio risk measures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The intended purpose of the package is efficient exposure simulation for XVA and Counterparty Credit Risk (CCR).","category":"page"},{"location":"#Repository","page":"Home","title":"Repository","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code for DiffFusion.jl is hosted at github.com/frame-consulting/DiffFusion.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The most recent release of the package can be installed via","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"DiffFusion.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unit tests can be run via","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.test(\"DiffFusion\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For details on the functionality, see the Overview page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For questions please contact info@frame-consult.de.","category":"page"},{"location":"#Architecture","page":"Home","title":"Architecture","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An overview of the architecture of the framework is illustrated in below figure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: DiffFusion.jl Architecture)\nArchitecture of the DiffFusion.jl simulation framework.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Details on purpose and scope are presented in the white paper DiffFusion.jl - A New Exposure Simulation Framework for the Post-Libor World.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Cross-asset exposure simulation can be a complex procedure. Here, we give a minimal example to illustrate the usage of the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more realistic examples, see the unit tests and component tests.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The basic usage can be decomposed into the following steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"model setup,\nMonte Carlo simulation,\nMonte Carlo path construction,\nfinancial instrument setup,\nscenario valuation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All methods are implemented in the DiffFusion module and accessible via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DiffFusion","category":"page"},{"location":"#Model-Setup","page":"Home","title":"Model Setup","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic one-factor Gaussian interest rate model can be set up as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"δ = DiffFusion.flat_parameter(1.)  # benchmark rate\nχ = DiffFusion.flat_parameter( 0.01 )  # mean reversion parameter\nσ = DiffFusion.flat_volatility( 0.0050 )  # short rate volatility\nmodel = DiffFusion.gaussian_hjm_model(\"mdl/HJM1F\", δ, χ, σ, nothing, nothing)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Details on the setup of model parameters are documented in the Interest Rates Models section. Available models are documented in the Models section.","category":"page"},{"location":"#Monte-Carlo-Simulation","page":"Home","title":"Monte Carlo Simulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Monte Carlo paths of model risk factors are stored in a Simulation object. A simulation object for our example model is calculated as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ch = DiffFusion.correlation_holder(\"Std\")  # correlations for more complex models\ntimes =  0.0:0.25:2.0  # simulation times\nn_paths = 2^10  # number of simulated paths\nsim = DiffFusion.simple_simulation(model, ch, times, n_paths)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further details on Monte Carlo simulation methods are documented in the Monte Carlo Simulations section.","category":"page"},{"location":"#Monte-Carlo-*Path*-Construction","page":"Home","title":"Monte Carlo Path Construction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In order to use the Monte Carlo simulation for the pricing of financial instruments we need to specify a Path object. For the Path object we need term structures and a valuation context.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We use simple flat yield term structures for this example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ts = [\n    DiffFusion.flat_forward(\"yc/Estr\", 0.02),  # discount curve\n    DiffFusion.flat_forward(\"yc/Euribor6m\", 0.03),  # projection curve\n]","category":"page"},{"location":"","page":"Home","title":"Home","text":"More details on yield curves and model parameter term structures are documented in the Term Structures Functions section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A context links available payoff keys with models and term structures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ctx = DiffFusion.context(\n    \"Std\",\n    DiffFusion.numeraire_entry(\"EUR\", \"mdl/HJM1F\", \"yc/Estr\"),\n    [\n        DiffFusion.rates_entry(\"EUR\", \"mdl/HJM1F\",\n            Dict((\n                (\"ESTR\", \"yc/Estr\"),\n                (\"EURIBOR6M\", \"yc/Euribor6m\"),\n            ))\n        ),\n    ],\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And a path combines simulation, term structures and context.","category":"page"},{"location":"","page":"Home","title":"Home","text":"path = DiffFusion.path(sim, ts, ctx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Context and Path objects are further documented in the Pricing Context section and the Simulated Paths section.","category":"page"},{"location":"#Financial-Instrument-Setup","page":"Home","title":"Financial Instrument Setup","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Financial instruments are composed of cash flows (or coupons) and cash flow legs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We use two simple floating rate coupons and one fixed rate coupon for this example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"float_coupons = [\n    DiffFusion.SimpleRateCoupon(\n        0.25,  # fixing time\n        0.25,  # start time\n        0.75,  # end time\n        0.75,  # pay time\n        0.50,  # year fraction\n        \"EUR:EURIBOR6M\",  # curve key\n        nothing,  # fixing key (if index rate is already fixed)\n        nothing,  # spread rate\n    ),\n    DiffFusion.SimpleRateCoupon(\n        0.75,  # fixing time\n        0.75,  # start time\n        1.25,  # end time\n        1.25,  # pay time\n        0.50,  # year fraction\n        \"EUR:EURIBOR6M\",  # curve key\n        nothing,  # fixing key (if index rate is already fixed)\n        nothing,  # spread rate\n    ),\n]\nfixed_coupons = [\n    DiffFusion.FixedRateCoupon(\n        1.25,  # pay time\n        0.03,  # fixed rate\n        1.00,  # year fraction\n    ),\n]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cash flow legs add additional information to the coupons.","category":"page"},{"location":"","page":"Home","title":"Home","text":"float_leg = DiffFusion.cashflow_leg(\n    \"leg/1\",  # an alias as identifier\n    float_coupons,\n    [ 10_000.00, 10_000.00 ],  # notionals\n    \"EUR:ESTR\",  # curve key for discounting\n    nothing,  # key for FX rate if applicable\n    -1.0, # payer leg\n)\nfixed_leg = DiffFusion.cashflow_leg(\n    \"leg/2\",  # an alias as identifier\n    fixed_coupons,\n    [ 10_000.00 ],  # notionals\n    \"EUR:ESTR\",  # curve key for discounting\n    nothing,  # key for FX rate if applicable\n    1.0, # receiver leg\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A financial instrument is a list of one or more cash flow legs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More details on available cash flows and cash flow legs are documented in the Cash Flow and Coupons section.","category":"page"},{"location":"#Scenario-Valuation","page":"Home","title":"Scenario Valuation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For scenario valuation we want to calculate the model price of the instrument on a set of observation times and simulated paths.","category":"page"},{"location":"","page":"Home","title":"Home","text":"scenarios = DiffFusion.scenarios(\n    [ float_leg, fixed_leg ],\n    0.0:0.25:1.5,  # observation times\n    path,\n    nothing,  # no discounting to t=0\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Scenario prices are stored in a scenario cube with the dimensions","category":"page"},{"location":"","page":"Home","title":"Home","text":"number of paths,\nnumber of time steps,\nnumber of legs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For our example, we can inspect the dimensions of the cube.","category":"page"},{"location":"","page":"Home","title":"Home","text":"display(size(scenarios.X))\n# Output: (1024, 7, 2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An important measure for XVA and CCR is expected (positive) exposure (EE).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Such measures can now be calculated for a given set of scenario valuation results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using StatsBase\n\nee = mean(max.(sum(scenarios.X, dims=3), 0.0), dims=1)\ndisplay(ee)\n# Output:\n# 1×7×1 Array{Float64, 3}:\n# [:, :, 1] =\n#  0.0  7.98524  9.44371  147.817  148.527  0.0  0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Scenario valuations are further documented in the Scenarios section.","category":"page"},{"location":"#Further-Examples","page":"Home","title":"Further Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The best way to become familiar with the DiffFusion framework is to have a look at the test suite.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An example for exposure simulation of a Vanilla swap portfolio is implemented in the scenario generation component test.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Individual examples on model, simulation and product setup can be found in the unit tests.","category":"page"},{"location":"termstructures/others/#Futures,-Inflation,-Credit","page":"Others","title":"Futures, Inflation, Credit","text":"","category":"section"},{"location":"termstructures/others/#Futures-Term-Structure","page":"Others","title":"Futures Term Structure","text":"","category":"section"},{"location":"termstructures/others/#DiffFusion.FuturesTermstructure","page":"Others","title":"DiffFusion.FuturesTermstructure","text":"abstract type FuturesTermstructure <: Termstructure end\n\nAn abstract futures term structure that provides methods to calculate prices of futures. Such prices represent risk-neutral expectations of spot prices.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/others/","page":"Others","title":"Others","text":"Call operator for FuturesTermstructure is defined as","category":"page"},{"location":"termstructures/others/","page":"Others","title":"Others","text":"(ts::FuturesTermstructure)(args...) = future_price(ts, args...)","category":"page"},{"location":"termstructures/others/#DiffFusion.future_price-Tuple{DiffFusion.FuturesTermstructure, Number}","page":"Others","title":"DiffFusion.future_price","text":"future_price(ts::FuturesTermstructure, t::ModelTime)\n\nReturn the price of a future with settlement time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/others/#Inflation-Term-Structure","page":"Others","title":"Inflation Term Structure","text":"","category":"section"},{"location":"termstructures/others/#DiffFusion.InflationTermstructure","page":"Others","title":"DiffFusion.InflationTermstructure","text":"abstract type InflationTermstructure <: Termstructure end\n\nAn abstract inflation term structure that provides methods to calculate forward inflation index. Forward inflation index is a T-forward measure expectation of (spot) inflation index values.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/others/","page":"Others","title":"Others","text":"Call operator for InflationTermstructure is defined as","category":"page"},{"location":"termstructures/others/","page":"Others","title":"Others","text":"(ts::InflationTermstructure)(args...) = inflation_index(ts, args...)","category":"page"},{"location":"termstructures/others/#DiffFusion.inflation_index-Tuple{DiffFusion.InflationTermstructure, Number}","page":"Others","title":"DiffFusion.inflation_index","text":"inflation_index(ts::InflationTermstructure, t::ModelTime)\n\nReturn the forward inflation index with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/others/#Credit-Default-Term-Structures","page":"Others","title":"Credit Default Term Structures","text":"","category":"section"},{"location":"termstructures/others/#DiffFusion.CreditDefaultTermstructure","page":"Others","title":"DiffFusion.CreditDefaultTermstructure","text":"abstract type CreditDefaultTermstructure <: Termstructure end\n\nAn abstract credit default term structure that provides methods to calculate survival probabilities.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/others/#DiffFusion.FlatSpreadCurve","page":"Others","title":"DiffFusion.FlatSpreadCurve","text":"struct FlatSpreadCurve <: CreditDefaultTermstructure\n    alias::String\n    spread::ModelValue\nend\n\nA flat credit spread curve.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/others/#DiffFusion.flat_spread_curve","page":"Others","title":"DiffFusion.flat_spread_curve","text":"flat_spread_curve(alias::String, spread::ModelValue)\n\nCreate a FlatSpreadCurve.\n\n\n\n\n\nflat_spread_curve(spread::ModelValue)\n\nCreate a FlatSpreadCurve without alias.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/others/#DiffFusion.LogSurvivalCurve","page":"Others","title":"DiffFusion.LogSurvivalCurve","text":"struct LogSurvivalCurve <: CreditDefaultTermstructure\n    alias::String\n    times::AbstractVector\n    values::AbstractVector\nend\n\nLog-interpolated survival probabilities.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/others/#DiffFusion.survival_curve","page":"Others","title":"DiffFusion.survival_curve","text":"survival_curve(\n    alias::String,\n    times::AbstractVector,\n    survival_probs::AbstractVector,\n    interp_method = (x,y) -> linear_interpolation(x, y, extrapolation_bc = Line()),\n    )\n\nCreate a LogSurvivalCurve.\n\n\n\n\n\nsurvival_curve(\n    alias::String,\n    times::AbstractVector,\n    survival_probs::AbstractVector,\n    method_alias::String,\n    )\n\nCreate a LogSurvivalCurve for pre-defined interpolation methods.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/others/","page":"Others","title":"Others","text":"Call operator for CreditDefaultTermstructure is defined as","category":"page"},{"location":"termstructures/others/","page":"Others","title":"Others","text":"(ts::CreditDefaultTermstructure)(args...) = survival(ts, args...)","category":"page"},{"location":"termstructures/others/#DiffFusion.survival","page":"Others","title":"DiffFusion.survival","text":"survival(ts::CreditDefaultTermstructure, t::ModelTime)\n\nReturn the survival probability with observation time t.\n\n\n\n\n\nsurvival(ts::FlatSpreadCurve, t::ModelTime)\n\nCalculate survival probability.\n\n\n\n\n\nsurvival(ts::LogSurvivalCurve, t::ModelTime)\n\nCalculate survival probability.\n\n\n\n\n\n","category":"function"}]
}
