var documenterSearchIndex = {"docs":
[{"location":"pages/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"On this page, we give an overview of the DiffFusion.jl modelling framework.","category":"page"},{"location":"pages/overview/#What-Is-the-Purpose-of-the-Framework?","page":"Overview","title":"What Is the Purpose of the Framework?","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Scenario-based financial instrument pricing is at the core of most risk management processes and methods. The DiffFusion.jl modelling framework provides a flexible and computationally efficient simulation and pricing engine. It contains state-of-the art model implementations that go beyond what is available in many similar open source and proprietary systems.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The framework is designed for regular large-scale portfolio simulations as well as ad-hoc and interactive pricing and risk calculation analysis. As such, the framework can be used in production processes as well for benchmarking and model validation purposes. ","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"DiffFusion.jl is decomposed into the following components:","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"scenario generation,\nscenario-based financial instrument pricing and sensitivity calculation, as well as\nscenario-based risk measure calculation.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The components can be used independently. However, they develop their full potential when combined together. ","category":"page"},{"location":"pages/overview/#Scenario-Generation","page":"Overview","title":"Scenario Generation","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Scenario generation is based on Monte Carlo simulation of risk factors. Risk factors are represented by generic model state variables. The evolution of the model state variables is based on diffusion models.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The diffusion models in the DiffFusion.jl framework represent market standard risk neutral valuation models. For details on the specific models, see the model section. A key objective of the framework is flexibility regarding the choice model. For example, you can combine multi-factor rates models for major currencies with single-factor rates models for other currencies.  ","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Component models for e.g. interest rates, exchange rates and equities are combined into a cross-asset hybrid model. The joint evolution of the hybrid model state variables is then calculated by Monte Carlo simulation.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The Monte Carlo method in the DiffFusion.jl framework uses bias-free simulation of random variables whenever the model allows for. This approach provides flexibility on the chosen time grid and allows simulating long time-horizons without sacrificing simulation accuracy. Random numbers are drawn from efficient pseudo-random number generators or low-discrepancy sequences.","category":"page"},{"location":"pages/overview/#Financial-Instrument-Pricing-and-Sensitivity-Calculation","page":"Overview","title":"Financial Instrument Pricing and Sensitivity Calculation","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Financial instruments in the DiffFusion.jl framework are represented as a layered composition of payoffs, cash flows and cash flow legs. Each layer adds a level of abstraction and common functionality. Cash flow legs are finally combined into products and portfolios.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The layered design of portfolios and products allows for a very flexible extendability of the framework for new products and feature. Exotic products can easily be integrated since payoffs and payoff-scripting are integral functionalities by design.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Portfolios and products are agnostic to the simulation model and Monte Carlo method. The link between model, simulation and market data is established via a separate entity that holds the context details. This feature also contributes to the flexibility and extendability of the framework. ","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Future risk-neutral prices of portfolios and products are calculated using the simulated state variables and the corresponding models. We implement analytical pricing methods whenever available and appropriate. American Monte-Carlo methods are available for complex products.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Sensitivities of future prices are calculated efficiently using Algorithmic Differentiation (AD) methods. AD methods are directly available in the Julia language. For more details on AD in Julia, see the Julia setion. ","category":"page"},{"location":"pages/overview/#Risk-Measure-Calculation","page":"Overview","title":"Risk Measure Calculation","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Scenario prices for portfolios and products are stored in a three-dimensional scenario cube. The axes of the cube are simulated scenarios, future observation times and individual product legs. With these data we calculate risk measures like expected exposure and potential future exposure. New risk measures can easily be added to the framework. Alternatively, scenario cubes can also be processed by client applications or directly by the user.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Portfolio risk measures need to take into account collateralization. We model collateral directly based on relevant CSA parameters like threshold, minimum transfer amount and independent amount. Collateralized portfolios are modelled using a margin period of risk. The methodology allows for an accurate portfolio modelling. In particular, we can model exposure spikes following large payments.","category":"page"},{"location":"pages/overview/#What-Models-and-Products-Are-Covered?","page":"Overview","title":"What Models and Products Are Covered?","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework covers models for interest rates, exchange rates. Further asset classes like equities/indices, inflation, commodity futures, and credit spreads will be added. All models can be combined into hybrid models for joint simulation.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Financial products are composed of cash flows. Cash flows for linear products are directly available in the framework. New cash flow types can easily be added.","category":"page"},{"location":"pages/overview/#Component-Models","page":"Overview","title":"Component Models","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"We make extensive use of the Heath-Jarrow-Morton (HJM) framework for the component models. This approach yields most analytical tractability for simulation, pricing and model calibration. More complex model variants can be easily added to the framework.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Interest rates are modelled as multi-factor Gaussian HJM models. Such models allow for a rich set of simulated yield curves involving curve shifts, slopes and curvatures. The models can be calibration to the full surface of at-the-money swaptions. In its single-factor form, the model reduces to the classical Hull-White interest rate model.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Exchange rates are modelled in a classical Black-Scholes-type model. Exchange rate models are linked to the corresponding domestic and foreign interest rate models. Calibration of the models takes into account the joint evolution of exchange rates as well as corresponding interest rates.","category":"page"},{"location":"pages/overview/#Cash-Flows-and-Legs","page":"Overview","title":"Cash Flows and Legs","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework already includes standard fixed income and interest rate cash flows for principal payments, fixed rates and floating rates.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Linear FX and cross currency instruments are covered by the interest rate cash flows and exchange rate conversion. Additional principal payments in mark-to-market cross currency swaps are handled by a specific leg type.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Further cash flow typed and leg types will be added going forward.","category":"page"},{"location":"pages/overview/#Why-Do-We-Use-Julia-Language?","page":"Overview","title":"Why Do We Use Julia Language?","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Risk factor simulation and scenario-based financial instrument pricing are computationally expensive calculations. Efficient implementation of such calculations requires fast compiled machine code, ability to parallelize and distribute calculations as well as support for high-performance computing hardware like GPU. The Julia language natively fulfills all these requirements.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Development in Julia language is lightweight and similar to languages like Python. As a result, new functionalities can easily be added within the framework or attached by client applications or user interaction.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Sensitivity calculation is critical for risk management processes. For exposure simulations, sensitivity calculations can be particularly challenging from a computational perspective. These challenges are addressed by Automatic Differentiation (AD) methods. Julia language supports forward mode and reverse mode AD via operator overloading and source transformation. We leverage these language features and provide efficient and accurate Delta and Vega calculations.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework can be incorporated as package in Julia application and user code. Furthermore, the framework can be used e.g. in Jupyter notebooks, Python code and R code via Julia's interfaces to these environments. The DiffFusion.jl framework can also run fully independent, e.g. in a Docker container.","category":"page"},{"location":"pages/overview/#Related-Literature-and-References","page":"Overview","title":"Related Literature and References","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"L. Andersen, V. Piterbarg. Interest Rate Modeling. 2010.\nR. Jarrow, Y. Yildirim. Pricing Treasury Inflation Protected Securities and Related Derivatives Using an Hjm Model. 2003.\nL. Andersen. Markov Models for Commodity Futures: Theory and Practice. 2008.\nA. Green. XVA. 2016.\nL. Andersen, M. Pykhtin, A. Sokol. Rethinking Margin Period of Risk. 2016.\nThe Julia Programming Language\nPyJulia - a Python interface to the Julia language\nJuliaCall - an R interface to the Julia language","category":"page"},{"location":"pages/simulation_framework/#Simulation-Framework","page":"Simulation Framework","title":"Simulation Framework","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this documentation we discuss our framework for efficient implementation of Monte Carlo methods that aim at simulating joint diffusion processes. The framework is designed with the following objectives in mind:","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Simulation should be exact (i.e. bias-free) if the underlying model   allows for exact simulation.\nFramework should allow for efficient factorisation of the joint   covariance matrix and exploit independence structures.\nSimulation should be formulated in terms of matrix and tensor   operations.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Simulation models in scope are models for interest rates, FX rates, equities, inflation, futures and credit. Basic variants of such models can be formulated as Ornstein-Uhlenbeck (OU) processes. Such OU processes do allow for exact simulation.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Common notation.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t is an n-dimensional state variable which describes the   model dynamic.\nW_u is an m-dimensional Brownian motion under the common   risk-neutral measure mathbbQ.\nGamma is an mtimes m matrix representing correlations of   increments in W_u.\ns, u, t are simulation times with 0leq sleq uleq t.\nX_t^k for k=1ldotsN are model component states that   represent a slice of the full vector X_t.\nThetaleft(cdotright), Hleft(cdotright),   Sigmaleft(cdotright) and Lleft(cdotright) are composite   model functions for the full state X_t.\nTheta^kleft(cdotright), H^kleft(cdotright) and   Sigma^kleft(cdotright) are component model functions that   represent slices of Thetaleft(cdotright),   Hleft(cdotright) and Sigmaleft(cdotright).\nVleft(stX_sright) is a diagonal ntimes n matrix   representing volatilities of the increments of state vector X_t.\nCleft(stX_sright) is a ntimes n matrix representing   correlations of the increments of state vector X_t.\nZ^left(1right)ldotsZ^left(pright) are independent   n-dimensional standard normal random variables for p paths.\nX_t^left(1right)ldotsX_t^left(pright) are simulated   realisations of the full random state variable X_t for p   paths.","category":"page"},{"location":"pages/simulation_framework/#Hybrid-Model-Specification","page":"Simulation Framework","title":"Hybrid Model Specification","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The hybrid model is described by a multi-variate process left(X_tright)_t with X_tinmathbbR^n and initial condition X_0=0. The elements of the process left(X_tright)_t are grouped into models. That is, we decompose","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t=leftbeginarrayc\nX_t^1\nvdots\nX_t^N\nendarrayright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Each component model is descibed by the process left(X_t^kright)_t with X_t^kinmathbbR^n_k, k=1ldotsN. Each component model is specified independently but with a common interface. This allows for a flexible combination of models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Component models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Denote left(Omegacal F_tmathbbQright) a filtered probability space with (risk-neutral) probability measure mathbbQ. The common structure of the component models is given by the dynamics","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t^k=Theta^kleft(stX_sright)+H^kleft(stX_sright)X_s+int_s^tSigma^kleft(uX_sright)^topdW_u","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"for 0leq sleq t. Here, Theta^kleft(stX_sright)inmathbbR^n_k is a deterministic drift vector. The matrix H^kleft(stX_sright)inmathbbR^n_ktimes n typically accounts for mean reversion in the component model. Finally, the matrix Sigma^kleft(uX_sright)^topinmathbbR^n_ktimes m represents the volatility function of the component model and W_uinmathbbR^m is an m-dimensional vector of Brownian motions under mathbbQ.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Above specification is fairly general. We make a few comments to indicate how concrete component models will implement the specification.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The component model functions Theta^k, H^k and Sigma^k  may depend on the model state X_s. However, we impose that the  model state is observed at time s. This allows to cover local and  stochastic volatility models. But the component model functions  already need to implement some time-discretisation.\nIdeally, the component model functions Theta^k, H^k and  Sigma^k are independent of the model state. This is the case  for models based on OU processes. Then simulation can be exact.\nIn typical cases, component model states X_t^k do not depend  on the full hybrid model state X_s. Instead, X_t^k (as  well as Theta^k, H^k and Sigma^k) only use information  from X_s^k plus a few dependencies to other models.  Consequently, the dimensions n and m can effectively be reduced  to numbers in the order of n_k. We leave the general  representation in order to keep notation brief. But keep in mind  that with the general notation the full matrices H^k and  Sigma^k will be sparse.","category":"page"},{"location":"pages/simulation_framework/#Hybrid-Model-Simulation","page":"Simulation Framework","title":"Hybrid Model Simulation","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Our general component model specification yields that the hybrid model dynamics become","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t=Thetaleft(stX_sright)+Hleft(stX_sright)X_s+int_s^tSigmaleft(uX_sright)^topdW_u","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with composite hybrid model functions","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nThetaleft(stX_sright)  =leftbeginarrayc\nTheta^1left(stX_sright)\nvdots\nTheta^Nleft(stX_sright)\nendarrayrightinmathbbR^n\nHleft(stX_sright)  =leftbeginarrayc\nH^1left(stX_sright)^top\nvdots\nH^Nleft(stX_sright)^top\nendarrayrightinmathbbR^ntimes nquadtextand\nSigmaleft(uX_sright)^top  =leftbeginarrayc\nSigma^1left(uX_sright)^top\nvdots\nSigma^Nleft(uX_sright)^top\nendarrayrightinmathbbR^ntimes m\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"As a consequence, we find that X_tX_s is multi-variate normally distributed with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"mathbbEleftX_tX_sright=Thetaleft(stX_sright)+Hleft(stX_sright)X_sinmathbbR^n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"textCovleftX_tX_sright=int_s^tSigmaleft(uX_sright)^topGammaSigmaleft(uX_sright)dtinmathbbR^ntimes n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The constant symmetric matrix GammainmathbbR^mtimes m represents the instantaneous correlations of increments dW_t. We get for the elements textCovleftX_tX_sright_ij of the covariance matrix","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\ntextCovleftX_tX_sright_ij  =int_s^tSigmaleft(uX_sright)_i^topGammaSigmaleft(uX_sright)_jdu\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, Sigmaleft(uX_sright)_i and Sigmaleft(uX_sright)_j are the i-th and j-th column (ij=1ldotsn) of the volatility matrix Sigmaleft(uX_sright).","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The covariance matrix is decomposed into a diagonal state-volatility matrix Vleft(stX_sright) and a state-correlation matrix Cleft(stX_sright) such that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nleftVleft(stX_sright)right_ii  =sqrtlefttextCovleftX_tX_srightright_iileft(t-sright)\nleftCleft(stX_sright)right_ii  =1\nleftCleft(stX_sright)right_ij  =begincases\nfraclefttextCovleftX_tX_srightright_ijleftVleft(stX_sright)right_iileftVleft(stX_sright)right_jjleft(t-sright)  textif leftVleft(stX_sright)right_iileftVleft(stX_sright)right_jj0\n0  textelse\nendcases\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"for all indices ij=1ldotsn. Then textCovleftX_tX_sright=Vleft(stX_sright)Cleft(stX_sright)Vleft(stX_sright)left(t-sright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"If all model functions are independent of the state X_s then we can directly calculate a (Cholesky) decomposition","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"textCovleftX_tX_sright=Vleft(stright)Lleft(stright)Lleft(stright)^topVleft(stright)left(t-sright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With such a factorisation we can simulate","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t=Thetaleft(stright)+Hleft(stright)X_s+Vleft(stright)Lleft(stright)Zsqrtt-s","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with standard normal vectors Zsimcal Nleft(01right). For a list of paths leftX_s^left(1right)ldotsX_s^left(pright)rightinmathbbR^ntimes p and standard normal increments leftZ^left(1right)ldotsZ^left(pright)rightinmathbbR^ntimes p this can be implemented as matrix multiplication and addition","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nleftX_t^left(1right)ldotsX_t^left(pright)right  =leftThetaleft(stright)ldotsThetaleft(stright)right\n  quad+Hleft(stright)^topleftX_s^left(1right)ldotsX_s^left(pright)right\n  quad+Vleft(stright)Lleft(stright)leftZ^left(1right)ldotsZ^left(pright)rightsqrtt-s\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The assumption of state-independent model component functions holds e.g. for Gaussian short rate models, Black-Scholes equity/foreign exchange models, and Dodgson-Kainth inflation model.","category":"page"},{"location":"pages/simulation_framework/#Component-Models","page":"Simulation Framework","title":"Component Models","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this section, we specify component models for our hybrid model framework.","category":"page"},{"location":"pages/simulation_framework/#Interest-Rate-Models","page":"Simulation Framework","title":"Interest Rate Models","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Interest rate models are formulated as separable Heath-Jarrow-Morton (HJM) models for the continuous forward rate fleft(tTright) with observation time t and term T.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Our specification follows in large parts Andersen/Piterbarg, Interest Rate Modeling, 2010, Sec. 4.4 and 4.5.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Forward rates are directly linked to zero coupon bonds Pleft(tTright). We have","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Pleft(tTright)=expleft -int_t^Tfleft(tsright)dsright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"or equivalently","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"fleft(tTright)=-fracpartialpartial Tlogleft(Pleft(tTright)right)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We formulate the model in risk neutral measure. The risk neutral measure uses the continuous bank account as numeraire. The bank account accruals at the short rate","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r_t=f(tt)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"And the price process of the bank account left(B_tright)_t is given by","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"B_t=e^int_0^tr_sds","category":"page"},{"location":"pages/simulation_framework/#Heath-Jarrow-Morton-Modelling-Framework","page":"Simulation Framework","title":"Heath-Jarrow-Morton Modelling Framework","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Consider a general HJM model for the forward rates f(tT). No-arbitrage considerations yield the dynamics","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"dfleft(tTright)=sigma_fleft(tTright)^topcdotleftint_t^Tsigma_fleft(turight)durightcdot dt+sigma_fleft(tTright)^topcdot dW_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, sigma_fleft(tTright)^top is a d-dimensional vector of forward rate volatilities and W_t is a d-dimensional Brownian motion in the risk-neutral measure. The drift term of the HJM model follows from no-arbitrage considerations. Thus it remains to specify the forward rate volatility function sigma_fleft(tTright)^top.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In an HJM model with separable volatility the forward rate volatility takes the form sigma_fleft(tTright)=gleft(tright)hleft(Tright). Here gleft(tright)=gleft(tomegaright)inmathbbR^dtimes d is a matrix-valued process adapted to cal F_t and hleft(Tright)inmathbbR^d is a vector-valued deterministic function. The models of this class are also considered Quasi-Gaussian models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For an HJM model we get the bond price dynamics in risk-neutral measure as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"fracdPleft(tTright)Pleft(tTright)=r_tcdot dt-sigma_Pleft(tTright)^topcdot dW_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The minus sign indicates that if rates increase bond prices decrease (and vice versa). In a separable volatility HJM model the bond price volatility becomes","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_Pleft(tTright)=gleft(tright)cdotint_t^Thleft(uright)cdot du","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Integration yields the forward rates","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nfleft(tTright)  =fleft(0Tright)+\n  quad hleft(Tright)^topint_0^tgleft(sright)^topgleft(sright)left(int_s^Thleft(uright)duright)ds+\n  quad hleft(Tright)^topint_0^tgleft(sright)^topdW_s\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r_t=fleft(0tright)+hleft(tright)^topleftint_0^tgleft(sright)^topgleft(sright)left(int_s^thleft(uright)duright)ds+int_0^tgleft(sright)^topdW_sright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We can re-write hleft(tright)^top=boldsymbol1^topHleft(tright) and get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r(t)=f(0t)+boldsymbol1^topHleft(tright)leftint_0^tgleft(sright)^topgleft(sright)left(int_s^thleft(uright)duright)ds+int_0^tgleft(sright)^topdW_sright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"boldsymbol1=left(beginarrayc\n1\nvdots\n1\nendarrayright)text and Hleft(tright)=textdiagleft(hleft(tright)right)=left(beginarrayccc\nh_1left(tright)  0  0\n0  ddots  0\n0  0  h_dleft(tright)\nendarrayright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Now, we can introduce the vector of state variables x_t with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =Hleft(tright)leftint_0^tgleft(sright)^topgleft(sright)left(int_s^thleft(uright)duright)ds+int_0^tgleft(sright)^topdW_sright\n  =Hleft(tright)leftint_0^tgleft(sright)^topsigma_Pleft(stright)ds+int_0^tgleft(sright)^topdW_sright\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Some (lengthy) calculations yield the representation","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hleft(tright)^-1x_t-Hleft(sright)^-1x_s=Hleft(sright)^-1y_sGleft(stright)+int_s^tgleft(uright)^topleftsigma_Pleft(utright)du+dW_uright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with model function","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Gleft(stright)=int_s^tHleft(sright)^-1Hleft(uright)boldsymbol1du","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and auxilliary state variable process","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"y_t=Hleft(tright)left(int_0^tgleft(sright)^topgleft(sright)dsright)Hleft(tright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Separation of volatility and mean reversion.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In order to better separate volatility and mean reversion components, we set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\ngleft(tright)  =Hleft(tright)^-1sigma_t\nHleft(stright)  =Hleft(tright)Hleft(sright)^-1\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =Hleft(stright)leftx_s+y_sGleft(stright)+int_s^tHleft(suright)^-1sigma_u^topleftsigma_uGleft(utright)du+dW_urightright\ny_t  =Hleft(stright)y_sHleft(stright)+int_s^tHleft(utright)sigma_u^topsigma_uHleft(utright)ds\nGleft(stright)  =int_s^tHleft(suright)boldsymbol1du\nsigma_Pleft(utright)  =sigma_uGleft(utright)\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Above representation is the basis for our hybrid model interface.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We note, that we also get the following equality for the drift terms","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"underbracey_sGleft(stright)+int_s^tHleft(suright)^-1sigma_u^topsigma_uGleft(utright)du_I_1left(tright)=underbraceint_s^tHleft(suright)^-1y_uboldsymbol1du_I_2left(tright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This property follows by differentiating both sides w.r.t. t. Then we get for the left side of the equation","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nI_1left(tright)  =y_sHleft(stright)boldsymbol1+int_s^tHleft(suright)^-1sigma_u^topsigma_uHleft(utright)boldsymbol1du\n  =y_sHleft(stright)boldsymbol1+Hleft(stright)^-1int_s^tHleft(utright)sigma_u^topsigma_uHleft(utright)boldsymbol1du\n  =y_sHleft(stright)boldsymbol1+Hleft(stright)^-1lefty_t-Hleft(stright)y_sHleft(stright)rightboldsymbol1\n  =Hleft(stright)^-1y_tboldsymbol1\n  =I_2left(tright)\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The alternative representation of the drift term is useful in some situations because the integrand does not depend on the upper boundary t. We get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=Hleft(stright)leftx_s+int_s^tHleft(suright)^-1lefty_uboldsymbol1du+sigma_u^topdW_urightright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Integrated state variable.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In addition to the state variable x_t itself we are also interested in the integrated state variable z_t=boldsymbol1^topint_0^tx_sds. In order to derive the dynamics of the integrated state variable, we need to calculate","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nIleft(stright)  =int_s^tx_vdv\n  =int_s^tleft(Hleft(svright)leftx_s+int_s^vHleft(suright)^-1lefty_uboldsymbol1du+sigma_u^topdW_urightrightright)dv\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For the first term, we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"int_s^tHleft(svright)x_sdv=textdiagleft(Gleft(stright)right)x_s","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In order to simplify calculation for the second term we substitute dbarW_u=y_uboldsymbol1du+sigma_u^topdW_u. Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nint_s^tHleft(svright)int_s^vHleft(suright)^-1dbarW_udv  =int_s^tint_s^vHleft(uvright)dbarW_udv\n  =int_s^tleft(int_u^tHleft(uvright)dvright)dbarW_u\n  =int_s^ttextdiagleft(Gleft(utright)right)dbarW_u\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This yields","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Ileft(stright)=textdiagleft(Gleft(stright)right)x_s+int_s^ttextdiagleft(Gleft(utright)right)lefty_uboldsymbol1du+sigma_u^topdW_uright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With these preparations we get z_t=z_s+Gleft(stright)^topx_s+int_s^tGleft(utright)^toplefty_uboldsymbol1du+sigma_u^topdW_uright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Yield Curve Reconstruction","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We can derive future zero coupon bonds in terms of x_t and y_t as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"P(tT)=fracP(0T)P(0t)expleft -G(tT)^topx_t-frac12G(tT)^topy_tG(tT)right","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and future forward rates as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"f(tT)=f(0T)+boldsymbol1^topH(T)H(t)^-1leftx_t+y_tG(tT)right","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Also, we directly get the short rate representation","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r_t=f(0t)+boldsymbol1^topx_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"From the short rate we can also recontruct the bank account price process left(B_tright)_t as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"B_t=e^int_0^tr_sds=frace^z_tPleft(0tright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The zero coupon bond formula is the basic building block for calculating future option payoffs. More details on HJM models are elaborated in Andersen/Piterbarg, Interest Rate Modeling, 2010, Sec. 4.4 and 4.5. The bank account representation is used for numeraire calculation as well as future asset price reconstruction.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Constant mean reversion specification.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"So far, we have not specified the structure of the matrix function Hleft(tright) in our separable HJM model. In order, to make the model tractable, we set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hleft(tright)=textdiagleft(lefte^-chi_1tldotse^-chi_dtrightright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The parameters chi_1ldotschi_d represent the constant mean reversion parameters in the model.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With constant mean reversion parameters we can calculate","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hleft(stright)=textdiagleft(lefte^-chi_1left(t-sright)ldotse^-chi_dleft(t-sright)rightright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Gleft(stright)=leftfrac1-e^-chi_1left(t-sright)chi_1ldotsfrac1-e^-chi_dleft(t-sright)chi_dright^top","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Benchmark rates.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We choose d benchmark rates f_i(t)=f(tt+delta_i) (i=1ldotsd). The maturity terms delta_i represent the points on the yield curve that are selected to be modelled specifically. Consequently, delta_1 to delta_d should reasonably span the whole yield curve maturities relevant for pricing.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Furthermore, we denote","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"H^f(t)=left(beginarrayc\nhleft(t+delta_1right)^top\nvdots\nhleft(t+delta_dright)^top\nendarrayright)=left(beginarrayccc\ne^-chi_1left(t+delta_1right)  ldots  e^-chi_dleft(t+delta_1right)\nvdots    vdots\ne^-chi_1left(t+delta_dright)  ldots  e^-chi_dleft(t+delta_dright)\nendarrayright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"which yields","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"H(t)H^f(t)^-1=leftH^f(t)H(t)^-1right^-1=left(beginarrayccc\ne^-chi_1delta_1  ldots  e^-chi_ddelta_1\nvdots    vdots\ne^-chi_1delta_d  ldots  e^-chi_ddelta_d\nendarrayright)^-1","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Note that H(t)H^f(t)^-1 is independent of the observation time t. Consequently, the matrix inversion only needs to be evaluated once at inception of the model.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Benchmark rate volatility.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Model volatility is characterised by the volatility specification of the benchmark rates as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^f=left(beginarrayccc\nsigma_t^f_1\n  ddots\n    sigma_t^f_d\nendarrayright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The benchmark rate dynamics are coupled by a dtimes d correlation matrix Gamma_f which is decomposed into","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Gamma_f=leftD^fright^topD^f","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For our specification we choose a time-homogenous correlation matrix. Hence, the matrix decomposition above only needs to be computed at inception of the model.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Given the above specifications the volatility of the HJM model is defined via","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^top=H(t)H^f(t)^-1sigma_t^fD^f(t)^top","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The volatility specification is chosen such that dynamics of the benchmark rates become","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"df_i(t)=O(dt)+sigma_t^f_1dU_i(t)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with dU(t)=D^f(t)^topdW(t). For details on the derivation of the benchmark rate dynamics see Andersen/Piterbarg, Interest Rate Modeling, 2010, Prop. 13.3.2.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Note that within our hybrid model framework, the correlation Gamma_f is part of the full risk factor correlation matrix Gamma. Consequently, for our hybrid model interface, we use the specification","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^top=H(t)H^f(t)^-1sigma_t^f","category":"page"},{"location":"pages/simulation_framework/#Multi-factor-Gaussian-Model","page":"Simulation Framework","title":"Multi-factor Gaussian Model","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In order fully specify an interest rate model we need to define the dtimes d volatility process matrix left(sigma_tright)_t. By means of the benchmark forward rates f_i we already reduced this problem to the specification of the d individual benchmark rate volatility processes left(sigma_itright)_t. In this section, we give a first full specification of the benchmark rate volatility processes.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In a Gaussian model we assume deterministic volatility processes sigma_it=sigma_ileft(tright) for i=1ldotsd. In order to simplify analytics, er also assume that the volatility functions sigma_ileft(tright) are piece-wise constant. Then, also the model volatility sigma_t=sigmaleft(tright) is deterministic and piece-wise constant.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"An important consequence of this modelling choice is that the auxiliary state process y_t also becomes deterministic and easily computable. Assume yleft(sright) is known and sigmaleft(uright)=sigma is constant on the intervall left(stright). Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"yleft(sright)=Hleft(stright)yleft(sright)Hleft(stright)+int_s^tHleft(utright)sigma^topsigma Hleft(utright)ds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The integral becomes","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nint_s^tHleft(utright)sigma^topsigma Hleft(utright)ds  =leftint_s^te^-chi_ileft(t-uright)leftsigma^topsigmaright_ije^-chi_jleft(t-uright)duright_ij=1ldotsd\n  =leftleftsigma^topsigmaright_ijint_s^te^-left(chi_i+chi_jright)left(t-uright)duright_ij=1ldotsd\n  =leftleftsigma^topsigmaright_ijleftfrac1-e^-left(chi_i+chi_jright)left(t-uright)chi_i+chi_jrightright_ij=1ldotsd\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With this formula we calculate and store left(yleft(t_kright)right)_k on the grid left(t_1t_2ldotsright) of piece-wise constant volatility values left(sigma_left(kright)right)_k. Then a value yleft(tright) for some t_k-1leq tt_k is calculated as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"yleft(tright)=Hleft(t_k-1tright)yleft(t_k-1right)Hleft(t_k-1tright)+leftleftsigma_left(kright)^topsigma_left(kright)right_ijleftfrac1-e^-left(chi_i+chi_jright)left(t-t_k-1right)chi_i+chi_jrightright_ij=1ldotsd","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hybrid model interface.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In our hybrid model framework we need to take into account that we simulate in a measure other than the natural risk neutral measure for a given rates model. In such a situation need to take into account quanto adjustments. Denote left(W_t^nright)_t a Brownian motion under a common hybrid mode risk neutral measure. Girsanov's theorem yields that there is a process left(alpha_tright)_t and","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^n=W_t+int_0^talpha_sdt","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With this change of measure, we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=Hleft(stright)leftx_s+y_sGleft(stright)+int_s^tHleft(suright)^-1sigma_u^topleftsigma_uGleft(utright)du+leftdW_u^n-alpha_udurightrightright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =Hleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigmaleft(uright)^topleftsigmaleft(uright)Gleft(utright)-alpha_urightdu+\n  quad Hleft(stright)x_s+\n  quadint_s^tHleft(utright)sigmaleft(uright)^topdW_u^n\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Furthermore, we have for the integrated state variable","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nz_t  =z_s+Gleft(stright)^topx_s+int_s^tGleft(utright)^topleftyleft(uright)boldsymbol1du+sigmaleft(uright)^topleftdW_u^n-alpha_udurightright\n  =z_s+Gleft(stright)^topx_s+int_s^tGleft(utright)^topleftleftyleft(uright)boldsymbol1-sigmaleft(uright)^topalpha_urightdu+sigmaleft(uright)^topdW_u^nright\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"As a result, we find that we can specify our hybrid model state variable X_t^k and identify the model component functions Theta^kleft(cdotright), H^kleft(cdotright) and Sigma^kleft(cdotright) for a Gaussian model. We set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t^k=leftbeginarrayc\nx_t\nz_t\nendarrayright=leftbeginarrayc\nx_t^1\nvdots\nx_t^d\nz_t\nendarrayright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nTheta^kleft(stright)  =leftbeginarrayc\nHleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigmaleft(uright)^topleftsigmaleft(uright)Gleft(utright)-alpha_urightdu\nint_s^tGleft(utright)^topleftyleft(uright)boldsymbol1-sigmaleft(uright)^topalpha_urightdu\nendarrayright\nH^kleft(stright)  =leftbeginarraycc\nHleft(stright)  0\nGleft(stright)^top  1\nendarrayright\nSigmaleft(uright)^top  =leftbeginarrayc\nHleft(utright)sigmaleft(uright)^top\nGleft(utright)^topsigmaleft(uright)^top\nendarrayright\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We note, that the drift function Theta^k is only state-independent if the quanto drift alpha_t is state-independent. This property is closely linked to the volatility assumptions of the foreign exchange model between rates model's currency and the hybrid model numeraire currency.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Alternative drift formula.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=Hleft(stright)leftx_s+int_s^tHleft(suright)^-1lefty_uboldsymbol1du+sigma_u^topleftdW_u^n-alpha_udurightrightright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =int_s^tHleft(utright)leftyleft(uright)boldsymbol1-sigmaleft(uright)^topalpha_urightdt+\n  quad Hleft(stright)x_s+\n  quadint_s^tHleft(utright)sigmaleft(uright)^topdW_u^n\nendaligned","category":"page"},{"location":"pages/simulation_framework/#Tradeable-Asset-Models","page":"Simulation Framework","title":"Tradeable Asset Models","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this subsection we specify our component models for tradeable assets. Such assets are typically foreign exchange rates, equities, equity indices and inflation indices. We use the notation of foreign exchange rates models with domestic and foreign currency. An adaption to equity and inflation models is then straight forward.","category":"page"},{"location":"pages/simulation_framework/#Hybrid-FX-Modelling-Framework","page":"Simulation Framework","title":"Hybrid FX Modelling Framework","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We consider the positive price process left(S_tright)_t of one unit of foreign currency measured by units of domestic currency. Moreover, denote left(B_t^dright)_t and left(B_t^fright)_t the bank account processes in domestic and foreign currency. The process left(S_tB_t^fright)_t represents the price process of the foreign currency bank account measured in units of domestic currency. This is a tradeable asset in domestic currency. The domestic currency risk-neutral measure uses the bank account left(B_t^dright)_t as numeraire. As a consequence, the process","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"left(fracS_tB_t^fB_t^dright)_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"must be a martingale.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The martingale property motivates the asset price process","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"S_t=fracB_t^dB_t^fe^x_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"for a normalised state variable process left(x_tright)_t. For the state variable we assume the dynamics","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=-frac12int_0^tsigma_s^2ds+int_0^tsigma_sdW_s","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, left(sigma_tright)_t is a scalar volatility process adapted to cal F_t, and left(W_tright)_t is a scalar Brownian motion in the domestic currency risk-neutral measure.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Note that above specification of the process left(x_tright)_t covers a wide range of models. The models are distinguished by the modelling of the volatility process left(sigma_tright)_t. The representation S_t=left(B_t^dB_t^fright)e^x_t allows for a clear decoupling of interest rate modelling and hybrid asset modelling. For the sake of clarity we can also write the dynamics of left(S_tright)_t explicitely as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"S_t=S_s+int_s^tS_uleft(r_u^d-r_u^fright)du+int_s^tsigma_udW_u","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with domestic and foreign short rates r_u^d and r_u^f.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"There is an important consequence from the asset price representation S_t=left(B_t^dB_t^fright)e^x_t . In order to reconstruct future asset prices S_t the asset model must know its corresponding domestic and foreign interest rate model. Moreover, the asset model also requires the integrated state variables z_t^d and z_t^f in order to allow for the domestic and foreign interest rate model to calculate B_t^d and B_t^f.","category":"page"},{"location":"pages/simulation_framework/#Quanto-Adjustment","page":"Simulation Framework","title":"Quanto Adjustment","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"So far, we implicitly assumed that interest rate models are formulated in the risk-neutral measure of their respective currency. Similarly, we also assumed that asset models are formulated in their respective domestic currency risk neutral measure.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In a hybrid modelling framework for various currencies we need to decide on a common numeraire currency, the corresponding numeraire price process and the common martingale measure. Such a common martingale measure in general does not coincide with the risk-neutral measures that are typically used to formulate foreign currency component models. Consequently, we need to incorporate a change of measure for such foreign currency component models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this section, we formulate the change of measure from a given risk neutral measure to a common numeraire currency risk neutral measure. The change of measure is formulated in a rather general way in order to apply it later on for various component models. We consider a domestic currency with some asset price process X_t^d. For practical purposes, such an asset is typically","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"a domestic zero coupon bond with price process   left(P^dleft(tTright)right)_t or\nforeign currency bank account measured in units of domestic currency   with price process left(S_t^f-dB_t^fright)_t.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The corresponding domestic currency discounted asset process is denoted left(tildeX_t^dright)_t with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"tildeX_t^d=fracX_t^dB_t^d","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Without loss of generality, we assume that the discounted asset price process follows the dynamics","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"fracdtildeX_t^dtildeX_t^d=leftsigma_t^X^dright^topdW_t^d","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"where left(sigma_t^X^dright)_t is an adapted process and left(W_t^dright)_t is a n^d-dimensional Brownian motion in domestic currency risk neutral measure mathbbQ^d.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In addition to the domestic (and foreign) currency we consider a numeraire currency with bank account prices B_t^n. The price of one unit domestic currency measured by units of numeraire currency is denoted as S_t^d-n. The price of our domestic currency asset measured in units of numeraire currency is S_t^d-nX_t^d. Under the numeraire currency risk-neutral measure mathbbQ^n with numeraire price process left(B_t^nright)_t we can also formulate the discounted price process left(M_tright)_t with M_t=fracS_t^d-nP^dleft(tTright)B_t^n No-arbitrage arguments require that left(M_tright)_t is a mathbbQ^n-martingale.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Using our hybrid FX modelling framework we can write M_t as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"M_t=fracB_t^nB_t^de^x_t^d-nfracX_t^dB_t^n=fracX_t^dB_t^de^x_t^d-n=tildeX_t^de^x_t^d-n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with domestic numeraire FX model state variable process left(x_t^d-nright)_t. In order to further simplify notation, we set Y_t^d-n=e^x_t^d-n and note that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nY_t^d-n  =Y_0^d-n+int_0^tY_s^d-ndx_s^d-n+frac12int_0^tY_s^d-ndleftlangle x_s^d-nx_s^d-nrightrangle \n  =Y_0^d-n+int_0^tY_s^d-nsigma_s^d-ndW_s^d-n\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this representation, left(sigma_t^d-nright)_t is the FX volatility process of left(S_t^d-nright)_t and left(W_t^d-nright)_t is a Brownian motion in numeraire currency risk neutral measure. Above calculation also demonstrates that left(Y_t^d-nright)_t is a mathbbQ^n-martingale driven by an Ito integral.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Now, Ito product rule yields for the process left(M_tright)_t that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"M_t=M_0+int_0^ttildeX_s^ddY_s^d-n+int_0^tY_s^d-ndtildeX_s^d+int_0^tdleftlangle tildeX_s^dY_s^d-nrightrangle ","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The first Ito integral is","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_1=int_0^ttildeX_s^ddY_s^d-n=int_0^tM_ssigma_s^d-ndW_s^d-n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This term is a mathbbQ^n-martingale. For the second integral we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_2=int_0^tY_s^d-ndtildeX_s^d=int_0^tM_sleftsigma_s^X^dright^topdW_s^d","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This term is a mathbbQ^d-martingale because by construction left(W_t^dright)_t is a Brownian motion in the domestic currency risk neutral measure. for the third integral we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_3=int_0^tdleftlangle tildeX_s^dY_s^d-nrightrangle =int_0^tleftlangle dtildeX_s^ddY_s^d-nrightrangle =int_0^tM_sleftlangle leftsigma_s^X^dright^topdW_s^dsigma_s^d-ndW_s^d-nrightrangle ","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Girsanov's theorem yields that there is an adapted process left(alpha_tright)_t such that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^dn=W_t^d+int_0^talpha_sds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"is a Brownian motion under mathbbQ^n. This yields","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_2=int_0^tM_sleftsigma_t^X^dright^topleft(dW_s^dn-alpha_sdsright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For the third integral, we can now use linearity of covariance process and the property, that the quadratic variation of int_0^talpha_sds vanishes. This gives","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nI_3  =int_0^tM_sleftlangle leftsigma_s^X^dright^topleft(dW_s^dn-alpha_sdsright)sigma_s^d-ndW_s^d-nrightrangle \n  =int_0^tM_sleftlangle leftsigma_s^X^dright^topdW_s^dnsigma_s^d-ndW_s^d-nrightrangle \nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The Brownian motion increments are correlated such that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"leftlangle dW_s^dndW_s^d-nrightrangle =Gamma^X^dS^d-ndt","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with instantaneous correlation matrix Gamma^X^dS^d-n of shape left(n^d1right). This leads to the representation","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_3=int_0^tM_sleftsigma_s^X^dright^topGamma^X^dS^d-nsigma_s^d-nds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Recall that left(M_tright)_t is a mathbbQ^n-martingale. This requires that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_2+I_3=int_0^tM_sleftsigma_t^X^dright^topleft(dW_s^dn+leftGamma^X^dS^d-nsigma_s^d-n-alpha_srightdsright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"is a mathbbQ^n-martingale. This leads to the condition","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"alpha_t=Gamma^X^dS^d-nsigma_t^d-n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and the change of measure formula","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^dn=W_t^d+int_0^tGamma^X^dS^d-nsigma_s^d-nds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Quanto adjustment for rates models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For Gaussian rates models in a domestic currency we have","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Theta^kleft(stright)=leftbeginarrayc\nHleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigma^dleft(uright)^topleftsigma^dleft(uright)Gleft(utright)-alpha_urightdu\nint_s^tGleft(utright)^topleftyleft(uright)boldsymbol1-sigma^dleft(uright)^topalpha_urightdu\nendarrayright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Assets prices are zero coupon bonds, X_t^d=P^dleft(tTright) driven by the state variable x_t^d. Consequently, the quanto adjustment drift becomes","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"alpha_t=Gamma^x^dS^d-nsigma_t^d-n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, Gamma^x^dS^d-n summarises the instantaneous correlations of the interest rate risk factors and the FX risk factor. Assuming FX volatility is deterministic with sigma_t^d-n=sigma^d-nleft(tright), we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Theta^kleft(stright)=leftbeginarrayc\nHleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigma^dleft(uright)^topleftsigma^dleft(uright)Gleft(utright)-Gamma^x^dS^d-nsigma_t^d-nrightdu\nint_s^tGleft(utright)^topleftyleft(uright)boldsymbol1-sigma^dleft(uright)^topGamma^x^dS^d-nsigma_t^d-nrightdu\nendarrayright","category":"page"},{"location":"pages/simulation_framework/#Lognormal-Model","page":"Simulation Framework","title":"Lognormal Model","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We construct a basic asset model by assuming that the volatility process left(sigma_t^f-dright)_t is deterministic, i.e. sigma_t^f-d=sigma^f-dleft(tright). Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t^f-d=x_s^f-d-frac12int_s^tsigma^f-dleft(uright)^2du+int_s^tsigma^f-dleft(uright)dW_u^d","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"If the domestic currency differs from the numeraire currency then we need to incorporate quanto adjustment with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^dn=W_t^d+int_0^tGamma^S^f-dS^d-nsigma_s^d-nds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This yields","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t^f-d  =x_s^f-d-frac12int_s^tsigma^f-dleft(uright)^2du+int_s^tsigma^f-dleft(uright)leftdW_u^dn-Gamma^S^f-dS^d-nsigma_u^d-nduright\n  =x_s^f-d-frac12int_s^tsigma^f-dleft(uright)leftsigma^f-dleft(uright)+2Gamma^S^f-dS^d-nsigma_u^d-nrightdu+int_s^tsigma^f-dleft(uright)dW_u^dn\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this model setting the state variable process left(x_t^f-dright)_t has normal terminal distributions. Consequently, e^x_t is lognormal. If interest rates are modelled by (multi-factor) Gaussian models then B_t^d and B_t^f are also lognormal. As a result, we find that the asset price S_t is also lognormal.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In the lognormal model, our generic hybrid model state variable X_t^k and component functions Theta^kleft(cdotright), H^kleft(cdotright) and Sigma^kleft(cdotright) are easily identified. We set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nX_t^k  =leftx_tright\nTheta^kleft(stright)  =left-frac12int_s^tsigma^f-dleft(uright)leftsigma^f-dleft(uright)+2Gamma^S^f-dS^d-nsigma_u^d-nrightduright\nH^kleft(stright)  =left1right\nSigma^kleft(uright)^top  =leftsigma^f-dleft(uright)right\nendaligned","category":"page"},{"location":"models/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"In this section we document models for various risk factors.","category":"page"},{"location":"models/models/#Data-Structures-and-Constructors","page":"Models","title":"Data Structures and Constructors","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.Model","category":"page"},{"location":"models/models/#DiffFusion.Model","page":"Models","title":"DiffFusion.Model","text":"abstract type Model end\n\nAn abstract base model type. This type covers component models and hybrid composite models.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.ComponentModel","category":"page"},{"location":"models/models/#DiffFusion.ComponentModel","page":"Models","title":"DiffFusion.ComponentModel","text":"abstract type ComponentModel <: Model end\n\nAn abstract component model type. This type implements the common interface of all component models.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.AssetModel","category":"page"},{"location":"models/models/#DiffFusion.AssetModel","page":"Models","title":"DiffFusion.AssetModel","text":"abstract type AssetModel <: ComponentModel end\n\nAn AssetModel aims at modelling spot prices of tradeable assets like FX, shares and indices.\n\nWe implement several additional functions to handle quanto adjustments.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.LognormalAssetModel","category":"page"},{"location":"models/models/#DiffFusion.LognormalAssetModel","page":"Models","title":"DiffFusion.LognormalAssetModel","text":"struct LognormalAssetModel <: AssetModel\n    alias::String\n    sigma_x::BackwardFlatVolatility\n    state_alias::AbstractVector\n    factor_alias::AbstractVector\n    correlation_holder::CorrelationHolder\n    quanto_model::Union{AssetModel, Nothing}\nend\n\nA LognormalAssetModel is a model for simulating a spot price in a generalised Black-Scholes framework.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.lognormal_asset_model","category":"page"},{"location":"models/models/#DiffFusion.lognormal_asset_model","page":"Models","title":"DiffFusion.lognormal_asset_model","text":"lognormal_asset_model(\n    alias::String,\n    sigma_x::BackwardFlatVolatility,\n    ch::CorrelationHolder,\n    quanto_model::Union{AssetModel, Nothing}\n    )\n\nCreate a LognormalAssetModel.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.SeparableHjmModel","category":"page"},{"location":"models/models/#DiffFusion.SeparableHjmModel","page":"Models","title":"DiffFusion.SeparableHjmModel","text":"abstract type SeparableHjmModel <: ComponentModel end\n\nAn abstract type for separable HJM models.\n\nThis type covers common functions for Gaussian and Quasi-Gaussian models.\n\nThe SeparableHjmModel is supposed to hold a constant vector-valued ParameterTermstructure for mean reversion chi and benchmark rate times delta.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.GaussianHjmModel","category":"page"},{"location":"models/models/#DiffFusion.GaussianHjmModel","page":"Models","title":"DiffFusion.GaussianHjmModel","text":"struct GaussianHjmModel <: SeparableHjmModel\n    alias::String\n    delta::ParameterTermstructure\n    chi::ParameterTermstructure\n    sigma_T::GaussianHjmModelVolatility\n    y::AbstractArray\n    state_alias::AbstractVector\n    factor_alias::AbstractVector\n    correlation_holder::Union{CorrelationHolder, Nothing}\n    quanto_model::Union{AssetModel, Nothing}\nend\n\nA Gaussian HJM model with piece-wise constant benchmark rate volatility and constant mean reversion.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.gaussian_hjm_model","category":"page"},{"location":"models/models/#DiffFusion.gaussian_hjm_model","page":"Models","title":"DiffFusion.gaussian_hjm_model","text":"gaussian_hjm_model(\n    alias::String,\n    delta::ParameterTermstructure,\n    chi::ParameterTermstructure,\n    sigma_f::BackwardFlatVolatility,\n    correlation_holder::Union{CorrelationHolder, Nothing},\n    quanto_model::Union{AssetModel, Nothing},\n    )\n\nCreate a Gausian HJM model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#State-Variable","page":"Models","title":"State Variable","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"A model allows to simulate a stochastic process left(X_tright). For a given t the vector X_t is represented by a ModelState. ","category":"page"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.ModelState","category":"page"},{"location":"models/models/#DiffFusion.ModelState","page":"Models","title":"DiffFusion.ModelState","text":"struct ModelState\n    X::AbstractMatrix\n    idx::Dict{String,Int}\nend\n\nA ModelState is a matrix of state variables decorated by a dictionary of alias strings and optional additional parameters.\n\nIt allows to decouple simulation of state variables and usage of state variables.\n\nX is of size (n, p) where n represents the number of state aliases and p represents the number of paths. A matrix with a large number of paths is typically used when calling model functions for payoff evaluation.\n\nA single realisation of risk factors is represented by an (n, 1) matrix. We use (n,1) matrix instead of (n,) vector to avoid size-dependent switches.\n\nidx is a dictionary with n entries. Keys represent state state alias entries and values represent the corresponding positions in X.\n\nparams is a struct or dictionary that holds additional pre-calculated state-independent data which is used in subsequent Theta and Sigma calculations. This aims at avoiding duplicate calculations for state-dependent Theta and Sigma calculations. The params is supposed to be calculated by method simulation_parameters(...).\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.model_state","category":"page"},{"location":"models/models/#DiffFusion.model_state","page":"Models","title":"DiffFusion.model_state","text":"model_state(X::AbstractMatrix, idx::Dict{String,Int})\n\nCreate a ModelState object and make sure it is consistent.\n\n\n\n\n\nmodel_state(X::AbstractMatrix, m::Model, params = nothing)\n\nCreate a model state for a given model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.alias_dictionary","category":"page"},{"location":"models/models/#DiffFusion.alias_dictionary","page":"Models","title":"DiffFusion.alias_dictionary","text":"alias_dictionary(alias_list)\n\nCreate an alias dictionary\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Auxilliary-Methods","page":"Models","title":"Auxilliary Methods","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.alias(m::DiffFusion.Model)","category":"page"},{"location":"models/models/#DiffFusion.alias-Tuple{DiffFusion.Model}","page":"Models","title":"DiffFusion.alias","text":"alias(m::Model)\n\nReturn the model's own alias. This is the default implementation.\n\n\n\n\n\n","category":"method"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.model_alias","category":"page"},{"location":"models/models/#DiffFusion.model_alias","page":"Models","title":"DiffFusion.model_alias","text":"model_alias(m::Model)\n\nReturn the aliases modelled by a model.\n\nTypically, this coincides with the model's own alias. For composite models this is a list of component model aliases.\n\n\n\n\n\nmodel_alias(m::CompositeModel)\n\nReturn the aliases modelled by a model.\n\nTypical this coincides with the model's own alias. For composite models this is a list of component model aliases.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_alias","category":"page"},{"location":"models/models/#DiffFusion.state_alias","page":"Models","title":"DiffFusion.state_alias","text":"state_alias(m::Model)\n\nReturn a list of state alias strings that represent the model components.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.factor_alias","category":"page"},{"location":"models/models/#DiffFusion.factor_alias","page":"Models","title":"DiffFusion.factor_alias","text":"factor_alias(m::Model)\n\nReturn a list of risk factor alias strings that represent the components of the multi-variate Brownian motion risk factors. \n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.parameter_grid","category":"page"},{"location":"models/models/#DiffFusion.parameter_grid","page":"Models","title":"DiffFusion.parameter_grid","text":"parameter_grid(m::Model)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(models::AbstractVector)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::LognormalAssetModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::CompositeModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::GaussianHjmModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::MarkovFutureModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Model-Functions-for-Payoff-Evaluation","page":"Models","title":"Model Functions for Payoff Evaluation","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_asset","category":"page"},{"location":"models/models/#DiffFusion.log_asset","page":"Models","title":"DiffFusion.log_asset","text":"log_asset(m::Model, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_asset(m::LognormalAssetModel, model_alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\n\n\n\n\nlog_asset(m::CompositeModel, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_bank_account","category":"page"},{"location":"models/models/#DiffFusion.log_bank_account","page":"Models","title":"DiffFusion.log_bank_account","text":"log_bank_account(m::Model, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the integral over sum of state variables s(t) from interest rate model.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_bank_account(m::CompositeModel, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the integral over sum of state variables s(t) from interest rate model.\n\n\n\n\n\nlog_bank_account(m::GaussianHjmModel, model_alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the integral over sum of state variables s(t) from interest rate model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_zero_bond","category":"page"},{"location":"models/models/#DiffFusion.log_zero_bond","page":"Models","title":"DiffFusion.log_zero_bond","text":"log_zero_bond(m::Model, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the zero bond term [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_zero_bond(m::CompositeModel, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the zero bond term [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\n\n\n\n\nlog_zero_bond(m::GaussianHjmModel, model_alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the zero bond term [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_asset_convexity_adjustment","category":"page"},{"location":"models/models/#DiffFusion.log_asset_convexity_adjustment","page":"Models","title":"DiffFusion.log_asset_convexity_adjustment","text":"log_asset_convexity_adjustment(\n    m::Model,\n    dom_alias::String,\n    for_alias::String,\n    ast_alias::String,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    )\n\nCalculate the YoY convexity adjustment term for OU models.\n\nReturns a scalar quantity.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_future","category":"page"},{"location":"models/models/#DiffFusion.log_future","page":"Models","title":"DiffFusion.log_future","text":"log_future(m::Model, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the Future price term h(t,T)'[x(t) + 0.5y(t)(1 - h(t,T))].\n\n\n\n\n\nlog_future(m::CompositeModel, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the Future price term h(t,T)'[x(t) + 0.5y(t)(1 - h(t,T))].\n\n\n\n\n\nlog_future(m::MarkovFutureModel, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the Future price term (h(t,T)'[x(t) + 0.5y(t)(1 - h(t,T))])'.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.forward_rate_variance","category":"page"},{"location":"models/models/#DiffFusion.forward_rate_variance","page":"Models","title":"DiffFusion.forward_rate_variance","text":"forward_rate_variance(\n    m::Model,\n    alias::String,\n    t::ModelTime,\n    T::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    )\n\nCalculate the lognormal model variance of a forward looking or backward looking forward rate.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Model-Functions-for-Simulation","page":"Models","title":"Model Functions for Simulation","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.Theta","category":"page"},{"location":"models/models/#DiffFusion.Theta","page":"Models","title":"DiffFusion.Theta","text":"Theta(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t]. If Theta is state-dependent a state vector X must be supplied. The method returns a vector of length(state_alias).\n\n\n\n\n\nTheta(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t].\n\n\n\n\n\nTheta(\n    m::SimpleModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t].\n\n\n\n\n\nTheta(\n    m::GaussianHjmModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t]. If Theta is state-dependent a state vector X must be supplied. The method returns a vector of length(state_alias).\n\n\n\n\n\nTheta(\n    m::MarkovFutureModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t]. If Theta is state-dependent a state vector X must be supplied. The method returns a vector of length(state_alias).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.H_T","category":"page"},{"location":"models/models/#DiffFusion.H_T","page":"Models","title":"DiffFusion.H_T","text":"H_T(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t]. If H is state-dependent a state vector X must be supplied. We use the transposed of H to\n\nallow for efficient sparse CSC matrix insertion and\nallow for efficient multiplication X' * H' = (H * X)'.\n\nThe state vector X may effectively be a subset of all states. To accommodate this, we use a dedicated list of state aliases state_alias_H for the result matrix. The method returns a (sparse) matrix of size (length(state_alias_H), length(state_alias)).\n\n\n\n\n\nH_T(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::SimpleModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::GaussianHjmModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::MarkovFutureModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.Sigma_T","category":"page"},{"location":"models/models/#DiffFusion.Sigma_T","page":"Models","title":"DiffFusion.Sigma_T","text":"Sigma_T(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\nThe state vector is required if Sigma(u) depends on X_s.\n\nThe result of an evaluation of Sigma_T(...)(u) is a matrix of size (length(state_alias), length(factor_alias_Sigma)).\n\nThe Brownian motion relevant for a model may effectively be a subset of all Brownian motions. To accommodate this, we use a dedicated list of factor aliases factor_alias_Sigma for the size of the result matrix of a function evaluation.\n\nThe transposed '_T' is convention to simplify notation for covariance calculation.\n\n\n\n\n\nSigma_T(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\n\n\n\n\nSigma_T(\n    m::SimpleModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\n\n\n\n\nSigma_T(\n    m::GaussianHjmModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\n\n\n\n\nSigma_T(\n    m::MarkovFutureModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_dependent_Theta","category":"page"},{"location":"models/models/#DiffFusion.state_dependent_Theta","page":"Models","title":"DiffFusion.state_dependent_Theta","text":"state_dependent_Theta(m::Model)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::LognormalAssetModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::CompositeModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::GaussianHjmModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::MarkovFutureModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_dependent_H","category":"page"},{"location":"models/models/#DiffFusion.state_dependent_H","page":"Models","title":"DiffFusion.state_dependent_H","text":"state_dependent_H(m::Model)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::LognormalAssetModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::CompositeModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::GaussianHjmModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::MarkovFutureModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_dependent_Sigma","category":"page"},{"location":"models/models/#DiffFusion.state_dependent_Sigma","page":"Models","title":"DiffFusion.state_dependent_Sigma","text":"state_dependent_Sigma(m::Model)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::LognormalAssetModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::CompositeModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::GaussianHjmModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::MarkovFutureModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_alias_H","category":"page"},{"location":"models/models/#DiffFusion.state_alias_H","page":"Models","title":"DiffFusion.state_alias_H","text":"state_alias_H(m::Model)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::LognormalAssetModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::CompositeModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::GaussianHjmModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::MarkovFutureModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.factor_alias_Sigma","category":"page"},{"location":"models/models/#DiffFusion.factor_alias_Sigma","page":"Models","title":"DiffFusion.factor_alias_Sigma","text":"factor_alias_Sigma(m::Model)\n\nReturn a list of factor alias strings required for (Sigma(u)' Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::LognormalAssetModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::CompositeModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::GaussianHjmModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::MarkovFutureModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.covariance","category":"page"},{"location":"models/models/#DiffFusion.covariance","page":"Models","title":"DiffFusion.covariance","text":"covariance(\n    m::Model,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nCalculate the covariance matrix over a time interval.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.volatility_and_correlation","category":"page"},{"location":"models/models/#DiffFusion.volatility_and_correlation","page":"Models","title":"DiffFusion.volatility_and_correlation","text":"volatility_and_correlation(\n    m::Model,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    vol_eps::ModelValue = 1.0e-8,  # avoid division by zero\n    )\n\nCalculate the volatility vector and correlation matrix over a time interval.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.simulation_parameters","category":"page"},{"location":"models/models/#DiffFusion.simulation_parameters","page":"Models","title":"DiffFusion.simulation_parameters","text":"simulation_parameters(\n    m::Model,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\n\n\n\n\nsimulation_parameters(\n    m::GaussianHjmModel,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\nFor LognormalAssetModel there are no valuations that should be cached.\n\n\n\n\n\nsimulation_parameters(\n    m::GaussianHjmModel,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\nFor GaussianHjmModel there are no valuations that should be cached.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.diagonal_volatility","category":"page"},{"location":"models/models/#DiffFusion.diagonal_volatility","page":"Models","title":"DiffFusion.diagonal_volatility","text":"diagonal_volatility(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the path-dependent volatilities for a given model.\n\nX is supposed to hold a state matrix of size (n, p). Here, n is length(state_alias(m)) and p is the number of paths.\n\nThe method returns a matrix of size (n, p).\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Additional-Asset-Model-Functions","page":"Models","title":"Additional Asset Model Functions","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.asset_volatility","category":"page"},{"location":"models/models/#DiffFusion.asset_volatility","page":"Models","title":"DiffFusion.asset_volatility","text":"asset_volatility(\n    m::AssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a state-independent volatility function sigma(u) for the interval (s,t).\n\n\n\n\n\nasset_volatility(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a state-independent volatility function sigma(u) for the interval (s,t).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.correlation_holder(m::DiffFusion.AssetModel)","category":"page"},{"location":"models/models/#DiffFusion.correlation_holder-Tuple{DiffFusion.AssetModel}","page":"Models","title":"DiffFusion.correlation_holder","text":"correlation_holder(m::AssetModel)\n\nReturn the correlation holder term structure.\n\n\n\n\n\n","category":"method"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.quanto_drift","category":"page"},{"location":"models/models/#DiffFusion.quanto_drift","page":"Models","title":"DiffFusion.quanto_drift","text":"quanto_drift(\n    dom_factor_alias::AbstractVector,\n    quanto_model::Nothing,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a zero quanto adjustment function alpha(u).\n\n\n\n\n\nquanto_drift(\n    dom_factor_alias::AbstractVector,\n    quanto_model::AssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a function alpha(u) that allows to calculate the quanto adjustment on the time interval (s,t).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.asset_variance","category":"page"},{"location":"models/models/#DiffFusion.asset_variance","page":"Models","title":"DiffFusion.asset_variance","text":"asset_variance(\n    m::Model,\n    ast_alias::Union{String, Nothing},\n    dom_alias::Union{String, Nothing},\n    for_alias::Union{String, Nothing},\n    t::ModelTime,\n    T::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the lognormal model variance of an asset spot price over the time period [t,T]. If Model is state-dependent then variance calculation takes into account model state X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Additional-Rates-Model-Functions","page":"Models","title":"Additional Rates Model Functions","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_y","category":"page"},{"location":"models/models/#DiffFusion.func_y","page":"Models","title":"DiffFusion.func_y","text":"func_y(\n    y0::AbstractMatrix,\n    chi::AbstractVector,\n    sigmaT::AbstractMatrix,\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nCalculate variance/auxiliary state variable y(t) given y(s)=y_0.\n\nIn this function we assume that sigma is constant over the time interval (st).\n\n\n\n\n\nfunc_y(m::GaussianHjmModel, t::ModelTime)\n\nCalculate variance/auxiliary state variable y(t).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.chi_hjm","category":"page"},{"location":"models/models/#DiffFusion.chi_hjm","page":"Models","title":"DiffFusion.chi_hjm","text":"chi_hjm(m::SeparableHjmModel)\n\nReturn vector of constant mean reversion rates.\n\n\n\n\n\nchi_hjm(m::MarkovFutureModel)\n\nReturn vector of constant mean reversion rates.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.benchmark_times","category":"page"},{"location":"models/models/#DiffFusion.benchmark_times","page":"Models","title":"DiffFusion.benchmark_times","text":"benchmark_times(m::SeparableHjmModel)\n\nReturn vector of reference/benchmark times\n\n\n\n\n\nbenchmark_times(m::MarkovFutureModel)\n\nReturn vector of reference/benchmark times\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.H_hjm","category":"page"},{"location":"models/models/#DiffFusion.H_hjm","page":"Models","title":"DiffFusion.H_hjm","text":"H_hjm(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nDiagonal entries of H(st).\n\n\n\n\n\nH_hjm(m::SeparableHjmModel, s::ModelTime, t::ModelTime)\n\nDiagonal entries of H(st).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.G_hjm","category":"page"},{"location":"models/models/#DiffFusion.G_hjm","page":"Models","title":"DiffFusion.G_hjm","text":"G_hjm(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nVector function G(st).\n\n\n\n\n\nG_hjm(m::SeparableHjmModel, s::ModelTime, t::ModelTime)\n\nVector function G(st).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.benchmark_times_scaling","category":"page"},{"location":"models/models/#DiffFusion.benchmark_times_scaling","page":"Models","title":"DiffFusion.benchmark_times_scaling","text":"benchmark_times_scaling(chi::AbstractVector, delta::AbstractVector)\n\nBenchmark times volatility scaling matrix H H^f^-1 = H^f H^-1^-1.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Theta_x","category":"page"},{"location":"models/models/#DiffFusion.func_Theta_x","page":"Models","title":"DiffFusion.func_Theta_x","text":"func_Theta_x(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for state variable x.\n\nIn this function we assume for the interval (st) that     - variance y(s) is known,     - volatility  is state-independent and     - quanto adjustment alpha is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Theta_x_integrate_y","category":"page"},{"location":"models/models/#DiffFusion.func_Theta_x_integrate_y","page":"Models","title":"DiffFusion.func_Theta_x_integrate_y","text":"func_Theta_x_integrate_y(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for state variable x.\n\nAvoidance of explicit ^top  dependence may help with integrating over jumps in piece-wise constant volatility. \n\nIn this function we assume for the interval (st) that     - variance y is state-independent,     - volatility  is state-independent and     - quanto adjustment  is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Theta_s","category":"page"},{"location":"models/models/#DiffFusion.func_Theta_s","page":"Models","title":"DiffFusion.func_Theta_s","text":"func_Theta_s(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for integrated state variable s.\n\nIn this function we assume for the interval (st) that     - variance y state-independent,     - volatility  is state-independent and     - quanto adjustment  is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Theta","category":"page"},{"location":"models/models/#DiffFusion.func_Theta","page":"Models","title":"DiffFusion.func_Theta","text":"func_Theta(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for component model state variable X.\n\nIn this function we assume for the interval (st) that     - variance y state-independent,     - volatility  is state-independent and     - quanto adjustment  is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_H_T","category":"page"},{"location":"models/models/#DiffFusion.func_H_T","page":"Models","title":"DiffFusion.func_H_T","text":"func_H_T(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nCalculate H function for component model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_H_T_dense","category":"page"},{"location":"models/models/#DiffFusion.func_H_T_dense","page":"Models","title":"DiffFusion.func_H_T_dense","text":"func_H_T_dense(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nAlternative H function implementation for debugging.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Sigma_T","category":"page"},{"location":"models/models/#DiffFusion.func_Sigma_T","page":"Models","title":"DiffFusion.func_Sigma_T","text":"func_Sigma_T(\n    chi::AbstractVector,\n    sigmaT::Function,\n    s::ModelTime,\n    t::ModelTime\n    )\n\nCalculate (u)^top function for component model.\n\nIn this function we assume for the interval (st) that     - volatility  is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.GaussianHjmModelVolatility","category":"page"},{"location":"models/models/#DiffFusion.GaussianHjmModelVolatility","page":"Models","title":"DiffFusion.GaussianHjmModelVolatility","text":"struct GaussianHjmModelVolatility\n    HHfInv::AbstractMatrix\n    sigma_f::BackwardFlatVolatility\n    DfT::AbstractMatrix\nend\n\nA dedicated matrix-valued volatility term structure for Gaussian HJM Models.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.swap_rate_instantaneous_covariance","category":"page"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.swap_rate_variance","category":"page"},{"location":"models/models/#DiffFusion.swap_rate_variance","page":"Models","title":"DiffFusion.swap_rate_variance","text":"swap_rate_variance(\n    m::Model,\n    alias::String,\n    yts::YieldTermstructure,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    X::ModelState,\n    )\n\nCalculate the normal model variance of a swap rate via Gaussian swap rate approximation.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"In this section we document data and functions to work with the product and model examples.","category":"page"},{"location":"payoffs/payoffs/#Payoffs","page":"Payoffs","title":"Payoffs","text":"","category":"section"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"In this section we document the payoff scripting framework.","category":"page"},{"location":"analytics/analytics/#Analytics","page":"Analytics","title":"Analytics","text":"","category":"section"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"In this section we document methods for instrument pricing, exposure and collateral simulation.","category":"page"},{"location":"paths/paths/#Paths","page":"Paths","title":"Paths","text":"","category":"section"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"In this section we document data structures and methods for path setup.","category":"page"},{"location":"serialisation/serialisation/#Serialisation","page":"Serialisation","title":"Serialisation","text":"","category":"section"},{"location":"serialisation/serialisation/","page":"Serialisation","title":"Serialisation","text":"In this section we document methods for serialising and de-serialising objects.","category":"page"},{"location":"simulations/simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"simulations/simulations/","page":"Simulations","title":"Simulations","text":"In this section we document data structures and methods for Monte Carlo  simulation and path setup.","category":"page"},{"location":"termstructures/termstructures/#Term-Structures","page":"Term Structures","title":"Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"In this section we document term structures.","category":"page"},{"location":"termstructures/termstructures/#Term-Structure-Types-and-Methods","page":"Term Structures","title":"Term Structure Types and Methods","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.Termstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.Termstructure","page":"Term Structures","title":"DiffFusion.Termstructure","text":"abstract type Termstructure end\n\nAn abstract term structure that provides an alias for identification.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.alias(ts::DiffFusion.Termstructure)","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.alias-Tuple{DiffFusion.Termstructure}","page":"Term Structures","title":"DiffFusion.alias","text":"alias(ts::Termstructure)\n\nReturn the term structure's alias.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.TermstructureResultSize","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.TermstructureResultSize","page":"Term Structures","title":"DiffFusion.TermstructureResultSize","text":"@enum(\n    TermstructureResultSize,\n    TermstructureVector,\n    TermstructureScalar\n)\n\nSpecify the dimensions/shape of the values modelled by a term structure.\n\nFor some term structures (e.g. ParameterTermstructure and VolatilityTermstructure) the result may be either a vector or a scalar.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/#CorrelationTermstructure","page":"Term Structures","title":"CorrelationTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.CorrelationTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.CorrelationTermstructure","page":"Term Structures","title":"DiffFusion.CorrelationTermstructure","text":"abstract type CorrelationTermstructure <: Termstructure end\n\nAn abstract correlation term structure that provides methods to calculate instantaneous correlations.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for CorrelationTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::CorrelationTermstructure)(args...) = correlation(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    alias1::String,\n    alias2::String,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, String, String}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, alias1::String, alias2::String)\n\nReturn a scalar instantaneous correlation.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    aliases::AbstractVector{String},\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, AbstractVector{String}}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, aliases::AbstractVector{String})\n\nReturn a symmetric matrix of instantaneous correlations.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    aliases1::AbstractVector{String},\n    aliases2::AbstractVector{String},\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, AbstractVector{String}, AbstractVector{String}}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, aliases2::AbstractVector{String})\n\nReturn a matrix of instantaneous correlations, each element of aliases1 versus each element of aliases2. The size of the resulting matrix is (length(aliases1), length(aliases2)).\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    alias1::String,\n    aliases2::AbstractVector{String},\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, String, AbstractVector{String}}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, alias1::String, aliases2::AbstractVector{String})\n\nReturn an (1,N) matrix of instantaneous correlations.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    aliases1::AbstractVector{String},\n    alias2::String,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, AbstractVector{String}, String}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, alias2::String)\n\nReturn an (N, 1) matrix of instantaneous correlations.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#CreditDefaultTermstructure","page":"Term Structures","title":"CreditDefaultTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.CreditDefaultTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.CreditDefaultTermstructure","page":"Term Structures","title":"DiffFusion.CreditDefaultTermstructure","text":"abstract type CreditDefaultTermstructure <: Termstructure end\n\nAn abstract credit default term structure that provides methods to calculate survival probabilities.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for CreditDefaultTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::CreditDefaultTermstructure)(args...) = survival(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.survival(\n    ts::DiffFusion.CreditDefaultTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.survival-Tuple{DiffFusion.CreditDefaultTermstructure, Number}","page":"Term Structures","title":"DiffFusion.survival","text":"survival(ts::CreditDefaultTermstructure, t::ModelTime)\n\nReturn the survival probability with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#FuturesTermstructure","page":"Term Structures","title":"FuturesTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.FuturesTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.FuturesTermstructure","page":"Term Structures","title":"DiffFusion.FuturesTermstructure","text":"abstract type FuturesTermstructure <: Termstructure end\n\nAn abstract futures term structure that provides methods to calculate prices of futures. Such prices represent risk-neutral expectations of spot prices.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for FuturesTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::FuturesTermstructure)(args...) = future_price(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.future_price(\n    ts::DiffFusion.FuturesTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.future_price-Tuple{DiffFusion.FuturesTermstructure, Number}","page":"Term Structures","title":"DiffFusion.future_price","text":"future_price(ts::FuturesTermstructure, t::ModelTime)\n\nReturn the price of a future with settlement time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#InflationTermstructure","page":"Term Structures","title":"InflationTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.InflationTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.InflationTermstructure","page":"Term Structures","title":"DiffFusion.InflationTermstructure","text":"abstract type InflationTermstructure <: Termstructure end\n\nAn abstract inflation term structure that provides methods to calculate forward inflation index. Forward inflation index is a T-forward measure expectation of (spot) inflation index values.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for InflationTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::InflationTermstructure)(args...) = inflation_index(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.inflation_index(\n    ts::DiffFusion.InflationTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.inflation_index-Tuple{DiffFusion.InflationTermstructure, Number}","page":"Term Structures","title":"DiffFusion.inflation_index","text":"inflation_index(ts::InflationTermstructure, t::ModelTime)\n\nReturn the forward inflation index with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#ParameterTermstructure","page":"Term Structures","title":"ParameterTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.ParameterTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.ParameterTermstructure","page":"Term Structures","title":"DiffFusion.ParameterTermstructure","text":"abstract type ParameterTermstructure <: Termstructure end\n\nAn abstract generic parameter term structure that provides methods to retrieve parameter values for various incarnations of signatures.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for ParameterTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::ParameterTermstructure)(args...) = value(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.value(\n    ts::DiffFusion.ParameterTermstructure,\n    result_size::DiffFusion.TermstructureResultSize = DiffFusion.TermstructureVector,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.value","page":"Term Structures","title":"DiffFusion.value","text":"value(ts::ParameterTermstructure, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for constant/time-homogeneous parameters.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.value(\n    ts::DiffFusion.ParameterTermstructure,\n    t::ModelTime,\n    result_size::DiffFusion.TermstructureResultSize = DiffFusion.TermstructureVector,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.value-2","page":"Term Structures","title":"DiffFusion.value","text":"value(ts::ParameterTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/#YieldTermstructure","page":"Term Structures","title":"YieldTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.YieldTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.YieldTermstructure","page":"Term Structures","title":"DiffFusion.YieldTermstructure","text":"abstract type YieldTermstructure <: Termstructure end\n\nAn abstract yield term structure that provides methods to calculate discount factors zero rates and forward rates.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for YieldTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::YieldTermstructure)(args...) = discount(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.discount(\n    ts::DiffFusion.YieldTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.discount-Tuple{DiffFusion.YieldTermstructure, Number}","page":"Term Structures","title":"DiffFusion.discount","text":"discount(ts::YieldTermstructure, t::ModelTime)\n\nReturn the discount factor with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.zero_rate(\n    ts::DiffFusion.YieldTermstructure,\n    t0::ModelTime,\n    t1::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.zero_rate-Tuple{DiffFusion.YieldTermstructure, Number, Number}","page":"Term Structures","title":"DiffFusion.zero_rate","text":"zero_rate(ts::YieldTermstructure, t0::ModelTime, t1::ModelTime)\n\nReturn the continuous compounded zero rate over a period t0 to t1.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.zero_rate(\n    ts::DiffFusion.YieldTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.zero_rate-Tuple{DiffFusion.YieldTermstructure, Number}","page":"Term Structures","title":"DiffFusion.zero_rate","text":"zero_rate(ts::YieldTermstructure, t::ModelTime)\n\nReturn the continuous compounded zero rate as of today with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.forward_rate(\n    ts::DiffFusion.YieldTermstructure,\n    t::ModelTime,\n    dt=1.0e-6,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.forward_rate","page":"Term Structures","title":"DiffFusion.forward_rate","text":"forward_rate(ts::YieldTermstructure, t::ModelTime, dt=1.0e-6)\n\nReturn the instantaneous forward rate with observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/#VolatilityTermstructure","page":"Term Structures","title":"VolatilityTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.VolatilityTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.VolatilityTermstructure","page":"Term Structures","title":"DiffFusion.VolatilityTermstructure","text":"abstract type VolatilityTermstructure <: Termstructure end\n\nAn abstract volatility term structure that provides methods to calculate volatility values for various incarnations of signatures.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for VolatilityTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::VolatilityTermstructure)(args...) = volatility(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.volatility(\n    ts::DiffFusion.VolatilityTermstructure,\n    t::ModelTime,\n    result_size::DiffFusion.TermstructureResultSize = DiffFusion.TermstructureVector,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.volatility","page":"Term Structures","title":"DiffFusion.volatility","text":"volatility(ts::VolatilityTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a volatility for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.volatility(\n    ts::DiffFusion.VolatilityTermstructure,\n    t::ModelTime,\n    x::ModelValue,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.volatility-Tuple{DiffFusion.VolatilityTermstructure, Number, Number}","page":"Term Structures","title":"DiffFusion.volatility","text":"volatility(ts::VolatilityTermstructure, t::ModelTime, x::ModelValue)\n\nReturn a scalar volatility for a given observation time t and underlying or strike value x.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#Correlation-Term-Structures","page":"Term Structures","title":"Correlation Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.CorrelationHolder","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.CorrelationHolder","page":"Term Structures","title":"DiffFusion.CorrelationHolder","text":"struct CorrelationHolder <: CorrelationTermstructure\n    alias::String\n    correlations::Dict\n    sep::String\nend\n\nA container holding correlation values.\n\nA CorrelationHolder allows to calculate correlation matrices based on String alias keys (identifiers).\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation_holder","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation_holder","page":"Term Structures","title":"DiffFusion.correlation_holder","text":"correlation_holder(\n    alias::String,\n    sep = \"<>\",\n    )\n\nCreate an empty CorrelationHolder object.\n\n\n\n\n\ncorrelation_holder(m::AssetModel)\n\nReturn the correlation holder term structure.\n\n\n\n\n\nReturn the model's CorrelationHolder.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation_key","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation_key","page":"Term Structures","title":"DiffFusion.correlation_key","text":"correlation_key(ch::CorrelationHolder, alias1::String, alias2::String)\n\nDerive the key for correlation dictionary from two aliases.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.set_correlation!","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.set_correlation!","page":"Term Structures","title":"DiffFusion.set_correlation!","text":"set_correlation!(\n    ch::CorrelationHolder,\n    alias1::String,\n    alias2::String,\n    value::ModelValue\n    )\n\nInsert a new correlation value into CorrelationHolder. If a correlation already exists it is overwritten.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.get","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.get","page":"Term Structures","title":"DiffFusion.get","text":"get(ch::CorrelationHolder, alias1::String, alias2::String)\n\nImplement methodology to obtain a scalar correlation from a CorrelationHolder.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/#Parameter-Term-Structures","page":"Term Structures","title":"Parameter Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.PiecewiseFlatParameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.PiecewiseFlatParameter","page":"Term Structures","title":"DiffFusion.PiecewiseFlatParameter","text":"abstract type PiecewiseFlatParameter <: ParameterTermstructure end\n\nA generic vector-valued model parameter term structure with piece-wise constant interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.BackwardFlatParameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.BackwardFlatParameter","page":"Term Structures","title":"DiffFusion.BackwardFlatParameter","text":"struct BackwardFlatParameter <: PiecewiseFlatParameter\n    alias::String\n    times::AbstractVector\n    values::AbstractMatrix\nend\n\nA generic vector-valued model parameter term structure with piece-wise constant backward-flat interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.backward_flat_parameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.backward_flat_parameter","page":"Term Structures","title":"DiffFusion.backward_flat_parameter","text":"backward_flat_parameter(\n     alias::String,\n     times::AbstractVector,\n     values::AbstractMatrix,\n     )\n\nCreate a BackwardFlatParameter object for vector-valued parameters.\n\n\n\n\n\nbackward_flat_parameter(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a BackwardFlatParameter object for scalar parameters.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.flat_parameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.flat_parameter","page":"Term Structures","title":"DiffFusion.flat_parameter","text":"flat_parameter(value::ModelValue)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\nflat_parameter(alias::String, value::ModelValue)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\nflat_parameter(value::AbstractVector)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\nflat_parameter(alias::String, value::AbstractVector)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.ForwardFlatParameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.ForwardFlatParameter","page":"Term Structures","title":"DiffFusion.ForwardFlatParameter","text":"struct ForwardFlatParameter <: PiecewiseFlatParameter\n    alias::String\n    times::AbstractVector\n    values::AbstractMatrix\nend\n\nA generic vector-valued model parameter term structure with piece-wise constant forward-flat interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.forward_flat_parameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.forward_flat_parameter","page":"Term Structures","title":"DiffFusion.forward_flat_parameter","text":"forward_flat_parameter(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractMatrix,\n    )\n\nCreate a ForwardFlatParameter object for vector-valued parameters.\n\n\n\n\n\nforward_flat_parameter(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a ForwardFlatParameter object for scalar parameters.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.time_idx(ts::DiffFusion.BackwardFlatParameter, t)","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.time_idx-Tuple{DiffFusion.BackwardFlatParameter, Any}","page":"Term Structures","title":"DiffFusion.time_idx","text":"time_idx(ts::BackwardFlatParameter, t)\n\nFind the index such that T[idx-1] < t <= T[idx]. If t is larger than the last (or all) times T then return length(T)+1.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.time_idx(ts::DiffFusion.ForwardFlatParameter, t)","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.time_idx-Tuple{DiffFusion.ForwardFlatParameter, Any}","page":"Term Structures","title":"DiffFusion.time_idx","text":"time_idx(ts::ForwardFlatParameter, t)\n\nFind the index such that T[idx] >= t > T[idx+1]. If t is smaller than the first (or all) times T then return 0.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#Yield-Term-Structures","page":"Term Structures","title":"Yield Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.FlatForward","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.FlatForward","page":"Term Structures","title":"DiffFusion.FlatForward","text":"struct FlatForward <: YieldTermstructure\n    alias::String\n    rate\nend\n\nA constant yield term structure.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.flat_forward","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.flat_forward","page":"Term Structures","title":"DiffFusion.flat_forward","text":"flat_forward(alias::String, rate)\n\nCreate a FlatForward yield curve.\n\n\n\n\n\nflat_forward(rate)\n\nCreate a FlatForward yield curve without alias.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.ZeroCurve","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.ZeroCurve","page":"Term Structures","title":"DiffFusion.ZeroCurve","text":"struct ZeroCurve <: YieldTermstructure\n    alias::String\n    times::AbstractVector\n    values::AbstractVector\n    interpolation\nend\n\nA yield term structure based on interpolated continuous compounded zero rates.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.zero_curve","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.zero_curve","page":"Term Structures","title":"DiffFusion.zero_curve","text":"zero_curve(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    interp_method = (x,y) -> linear_interpolation(x, y, extrapolation_bc = Line()),\n    )\n\nCreate a ZeroCurve object.\n\n\n\n\n\nzero_curve(\n    times::AbstractVector,\n    values::AbstractVector,\n    interp_method = (x,y) -> linear_interpolation(x, y, extrapolation_bc = Line()),\n    )\n\nCreate a ZeroCurve object without alias.\n\n\n\n\n\nzero_curve(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    method_alias::String,\n    )\n\nCreate a ZeroCurve object using interpolation string.\n\n\n\n\n\nzero_curve(\n    times::AbstractVector,\n    values::AbstractVector,\n    method_alias::String,\n    )\n\nCreate a ZeroCurve object using interpolation string.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/#Volatility-Term-Structures","page":"Term Structures","title":"Volatility Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.BackwardFlatVolatility","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.BackwardFlatVolatility","page":"Term Structures","title":"DiffFusion.BackwardFlatVolatility","text":"struct BackwardFlatVolatility <: VolatilityTermstructure\n    alias::String\n    times::AbstractVector\n    values::AbstractMatrix\nend\n\nA vector-valued volatility term structure with piece-wise constant (backward-flat) interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.backward_flat_volatility","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.backward_flat_volatility","page":"Term Structures","title":"DiffFusion.backward_flat_volatility","text":"backward_flat_volatility(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractMatrix,\n    )\n\nCreate a BackwardFlatVolatility object for vector-valued volatility.\n\nVolatility values are of size (nvols, ntimes).\n\n\n\n\n\nbackward_flat_volatility(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a BackwardFlatVolatility object for scalar volatility.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.flat_volatility","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.flat_volatility","page":"Term Structures","title":"DiffFusion.flat_volatility","text":"flat_volatility(alias::String, value)\n\nCreate a BackwardFlatVolatility object for a flat volatility.\n\n\n\n\n\nflat_volatility(alias::String, value)\n\nCreate a BackwardFlatVolatility object for a flat volatility.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.time_idx(ts::DiffFusion.BackwardFlatVolatility, t)","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.time_idx-Tuple{DiffFusion.BackwardFlatVolatility, Any}","page":"Term Structures","title":"DiffFusion.time_idx","text":"time_idx(ts::BackwardFlatVolatility, t)\n\nFind the index such that T[idx-1] < t <= T[idx]. If t is larger than the last (or all) times T then return length(T)+1.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#Common-Methods-Overview","page":"Term Structures","title":"Common Methods Overview","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, alias1::String, alias2::String)\n\nReturn a scalar instantaneous correlation.\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, aliases::AbstractVector{String})\n\nReturn a symmetric matrix of instantaneous correlations.\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, aliases2::AbstractVector{String})\n\nReturn a matrix of instantaneous correlations, each element of aliases1 versus each element of aliases2. The size of the resulting matrix is (length(aliases1), length(aliases2)).\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, alias1::String, aliases2::AbstractVector{String})\n\nReturn an (1,N) matrix of instantaneous correlations.\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, alias2::String)\n\nReturn an (N, 1) matrix of instantaneous correlations.\n\n\n\n\n\ncorrelation(ch::CorrelationHolder, alias1::String, alias2::String)\n\nReturn a scalar instantaneous correlation.\n\n\n\n\n\ncorrelation(ch::CorrelationHolder, aliases1::AbstractVector{String}, aliases2::AbstractVector{String})\n\nReturn a matrix of instantaneous correlations, each element of aliases1 versus each element  of aliases2. The size of the resulting matrix is (length(aliases1), length(aliases2)).\n\n\n\n\n\ncorrelation(ch::CorrelationHolder, aliases::AbstractVector{String})\n\nReturn a symmetric matrix of instantaneous correlations.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.discount","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.discount","page":"Term Structures","title":"DiffFusion.discount","text":"discount(ts::YieldTermstructure, t::ModelTime)\n\nReturn the discount factor with observation time t.\n\n\n\n\n\ndiscount(ts::FlatForward, t::ModelTime)\n\nCalculate discount factor.\n\n\n\n\n\ndiscount(ts::ZeroCurve, t::ModelTime)\n\nCalculate discount factor.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.value","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.value-3","page":"Term Structures","title":"DiffFusion.value","text":"value(ts::ParameterTermstructure, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for constant/time-homogeneous parameters.\n\n\n\n\n\nvalue(ts::ParameterTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for a given observation time t.\n\n\n\n\n\nvalue(ts::PiecewiseFlatParameter, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for constant/time-homogeneous parameters.\n\n\n\n\n\nvalue(ts::PiecewiseFlatParameter, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.volatility","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.volatility-2","page":"Term Structures","title":"DiffFusion.volatility","text":"volatility(ts::VolatilityTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a volatility for a given observation time t.\n\n\n\n\n\nvolatility(ts::VolatilityTermstructure, t::ModelTime, x::ModelValue)\n\nReturn a scalar volatility for a given observation time t and underlying or strike value x.\n\n\n\n\n\nvolatility(ts::BackwardFlatVolatility, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a vector of volatilities for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.survival","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.survival","page":"Term Structures","title":"DiffFusion.survival","text":"survival(ts::CreditDefaultTermstructure, t::ModelTime)\n\nReturn the survival probability with observation time t.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"In this section we document commonly used utility structures methods.","category":"page"},{"location":"utils/utils/#Interpolation-Methods","page":"Utilities","title":"Interpolation Methods","text":"","category":"section"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"DiffFusion.interpolation_methods","category":"page"},{"location":"utils/utils/#DiffFusion.interpolation_methods","page":"Utilities","title":"DiffFusion.interpolation_methods","text":"const interpolation_methods = Dict{String, Function}(...)\n\nSpecify names for available interpolation methods.\n\nDictionary values are constructors with signature (x,y) -> interpolation\n\nAvailable interpolation strings (i.e. keys) are\n\nLINEAR,\nCUBIC,\nAKIMA,\nFRITSCHCARLSON,\nSTEFFEN.\n\nSee package Interpolations for details.\n\n\n\n\n\n","category":"constant"},{"location":"pages/additional_functions/#Additional-Functions","page":"Additional Functions","title":"Additional Functions","text":"","category":"section"},{"location":"pages/additional_functions/","page":"Additional Functions","title":"Additional Functions","text":"In this section we document additional functions.","category":"page"},{"location":"pages/additional_functions/","page":"Additional Functions","title":"Additional Functions","text":"DiffFusion.alias","category":"page"},{"location":"pages/additional_functions/#DiffFusion.alias","page":"Additional Functions","title":"DiffFusion.alias","text":"alias(ts::Termstructure)\n\nReturn the term structure's alias.\n\n\n\n\n\nalias(m::Model)\n\nReturn the model's own alias. This is the default implementation.\n\n\n\n\n\nalias(m::MarkovFutureModel)\n\nReturn the model's own alias. This is the default implementation.\n\n\n\n\n\n","category":"function"},{"location":"pages/additional_functions/#Aliases-for-Common-Abstract-Data-Types","page":"Additional Functions","title":"Aliases for Common Abstract Data Types","text":"","category":"section"},{"location":"pages/additional_functions/","page":"Additional Functions","title":"Additional Functions","text":"DiffFusion.ModelTime","category":"page"},{"location":"pages/additional_functions/#DiffFusion.ModelTime","page":"Additional Functions","title":"DiffFusion.ModelTime","text":"A type alias for variables representing time.\n\n\n\n\n\n","category":"type"},{"location":"pages/additional_functions/","page":"Additional Functions","title":"Additional Functions","text":"DiffFusion.ModelValue","category":"page"},{"location":"pages/additional_functions/#DiffFusion.ModelValue","page":"Additional Functions","title":"DiffFusion.ModelValue","text":"A type alias for variables representing modelled quantities.\n\n\n\n\n\n","category":"type"},{"location":"products/products/#Products","page":"Products","title":"Products","text":"","category":"section"},{"location":"products/products/","page":"Products","title":"Products","text":"In this section we document product objects and methods.","category":"page"},{"location":"pages/function_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"pages/function_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#DiffFusion.jl-[F]","page":"DiffFusion.jl [F]","title":"DiffFusion.jl [F]","text":"","category":"section"},{"location":"","page":"DiffFusion.jl [F]","title":"DiffFusion.jl [F]","text":"Documentation for DiffFusion.jl","category":"page"},{"location":"","page":"DiffFusion.jl [F]","title":"DiffFusion.jl [F]","text":"The DiffFusion.jl package implements a framework for joint simulation of financial risk factors, risk-neutral valuation of financial instruments and calculation of portfolio risk measures.","category":"page"},{"location":"","page":"DiffFusion.jl [F]","title":"DiffFusion.jl [F]","text":"The intended purpose of the package is efficient exposure simulation for XVA and Counterparty Credit Risk (CCR).","category":"page"},{"location":"#Repository","page":"DiffFusion.jl [F]","title":"Repository","text":"","category":"section"},{"location":"","page":"DiffFusion.jl [F]","title":"DiffFusion.jl [F]","text":"The code for DiffFusion.jl is hosted at github.com/frame-consulting/DiffFusion.jl.","category":"page"},{"location":"#Installation","page":"DiffFusion.jl [F]","title":"Installation","text":"","category":"section"},{"location":"","page":"DiffFusion.jl [F]","title":"DiffFusion.jl [F]","text":"The package can be obtained as source code directly via","category":"page"},{"location":"","page":"DiffFusion.jl [F]","title":"DiffFusion.jl [F]","text":"git clone https://github.com/frame-consulting/DiffFusion.jl","category":"page"},{"location":"","page":"DiffFusion.jl [F]","title":"DiffFusion.jl [F]","text":"This package is in development stage. For details on the intended functionality, see the Overview page.","category":"page"},{"location":"","page":"DiffFusion.jl [F]","title":"DiffFusion.jl [F]","text":"For questions please contact info@frame-consult.de.","category":"page"}]
}
