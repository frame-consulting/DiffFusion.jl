var documenterSearchIndex = {"docs":
[{"location":"pages/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"On this page, we give an overview of the DiffFusion.jl modelling framework.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Some features mentioned here are still under development and will be added going forward. If you want to check the status of particular features, please get in touch.","category":"page"},{"location":"pages/overview/#What-Is-the-Purpose-of-the-Framework?","page":"Overview","title":"What Is the Purpose of the Framework?","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Scenario-based financial instrument pricing is at the core of most risk management processes and methods. The DiffFusion.jl modelling framework provides a flexible and computationally efficient simulation and pricing engine. It contains state-of-the art model implementations for single and multi-factor models.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The framework is designed for regular large-scale portfolio simulations as well as ad-hoc and interactive pricing and risk calculation analysis. As such, the framework can be used in production processes as well for benchmarking and model validation purposes. ","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"DiffFusion.jl is decomposed into the following components:","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"scenario generation,\nscenario-based financial instrument pricing and sensitivity calculation, as well as\nscenario-based risk measure calculation.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The components can be used independently. However, they develop their full potential when combined together. ","category":"page"},{"location":"pages/overview/#Scenario-Generation","page":"Overview","title":"Scenario Generation","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Scenario generation is based on Monte Carlo simulation of risk factors. Risk factors are represented by generic model state variables. The evolution of the model state variables is based on diffusion models.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The diffusion models in the DiffFusion.jl framework represent market standard risk neutral valuation models. For details on the specific models, see the model section. A key objective of the framework is flexibility regarding the choice model. For example, you can combine multi-factor rates models for major currencies with single-factor rates models for other currencies.  ","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Component models for e.g. interest rates, exchange rates and equities are combined into a cross-asset hybrid model. The joint evolution of the hybrid model state variables is then calculated by Monte Carlo simulation.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The Monte Carlo method in the DiffFusion.jl framework uses bias-free simulation of random variables whenever the model allows for. This approach provides flexibility on the chosen time grid and allows simulating long time-horizons without sacrificing simulation accuracy. Random numbers are drawn from efficient pseudo-random number generators or low-discrepancy sequences.","category":"page"},{"location":"pages/overview/#Financial-Instrument-Pricing-and-Sensitivity-Calculation","page":"Overview","title":"Financial Instrument Pricing and Sensitivity Calculation","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Financial instruments in the DiffFusion.jl framework are represented as a layered composition of payoffs, cash flows and cash flow legs. Each layer adds a level of abstraction and common functionality. Cash flow legs are finally combined into products and portfolios.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The layered design of portfolios and products allows for a very flexible extendability of the framework for new products and feature. Exotic products can easily be integrated since payoffs and payoff-scripting are integral functionalities by design.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Portfolios and products are agnostic to the simulation model and Monte Carlo method. The link between model, simulation and market data is established via a separate entity that holds the context details. This feature also contributes to the flexibility and extendability of the framework. ","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Future risk-neutral prices of portfolios and products are calculated using the simulated state variables and the corresponding models. We implement analytical pricing methods whenever available and appropriate. American Monte-Carlo methods will be available for complex products.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Sensitivities of future prices can be calculated efficiently using Algorithmic Differentiation (AD) methods. AD methods are directly available in the Julia language. For more details on AD in Julia, see the Julia section. ","category":"page"},{"location":"pages/overview/#Risk-Measure-Calculation","page":"Overview","title":"Risk Measure Calculation","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Scenario prices for portfolios and products are stored in a three-dimensional scenario cube. The axes of the cube are simulated scenarios, future observation times and individual product legs. With these data we calculate risk measures like expected exposure and potential future exposure. New risk measures can easily be added to the framework. Alternatively, scenario cubes can also be processed by client applications or directly by the user.","category":"page"},{"location":"pages/overview/#What-Models-and-Products-Are-Covered?","page":"Overview","title":"What Models and Products Are Covered?","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework covers models for interest rates, exchange rates, equities/indices, inflation, and commodity futures. All models can be combined into hybrid models for joint simulation.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Financial products are composed of cash flows. Cash flows for linear products are directly available in the framework. New cash flow types can easily be added.","category":"page"},{"location":"pages/overview/#Component-Models","page":"Overview","title":"Component Models","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"We make extensive use of the Heath-Jarrow-Morton (HJM) framework for the component models. This approach yields most analytical tractability for simulation, pricing and model calibration. More complex model variants can be easily added to the framework.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Interest rates are modelled as multi-factor Gaussian HJM models. Such models allow for a rich set of simulated yield curves involving curve shifts, slopes and curvatures. The models can be calibration to the full surface of at-the-money swaptions. In its single-factor form, the model reduces to the classical Hull-White interest rate model.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Exchange rates are modelled in a classical Black-Scholes-type model. Exchange rate models are linked to the corresponding domestic and foreign interest rate models. Calibration of the models takes into account the joint evolution of exchange rates as well as corresponding interest rates.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Equities and indices are modelled analogous to exchange rates. In that context, the foreign interest rate model is replaced by a dividend yield term structure. The framework allows for a modelling of discrete dividend and dividend yields.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Inflation models are designed following the foreign currency analogy. As a consequence, inflation models are also analogous to exchange rate models. This approach covers the classical Jarrow-Yildirim three-factor model as well as the two-factor Dodgson-Kainth model. Initial inflation forward curves are direct inputs to the model. This allows for modelling seasonality.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Commodity futures are modelled following the HJM framework applied for interest rates. As a consequence, we can cover single-factor models and multi-factor models. This allows for a modelling of futures volatility term structures. Initial futures curves are direct input to the model and can incorporate commodity-specific features like seasonality patterns.","category":"page"},{"location":"pages/overview/#Cash-Flows-and-Legs","page":"Overview","title":"Cash Flows and Legs","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework already includes standard fixed income and interest rate cash flows for principal payments, fixed rates and floating rates.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Linear FX and cross currency instruments are covered by the interest rate cash flows and exchange rate conversion. Additional principal payments in mark-to-market cross currency swaps are handled by a specific leg type.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Further cash flow typed and leg types will be added going forward.","category":"page"},{"location":"pages/overview/#Why-Do-We-Use-Julia-Language?","page":"Overview","title":"Why Do We Use Julia Language?","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Risk factor simulation and scenario-based financial instrument pricing are computationally expensive calculations. Efficient implementation of such calculations requires fast compiled machine code, ability to parallelize and distribute calculations as well as support for high-performance computing hardware like GPU. The Julia language natively fulfills all these requirements.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Development in Julia language is lightweight and similar to languages like Python. As a result, new functionalities can easily be added within the framework or attached by client applications or user interaction.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"Sensitivity calculation is critical for risk management processes. For exposure simulations, sensitivity calculations can be particularly challenging from a computational perspective. These challenges are addressed by Automatic Differentiation (AD) methods. Julia language supports forward mode and reverse mode AD via operator overloading and source transformation. We leverage these language features and provide efficient and accurate Delta and Vega calculations.","category":"page"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"The DiffFusion.jl framework can be incorporated as package in Julia application and user code. Furthermore, the framework can be used e.g. in Jupyter notebooks, Python code and R code via Julia's interfaces to these environments. The DiffFusion.jl framework can also run fully independent, e.g. in a Docker container.","category":"page"},{"location":"pages/overview/#label_literature_and_references","page":"Overview","title":"Related Literature and References","text":"","category":"section"},{"location":"pages/overview/","page":"Overview","title":"Overview","text":"L. Andersen, V. Piterbarg. Interest Rate Modeling. 2010.\nR. Jarrow, Y. Yildirim. Pricing Treasury Inflation Protected Securities and Related Derivatives Using an Hjm Model. 2003.\nL. Andersen. Markov Models for Commodity Futures: Theory and Practice. 2008.\nA. Green. XVA. 2016.\nL. Andersen, M. Pykhtin, A. Sokol. Rethinking Margin Period of Risk. 2016.\nThe Julia Programming Language\nPyJulia - a Python interface to the Julia language\nJuliaCall - an R interface to the Julia language","category":"page"},{"location":"pages/simulation_framework/#Simulation-Framework","page":"Simulation Framework","title":"Simulation Framework","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this documentation we discuss our framework for efficient implementation of Monte Carlo methods that aim at simulating joint diffusion processes. The framework is designed with the following objectives in mind:","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Simulation should be exact (i.e. bias-free) if the underlying model   allows for exact simulation.\nFramework should allow for efficient factorisation of the joint   covariance matrix and exploit independence structures.\nSimulation should be formulated in terms of matrix and tensor   operations.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Simulation models in scope are models for interest rates, FX rates, equities, inflation, futures and credit. Basic variants of such models can be formulated as Ornstein-Uhlenbeck (OU) processes. Such OU processes do allow for exact simulation.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Common notation.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t is an n-dimensional state variable which describes the   model dynamic.\nW_u is an m-dimensional Brownian motion under the common   risk-neutral measure mathbbQ.\nGamma is an mtimes m matrix representing correlations of   increments in W_u.\ns, u, t are simulation times with 0leq sleq uleq t.\nX_t^k for k=1ldotsN are model component states that   represent a slice of the full vector X_t.\nThetaleft(cdotright), Hleft(cdotright),   Sigmaleft(cdotright) and Lleft(cdotright) are composite   model functions for the full state X_t.\nTheta^kleft(cdotright), H^kleft(cdotright) and   Sigma^kleft(cdotright) are component model functions that   represent slices of Thetaleft(cdotright),   Hleft(cdotright) and Sigmaleft(cdotright).\nVleft(stX_sright) is a diagonal ntimes n matrix   representing volatilities of the increments of state vector X_t.\nCleft(stX_sright) is a ntimes n matrix representing   correlations of the increments of state vector X_t.\nZ^left(1right)ldotsZ^left(pright) are independent   n-dimensional standard normal random variables for p paths.\nX_t^left(1right)ldotsX_t^left(pright) are simulated   realisations of the full random state variable X_t for p   paths.","category":"page"},{"location":"pages/simulation_framework/#Hybrid-Model-Specification","page":"Simulation Framework","title":"Hybrid Model Specification","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The hybrid model is described by a multi-variate process left(X_tright)_t with X_tinmathbbR^n and initial condition X_0=0. The elements of the process left(X_tright)_t are grouped into models. That is, we decompose","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t=leftbeginarrayc\nX_t^1\nvdots\nX_t^N\nendarrayright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Each component model is descibed by the process left(X_t^kright)_t with X_t^kinmathbbR^n_k, k=1ldotsN. Each component model is specified independently but with a common interface. This allows for a flexible combination of models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Component models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Denote left(Omegacal F_tmathbbQright) a filtered probability space with (risk-neutral) probability measure mathbbQ. The common structure of the component models is given by the dynamics","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t^k=Theta^kleft(stX_sright)+H^kleft(stX_sright)X_s+int_s^tSigma^kleft(uX_sright)^topdW_u","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"for 0leq sleq t. Here, Theta^kleft(stX_sright)inmathbbR^n_k is a deterministic drift vector. The matrix H^kleft(stX_sright)inmathbbR^n_ktimes n typically accounts for mean reversion in the component model. Finally, the matrix Sigma^kleft(uX_sright)^topinmathbbR^n_ktimes m represents the volatility function of the component model and W_uinmathbbR^m is an m-dimensional vector of Brownian motions under mathbbQ.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Above specification is fairly general. We make a few comments to indicate how concrete component models will implement the specification.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The component model functions Theta^k, H^k and Sigma^k  may depend on the model state X_s. However, we impose that the  model state is observed at time s. This allows to cover local and  stochastic volatility models. But the component model functions  already need to implement some time-discretisation.\nIdeally, the component model functions Theta^k, H^k and  Sigma^k are independent of the model state. This is the case  for models based on OU processes. Then simulation can be exact.\nIn typical cases, component model states X_t^k do not depend  on the full hybrid model state X_s. Instead, X_t^k (as  well as Theta^k, H^k and Sigma^k) only use information  from X_s^k plus a few dependencies to other models.  Consequently, the dimensions n and m can effectively be reduced  to numbers in the order of n_k. We leave the general  representation in order to keep notation brief. But keep in mind  that with the general notation the full matrices H^k and  Sigma^k will be sparse.","category":"page"},{"location":"pages/simulation_framework/#Hybrid-Model-Simulation","page":"Simulation Framework","title":"Hybrid Model Simulation","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Our general component model specification yields that the hybrid model dynamics become","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t=Thetaleft(stX_sright)+Hleft(stX_sright)X_s+int_s^tSigmaleft(uX_sright)^topdW_u","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with composite hybrid model functions","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nThetaleft(stX_sright)  =leftbeginarrayc\nTheta^1left(stX_sright)\nvdots\nTheta^Nleft(stX_sright)\nendarrayrightinmathbbR^n\nHleft(stX_sright)  =leftbeginarrayc\nH^1left(stX_sright)^top\nvdots\nH^Nleft(stX_sright)^top\nendarrayrightinmathbbR^ntimes nquadtextand\nSigmaleft(uX_sright)^top  =leftbeginarrayc\nSigma^1left(uX_sright)^top\nvdots\nSigma^Nleft(uX_sright)^top\nendarrayrightinmathbbR^ntimes m\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"As a consequence, we find that X_tX_s is multi-variate normally distributed with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"mathbbEleftX_tX_sright=Thetaleft(stX_sright)+Hleft(stX_sright)X_sinmathbbR^n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"textCovleftX_tX_sright=int_s^tSigmaleft(uX_sright)^topGammaSigmaleft(uX_sright)dtinmathbbR^ntimes n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The constant symmetric matrix GammainmathbbR^mtimes m represents the instantaneous correlations of increments dW_t. We get for the elements textCovleftX_tX_sright_ij of the covariance matrix","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\ntextCovleftX_tX_sright_ij  =int_s^tSigmaleft(uX_sright)_i^topGammaSigmaleft(uX_sright)_jdu\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, Sigmaleft(uX_sright)_i and Sigmaleft(uX_sright)_j are the i-th and j-th column (ij=1ldotsn) of the volatility matrix Sigmaleft(uX_sright).","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The covariance matrix is decomposed into a diagonal state-volatility matrix Vleft(stX_sright) and a state-correlation matrix Cleft(stX_sright) such that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nleftVleft(stX_sright)right_ii  =sqrtlefttextCovleftX_tX_srightright_iileft(t-sright)\nleftCleft(stX_sright)right_ii  =1\nleftCleft(stX_sright)right_ij  =begincases\nfraclefttextCovleftX_tX_srightright_ijleftVleft(stX_sright)right_iileftVleft(stX_sright)right_jjleft(t-sright)  textif leftVleft(stX_sright)right_iileftVleft(stX_sright)right_jj0\n0  textelse\nendcases\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"for all indices ij=1ldotsn. Then textCovleftX_tX_sright=Vleft(stX_sright)Cleft(stX_sright)Vleft(stX_sright)left(t-sright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"If all model functions are independent of the state X_s then we can directly calculate a (Cholesky) decomposition","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"textCovleftX_tX_sright=Vleft(stright)Lleft(stright)Lleft(stright)^topVleft(stright)left(t-sright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With such a factorisation we can simulate","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t=Thetaleft(stright)+Hleft(stright)X_s+Vleft(stright)Lleft(stright)Zsqrtt-s","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with standard normal vectors Zsimcal Nleft(01right). For a list of paths leftX_s^left(1right)ldotsX_s^left(pright)rightinmathbbR^ntimes p and standard normal increments leftZ^left(1right)ldotsZ^left(pright)rightinmathbbR^ntimes p this can be implemented as matrix multiplication and addition","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nleftX_t^left(1right)ldotsX_t^left(pright)right  =leftThetaleft(stright)ldotsThetaleft(stright)right\n  quad+Hleft(stright)^topleftX_s^left(1right)ldotsX_s^left(pright)right\n  quad+Vleft(stright)Lleft(stright)leftZ^left(1right)ldotsZ^left(pright)rightsqrtt-s\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The assumption of state-independent model component functions holds e.g. for Gaussian short rate models, Black-Scholes equity/foreign exchange models, and Dodgson-Kainth inflation model.","category":"page"},{"location":"pages/simulation_framework/#Component-Models","page":"Simulation Framework","title":"Component Models","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this section, we specify component models for our hybrid model framework.","category":"page"},{"location":"pages/simulation_framework/#Interest-Rate-Models","page":"Simulation Framework","title":"Interest Rate Models","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Interest rate models are formulated as separable Heath-Jarrow-Morton (HJM) models for the continuous forward rate fleft(tTright) with observation time t and term T.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Our specification follows in large parts Andersen/Piterbarg, Interest Rate Modeling, 2010, Sec. 4.4 and 4.5.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Forward rates are directly linked to zero coupon bonds Pleft(tTright). We have","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Pleft(tTright)=expleft -int_t^Tfleft(tsright)dsright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"or equivalently","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"fleft(tTright)=-fracpartialpartial Tlogleft(Pleft(tTright)right)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We formulate the model in risk neutral measure. The risk neutral measure uses the continuous bank account as numeraire. The bank account accruals at the short rate","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r_t=f(tt)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"And the price process of the bank account left(B_tright)_t is given by","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"B_t=e^int_0^tr_sds","category":"page"},{"location":"pages/simulation_framework/#Heath-Jarrow-Morton-Modelling-Framework","page":"Simulation Framework","title":"Heath-Jarrow-Morton Modelling Framework","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Consider a general HJM model for the forward rates f(tT). No-arbitrage considerations yield the dynamics","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"dfleft(tTright)=sigma_fleft(tTright)^topcdotleftint_t^Tsigma_fleft(turight)durightcdot dt+sigma_fleft(tTright)^topcdot dW_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, sigma_fleft(tTright)^top is a d-dimensional vector of forward rate volatilities and W_t is a d-dimensional Brownian motion in the risk-neutral measure. The drift term of the HJM model follows from no-arbitrage considerations. Thus it remains to specify the forward rate volatility function sigma_fleft(tTright)^top.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In an HJM model with separable volatility the forward rate volatility takes the form sigma_fleft(tTright)=gleft(tright)hleft(Tright). Here gleft(tright)=gleft(tomegaright)inmathbbR^dtimes d is a matrix-valued process adapted to cal F_t and hleft(Tright)inmathbbR^d is a vector-valued deterministic function. The models of this class are also considered Quasi-Gaussian models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For an HJM model we get the bond price dynamics in risk-neutral measure as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"fracdPleft(tTright)Pleft(tTright)=r_tcdot dt-sigma_Pleft(tTright)^topcdot dW_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The minus sign indicates that if rates increase bond prices decrease (and vice versa). In a separable volatility HJM model the bond price volatility becomes","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_Pleft(tTright)=gleft(tright)cdotint_t^Thleft(uright)cdot du","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Integration yields the forward rates","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nfleft(tTright)  =fleft(0Tright)+\n  quad hleft(Tright)^topint_0^tgleft(sright)^topgleft(sright)left(int_s^Thleft(uright)duright)ds+\n  quad hleft(Tright)^topint_0^tgleft(sright)^topdW_s\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r_t=fleft(0tright)+hleft(tright)^topleftint_0^tgleft(sright)^topgleft(sright)left(int_s^thleft(uright)duright)ds+int_0^tgleft(sright)^topdW_sright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We can re-write hleft(tright)^top=boldsymbol1^topHleft(tright) and get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r(t)=f(0t)+boldsymbol1^topHleft(tright)leftint_0^tgleft(sright)^topgleft(sright)left(int_s^thleft(uright)duright)ds+int_0^tgleft(sright)^topdW_sright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"boldsymbol1=left(beginarrayc\n1\nvdots\n1\nendarrayright)text and Hleft(tright)=textdiagleft(hleft(tright)right)=left(beginarrayccc\nh_1left(tright)  0  0\n0  ddots  0\n0  0  h_dleft(tright)\nendarrayright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Now, we can introduce the vector of state variables x_t with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =Hleft(tright)leftint_0^tgleft(sright)^topgleft(sright)left(int_s^thleft(uright)duright)ds+int_0^tgleft(sright)^topdW_sright\n  =Hleft(tright)leftint_0^tgleft(sright)^topsigma_Pleft(stright)ds+int_0^tgleft(sright)^topdW_sright\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Some (lengthy) calculations yield the representation","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hleft(tright)^-1x_t-Hleft(sright)^-1x_s=Hleft(sright)^-1y_sGleft(stright)+int_s^tgleft(uright)^topleftsigma_Pleft(utright)du+dW_uright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with model function","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Gleft(stright)=int_s^tHleft(sright)^-1Hleft(uright)boldsymbol1du","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and auxilliary state variable process","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"y_t=Hleft(tright)left(int_0^tgleft(sright)^topgleft(sright)dsright)Hleft(tright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Separation of volatility and mean reversion.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In order to better separate volatility and mean reversion components, we set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\ngleft(tright)  =Hleft(tright)^-1sigma_t\nHleft(stright)  =Hleft(tright)Hleft(sright)^-1\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =Hleft(stright)leftx_s+y_sGleft(stright)+int_s^tHleft(suright)^-1sigma_u^topleftsigma_uGleft(utright)du+dW_urightright\ny_t  =Hleft(stright)y_sHleft(stright)+int_s^tHleft(utright)sigma_u^topsigma_uHleft(utright)ds\nGleft(stright)  =int_s^tHleft(suright)boldsymbol1du\nsigma_Pleft(utright)  =sigma_uGleft(utright)\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Above representation is the basis for our hybrid model interface.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We note, that we also get the following equality for the drift terms","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"underbracey_sGleft(stright)+int_s^tHleft(suright)^-1sigma_u^topsigma_uGleft(utright)du_I_1left(tright)=underbraceint_s^tHleft(suright)^-1y_uboldsymbol1du_I_2left(tright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This property follows by differentiating both sides w.r.t. t. Then we get for the left side of the equation","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nI_1left(tright)  =y_sHleft(stright)boldsymbol1+int_s^tHleft(suright)^-1sigma_u^topsigma_uHleft(utright)boldsymbol1du\n  =y_sHleft(stright)boldsymbol1+Hleft(stright)^-1int_s^tHleft(utright)sigma_u^topsigma_uHleft(utright)boldsymbol1du\n  =y_sHleft(stright)boldsymbol1+Hleft(stright)^-1lefty_t-Hleft(stright)y_sHleft(stright)rightboldsymbol1\n  =Hleft(stright)^-1y_tboldsymbol1\n  =I_2left(tright)\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The alternative representation of the drift term is useful in some situations because the integrand does not depend on the upper boundary t. We get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=Hleft(stright)leftx_s+int_s^tHleft(suright)^-1lefty_uboldsymbol1du+sigma_u^topdW_urightright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Integrated state variable.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In addition to the state variable x_t itself we are also interested in the integrated state variable z_t=boldsymbol1^topint_0^tx_sds. In order to derive the dynamics of the integrated state variable, we need to calculate","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nIleft(stright)  =int_s^tx_vdv\n  =int_s^tleft(Hleft(svright)leftx_s+int_s^vHleft(suright)^-1lefty_uboldsymbol1du+sigma_u^topdW_urightrightright)dv\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For the first term, we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"int_s^tHleft(svright)x_sdv=textdiagleft(Gleft(stright)right)x_s","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In order to simplify calculation for the second term we substitute dbarW_u=y_uboldsymbol1du+sigma_u^topdW_u. Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nint_s^tHleft(svright)int_s^vHleft(suright)^-1dbarW_udv  =int_s^tint_s^vHleft(uvright)dbarW_udv\n  =int_s^tleft(int_u^tHleft(uvright)dvright)dbarW_u\n  =int_s^ttextdiagleft(Gleft(utright)right)dbarW_u\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This yields","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Ileft(stright)=textdiagleft(Gleft(stright)right)x_s+int_s^ttextdiagleft(Gleft(utright)right)lefty_uboldsymbol1du+sigma_u^topdW_uright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With these preparations we get z_t=z_s+Gleft(stright)^topx_s+int_s^tGleft(utright)^toplefty_uboldsymbol1du+sigma_u^topdW_uright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Yield Curve Reconstruction","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We can derive future zero coupon bonds in terms of x_t and y_t as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"P(tT)=fracP(0T)P(0t)expleft -G(tT)^topx_t-frac12G(tT)^topy_tG(tT)right","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and future forward rates as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"f(tT)=f(0T)+boldsymbol1^topH(T)H(t)^-1leftx_t+y_tG(tT)right","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Also, we directly get the short rate representation","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"r_t=f(0t)+boldsymbol1^topx_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"From the short rate we can also recontruct the bank account price process left(B_tright)_t as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"B_t=e^int_0^tr_sds=frace^z_tPleft(0tright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The zero coupon bond formula is the basic building block for calculating future option payoffs. More details on HJM models are elaborated in Andersen/Piterbarg, Interest Rate Modeling, 2010, Sec. 4.4 and 4.5. The bank account representation is used for numeraire calculation as well as future asset price reconstruction.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Constant mean reversion specification.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"So far, we have not specified the structure of the matrix function Hleft(tright) in our separable HJM model. In order, to make the model tractable, we set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hleft(tright)=textdiagleft(lefte^-chi_1tldotse^-chi_dtrightright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The parameters chi_1ldotschi_d represent the constant mean reversion parameters in the model.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With constant mean reversion parameters we can calculate","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hleft(stright)=textdiagleft(lefte^-chi_1left(t-sright)ldotse^-chi_dleft(t-sright)rightright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Gleft(stright)=leftfrac1-e^-chi_1left(t-sright)chi_1ldotsfrac1-e^-chi_dleft(t-sright)chi_dright^top","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Benchmark rates.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We choose d benchmark rates f_i(t)=f(tt+delta_i) (i=1ldotsd). The maturity terms delta_i represent the points on the yield curve that are selected to be modelled specifically. Consequently, delta_1 to delta_d should reasonably span the whole yield curve maturities relevant for pricing.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Furthermore, we denote","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"H^f(t)=left(beginarrayc\nhleft(t+delta_1right)^top\nvdots\nhleft(t+delta_dright)^top\nendarrayright)=left(beginarrayccc\ne^-chi_1left(t+delta_1right)  ldots  e^-chi_dleft(t+delta_1right)\nvdots    vdots\ne^-chi_1left(t+delta_dright)  ldots  e^-chi_dleft(t+delta_dright)\nendarrayright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"which yields","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"H(t)H^f(t)^-1=leftH^f(t)H(t)^-1right^-1=left(beginarrayccc\ne^-chi_1delta_1  ldots  e^-chi_ddelta_1\nvdots    vdots\ne^-chi_1delta_d  ldots  e^-chi_ddelta_d\nendarrayright)^-1","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Note that H(t)H^f(t)^-1 is independent of the observation time t. Consequently, the matrix inversion only needs to be evaluated once at inception of the model.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Benchmark rate volatility.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Model volatility is characterised by the volatility specification of the benchmark rates as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^f=left(beginarrayccc\nsigma_t^f_1\n  ddots\n    sigma_t^f_d\nendarrayright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The benchmark rate dynamics are coupled by a dtimes d correlation matrix Gamma_f which is decomposed into","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Gamma_f=leftD^fright^topD^f","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For our specification we choose a time-homogenous correlation matrix. Hence, the matrix decomposition above only needs to be computed at inception of the model.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Given the above specifications the volatility of the HJM model is defined via","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^top=H(t)H^f(t)^-1sigma_t^fD^f(t)^top","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The volatility specification is chosen such that dynamics of the benchmark rates become","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"df_i(t)=O(dt)+sigma_t^f_1dU_i(t)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with dU(t)=D^f(t)^topdW(t). For details on the derivation of the benchmark rate dynamics see Andersen/Piterbarg, Interest Rate Modeling, 2010, Prop. 13.3.2.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Note that within our hybrid model framework, the correlation Gamma_f is part of the full risk factor correlation matrix Gamma. Consequently, for our hybrid model interface, we use the specification","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^top=H(t)H^f(t)^-1sigma_t^f","category":"page"},{"location":"pages/simulation_framework/#Multi-factor-Gaussian-Model","page":"Simulation Framework","title":"Multi-factor Gaussian Model","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In order fully specify an interest rate model we need to define the dtimes d volatility process matrix left(sigma_tright)_t. By means of the benchmark forward rates f_i we already reduced this problem to the specification of the d individual benchmark rate volatility processes left(sigma_itright)_t. In this section, we give a first full specification of the benchmark rate volatility processes.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In a Gaussian model we assume deterministic volatility processes sigma_it=sigma_ileft(tright) for i=1ldotsd. In order to simplify analytics, er also assume that the volatility functions sigma_ileft(tright) are piece-wise constant. Then, also the model volatility sigma_t=sigmaleft(tright) is deterministic and piece-wise constant.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"An important consequence of this modelling choice is that the auxiliary state process y_t also becomes deterministic and easily computable. Assume yleft(sright) is known and sigmaleft(uright)=sigma is constant on the intervall left(stright). Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"yleft(sright)=Hleft(stright)yleft(sright)Hleft(stright)+int_s^tHleft(utright)sigma^topsigma Hleft(utright)ds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The integral becomes","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nint_s^tHleft(utright)sigma^topsigma Hleft(utright)ds  =leftint_s^te^-chi_ileft(t-uright)leftsigma^topsigmaright_ije^-chi_jleft(t-uright)duright_ij=1ldotsd\n  =leftleftsigma^topsigmaright_ijint_s^te^-left(chi_i+chi_jright)left(t-uright)duright_ij=1ldotsd\n  =leftleftsigma^topsigmaright_ijleftfrac1-e^-left(chi_i+chi_jright)left(t-uright)chi_i+chi_jrightright_ij=1ldotsd\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With this formula we calculate and store left(yleft(t_kright)right)_k on the grid left(t_1t_2ldotsright) of piece-wise constant volatility values left(sigma_left(kright)right)_k. Then a value yleft(tright) for some t_k-1leq tt_k is calculated as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"yleft(tright)=Hleft(t_k-1tright)yleft(t_k-1right)Hleft(t_k-1tright)+leftleftsigma_left(kright)^topsigma_left(kright)right_ijleftfrac1-e^-left(chi_i+chi_jright)left(t-t_k-1right)chi_i+chi_jrightright_ij=1ldotsd","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hybrid model interface.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In our hybrid model framework we need to take into account that we simulate in a measure other than the natural risk neutral measure for a given rates model. In such a situation need to take into account quanto adjustments. Denote left(W_t^nright)_t a Brownian motion under a common hybrid mode risk neutral measure. Girsanov's theorem yields that there is a process left(alpha_tright)_t and","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^n=W_t+int_0^talpha_sdt","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"With this change of measure, we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=Hleft(stright)leftx_s+y_sGleft(stright)+int_s^tHleft(suright)^-1sigma_u^topleftsigma_uGleft(utright)du+leftdW_u^n-alpha_udurightrightright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =Hleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigmaleft(uright)^topleftsigmaleft(uright)Gleft(utright)-alpha_urightdu+\n  quad Hleft(stright)x_s+\n  quadint_s^tHleft(utright)sigmaleft(uright)^topdW_u^n\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Furthermore, we have for the integrated state variable","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nz_t  =z_s+Gleft(stright)^topx_s+int_s^tGleft(utright)^topleftyleft(uright)boldsymbol1du+sigmaleft(uright)^topleftdW_u^n-alpha_udurightright\n  =z_s+Gleft(stright)^topx_s+int_s^tGleft(utright)^topleftleftyleft(uright)boldsymbol1-sigmaleft(uright)^topalpha_urightdu+sigmaleft(uright)^topdW_u^nright\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"As a result, we find that we can specify our hybrid model state variable X_t^k and identify the model component functions Theta^kleft(cdotright), H^kleft(cdotright) and Sigma^kleft(cdotright) for a Gaussian model. We set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t^k=leftbeginarrayc\nx_t\nz_t\nendarrayright=leftbeginarrayc\nx_t^1\nvdots\nx_t^d\nz_t\nendarrayright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nTheta^kleft(stright)  =leftbeginarrayc\nHleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigmaleft(uright)^topleftsigmaleft(uright)Gleft(utright)-alpha_urightdu\nint_s^tGleft(utright)^topleftyleft(uright)boldsymbol1-sigmaleft(uright)^topalpha_urightdu\nendarrayright\nH^kleft(stright)  =leftbeginarraycc\nHleft(stright)  0\nGleft(stright)^top  1\nendarrayright\nSigmaleft(uright)^top  =leftbeginarrayc\nHleft(utright)sigmaleft(uright)^top\nGleft(utright)^topsigmaleft(uright)^top\nendarrayright\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We note, that the drift function Theta^k is only state-independent if the quanto drift alpha_t is state-independent. This property is closely linked to the volatility assumptions of the foreign exchange model between rates model's currency and the hybrid model numeraire currency.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Alternative drift formula.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=Hleft(stright)leftx_s+int_s^tHleft(suright)^-1lefty_uboldsymbol1du+sigma_u^topleftdW_u^n-alpha_udurightrightright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t  =int_s^tHleft(utright)leftyleft(uright)boldsymbol1-sigmaleft(uright)^topalpha_urightdt+\n  quad Hleft(stright)x_s+\n  quadint_s^tHleft(utright)sigmaleft(uright)^topdW_u^n\nendaligned","category":"page"},{"location":"pages/simulation_framework/#Tradeable-Asset-Models","page":"Simulation Framework","title":"Tradeable Asset Models","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this subsection we specify our component models for tradeable assets. Such assets are typically foreign exchange rates, equities, equity indices and inflation indices. We use the notation of foreign exchange rates models with domestic and foreign currency. An adaption to equity and inflation models is then straight forward.","category":"page"},{"location":"pages/simulation_framework/#Hybrid-FX-Modelling-Framework","page":"Simulation Framework","title":"Hybrid FX Modelling Framework","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We consider the positive price process left(S_tright)_t of one unit of foreign currency measured by units of domestic currency. Moreover, denote left(B_t^dright)_t and left(B_t^fright)_t the bank account processes in domestic and foreign currency. The process left(S_tB_t^fright)_t represents the price process of the foreign currency bank account measured in units of domestic currency. This is a tradeable asset in domestic currency. The domestic currency risk-neutral measure uses the bank account left(B_t^dright)_t as numeraire. As a consequence, the process","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"left(fracS_tB_t^fB_t^dright)_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"must be a martingale.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The martingale property motivates the asset price process","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"S_t=fracB_t^dB_t^fe^x_t","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"for a normalised state variable process left(x_tright)_t. For the state variable we assume the dynamics","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t=-frac12int_0^tsigma_s^2ds+int_0^tsigma_sdW_s","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, left(sigma_tright)_t is a scalar volatility process adapted to cal F_t, and left(W_tright)_t is a scalar Brownian motion in the domestic currency risk-neutral measure.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Note that above specification of the process left(x_tright)_t covers a wide range of models. The models are distinguished by the modelling of the volatility process left(sigma_tright)_t. The representation S_t=left(B_t^dB_t^fright)e^x_t allows for a clear decoupling of interest rate modelling and hybrid asset modelling. For the sake of clarity we can also write the dynamics of left(S_tright)_t explicitely as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"S_t=S_s+int_s^tS_uleft(r_u^d-r_u^fright)du+int_s^tsigma_udW_u","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with domestic and foreign short rates r_u^d and r_u^f.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"There is an important consequence from the asset price representation S_t=left(B_t^dB_t^fright)e^x_t . In order to reconstruct future asset prices S_t the asset model must know its corresponding domestic and foreign interest rate model. Moreover, the asset model also requires the integrated state variables z_t^d and z_t^f in order to allow for the domestic and foreign interest rate model to calculate B_t^d and B_t^f.","category":"page"},{"location":"pages/simulation_framework/#Quanto-Adjustment","page":"Simulation Framework","title":"Quanto Adjustment","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"So far, we implicitly assumed that interest rate models are formulated in the risk-neutral measure of their respective currency. Similarly, we also assumed that asset models are formulated in their respective domestic currency risk neutral measure.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In a hybrid modelling framework for various currencies we need to decide on a common numeraire currency, the corresponding numeraire price process and the common martingale measure. Such a common martingale measure in general does not coincide with the risk-neutral measures that are typically used to formulate foreign currency component models. Consequently, we need to incorporate a change of measure for such foreign currency component models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this section, we formulate the change of measure from a given risk neutral measure to a common numeraire currency risk neutral measure. The change of measure is formulated in a rather general way in order to apply it later on for various component models. We consider a domestic currency with some asset price process X_t^d. For practical purposes, such an asset is typically","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"a domestic zero coupon bond with price process   left(P^dleft(tTright)right)_t or\nforeign currency bank account measured in units of domestic currency   with price process left(S_t^f-dB_t^fright)_t.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The corresponding domestic currency discounted asset process is denoted left(tildeX_t^dright)_t with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"tildeX_t^d=fracX_t^dB_t^d","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Without loss of generality, we assume that the discounted asset price process follows the dynamics","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"fracdtildeX_t^dtildeX_t^d=leftsigma_t^X^dright^topdW_t^d","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"where left(sigma_t^X^dright)_t is an adapted process and left(W_t^dright)_t is a n^d-dimensional Brownian motion in domestic currency risk neutral measure mathbbQ^d.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In addition to the domestic (and foreign) currency we consider a numeraire currency with bank account prices B_t^n. The price of one unit domestic currency measured by units of numeraire currency is denoted as S_t^d-n. The price of our domestic currency asset measured in units of numeraire currency is S_t^d-nX_t^d. Under the numeraire currency risk-neutral measure mathbbQ^n with numeraire price process left(B_t^nright)_t we can also formulate the discounted price process left(M_tright)_t with M_t=fracS_t^d-nP^dleft(tTright)B_t^n No-arbitrage arguments require that left(M_tright)_t is a mathbbQ^n-martingale.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Using our hybrid FX modelling framework we can write M_t as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"M_t=fracB_t^nB_t^de^x_t^d-nfracX_t^dB_t^n=fracX_t^dB_t^de^x_t^d-n=tildeX_t^de^x_t^d-n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with domestic numeraire FX model state variable process left(x_t^d-nright)_t. In order to further simplify notation, we set Y_t^d-n=e^x_t^d-n and note that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nY_t^d-n  =Y_0^d-n+int_0^tY_s^d-ndx_s^d-n+frac12int_0^tY_s^d-ndleftlangle x_s^d-nx_s^d-nrightrangle \n  =Y_0^d-n+int_0^tY_s^d-nsigma_s^d-ndW_s^d-n\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this representation, left(sigma_t^d-nright)_t is the FX volatility process of left(S_t^d-nright)_t and left(W_t^d-nright)_t is a Brownian motion in numeraire currency risk neutral measure. Above calculation also demonstrates that left(Y_t^d-nright)_t is a mathbbQ^n-martingale driven by an Ito integral.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Now, Ito product rule yields for the process left(M_tright)_t that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"M_t=M_0+int_0^ttildeX_s^ddY_s^d-n+int_0^tY_s^d-ndtildeX_s^d+int_0^tdleftlangle tildeX_s^dY_s^d-nrightrangle ","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The first Ito integral is","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_1=int_0^ttildeX_s^ddY_s^d-n=int_0^tM_ssigma_s^d-ndW_s^d-n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This term is a mathbbQ^n-martingale. For the second integral we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_2=int_0^tY_s^d-ndtildeX_s^d=int_0^tM_sleftsigma_s^X^dright^topdW_s^d","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This term is a mathbbQ^d-martingale because by construction left(W_t^dright)_t is a Brownian motion in the domestic currency risk neutral measure. for the third integral we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_3=int_0^tdleftlangle tildeX_s^dY_s^d-nrightrangle =int_0^tleftlangle dtildeX_s^ddY_s^d-nrightrangle =int_0^tM_sleftlangle leftsigma_s^X^dright^topdW_s^dsigma_s^d-ndW_s^d-nrightrangle ","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Girsanov's theorem yields that there is an adapted process left(alpha_tright)_t such that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^dn=W_t^d+int_0^talpha_sds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"is a Brownian motion under mathbbQ^n. This yields","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_2=int_0^tM_sleftsigma_t^X^dright^topleft(dW_s^dn-alpha_sdsright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For the third integral, we can now use linearity of covariance process and the property, that the quadratic variation of int_0^talpha_sds vanishes. This gives","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nI_3  =int_0^tM_sleftlangle leftsigma_s^X^dright^topleft(dW_s^dn-alpha_sdsright)sigma_s^d-ndW_s^d-nrightrangle \n  =int_0^tM_sleftlangle leftsigma_s^X^dright^topdW_s^dnsigma_s^d-ndW_s^d-nrightrangle \nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The Brownian motion increments are correlated such that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"leftlangle dW_s^dndW_s^d-nrightrangle =Gamma^X^dS^d-ndt","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with instantaneous correlation matrix Gamma^X^dS^d-n of shape left(n^d1right). This leads to the representation","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_3=int_0^tM_sleftsigma_s^X^dright^topGamma^X^dS^d-nsigma_s^d-nds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Recall that left(M_tright)_t is a mathbbQ^n-martingale. This requires that","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"I_2+I_3=int_0^tM_sleftsigma_t^X^dright^topleft(dW_s^dn+leftGamma^X^dS^d-nsigma_s^d-n-alpha_srightdsright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"is a mathbbQ^n-martingale. This leads to the condition","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"alpha_t=Gamma^X^dS^d-nsigma_t^d-n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"and the change of measure formula","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^dn=W_t^d+int_0^tGamma^X^dS^d-nsigma_s^d-nds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Quanto adjustment for rates models.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For Gaussian rates models in a domestic currency we have","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Theta^kleft(stright)=leftbeginarrayc\nHleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigma^dleft(uright)^topleftsigma^dleft(uright)Gleft(utright)-alpha_urightdu\nint_s^tGleft(utright)^topleftyleft(uright)boldsymbol1-sigma^dleft(uright)^topalpha_urightdu\nendarrayright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Assets prices are zero coupon bonds, X_t^d=P^dleft(tTright) driven by the state variable x_t^d. Consequently, the quanto adjustment drift becomes","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"alpha_t=Gamma^x^dS^d-nsigma_t^d-n","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Here, Gamma^x^dS^d-n summarises the instantaneous correlations of the interest rate risk factors and the FX risk factor. Assuming FX volatility is deterministic with sigma_t^d-n=sigma^d-nleft(tright), we get","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Theta^kleft(stright)=leftbeginarrayc\nHleft(stright)yleft(sright)Gleft(stright)+int_s^tHleft(utright)sigma^dleft(uright)^topleftsigma^dleft(uright)Gleft(utright)-Gamma^x^dS^d-nsigma_t^d-nrightdu\nint_s^tGleft(utright)^topleftyleft(uright)boldsymbol1-sigma^dleft(uright)^topGamma^x^dS^d-nsigma_t^d-nrightdu\nendarrayright","category":"page"},{"location":"pages/simulation_framework/#Lognormal-Model","page":"Simulation Framework","title":"Lognormal Model","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We construct a basic asset model by assuming that the volatility process left(sigma_t^f-dright)_t is deterministic, i.e. sigma_t^f-d=sigma^f-dleft(tright). Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t^f-d=x_s^f-d-frac12int_s^tsigma^f-dleft(uright)^2du+int_s^tsigma^f-dleft(uright)dW_u^d","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"If the domestic currency differs from the numeraire currency then we need to incorporate quanto adjustment with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"W_t^dn=W_t^d+int_0^tGamma^S^f-dS^d-nsigma_s^d-nds","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This yields","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nx_t^f-d  =x_s^f-d-frac12int_s^tsigma^f-dleft(uright)^2du+int_s^tsigma^f-dleft(uright)leftdW_u^dn-Gamma^S^f-dS^d-nsigma_u^d-nduright\n  =x_s^f-d-frac12int_s^tsigma^f-dleft(uright)leftsigma^f-dleft(uright)+2Gamma^S^f-dS^d-nsigma_u^d-nrightdu+int_s^tsigma^f-dleft(uright)dW_u^dn\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this model setting the state variable process left(x_t^f-dright)_t has normal terminal distributions. Consequently, e^x_t is lognormal. If interest rates are modelled by (multi-factor) Gaussian models then B_t^d and B_t^f are also lognormal. As a result, we find that the asset price S_t is also lognormal.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In the lognormal model, our generic hybrid model state variable X_t^k and component functions Theta^kleft(cdotright), H^kleft(cdotright) and Sigma^kleft(cdotright) are easily identified. We set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nX_t^k  =leftx_tright\nTheta^kleft(stright)  =left-frac12int_s^tsigma^f-dleft(uright)leftsigma^f-dleft(uright)+2Gamma^S^f-dS^d-nsigma_u^d-nrightduright\nH^kleft(stright)  =left1right\nSigma^kleft(uright)^top  =leftsigma^f-dleft(uright)right\nendaligned","category":"page"},{"location":"pages/simulation_framework/#Future-Index/Price-Models","page":"Simulation Framework","title":"Future Index/Price Models","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"In this section we specify models for Future index curves or Future price curves. Such models are typical for commodity derivatives.","category":"page"},{"location":"pages/simulation_framework/#Markov-Model-Specification","page":"Simulation Framework","title":"Markov Model Specification","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"The model is specified following  Andersen 2008, eq. (10) - (12). We keep notation as close as possible to the HJM model specification used for interest rates.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We denote","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Fleft(tTright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"a Future index or future price curve. The Future price is denominated in units of domestic currency. A key proposition is that for tleq T the future price left(Fleft(tTright)right)_t is a martingale in the domestic currency risk-neutral measure. The martingale property and the theory of separable HJM models motivate the specification","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Fleft(tTright) = \nFleft(0Tright)exp\n  left \n    hleft(tTright)^top\n    left\n        x_t+frac12y_tleft(I-Hleft(tTright)right)boldsymbol1\n    right\nright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with d-dimensional state variable process left(x_tright)_t and dtimes d-dimensional auxiliary (variance) variable process left(y_tright)_t. State and auxiliary variable follow the dynamics","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\n  x_t =\n  Hleft(stright)\n  left\n    x_s+int_s^tHleft(suright)^-1\n    left\n        frac12\n        left(\n            y_uchileft(uright)-sigma_u^topsigma_u\n        right)\n        boldsymbol1du+sigma_u^topdW_u^d\n    right\n  right\n  y_t =\n  Hleft(stright)y_sHleft(stright)+\n  int_s^tHleft(utright)sigma_u^topsigma_uHleft(utright)du\n  endaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Quanto-adjustment.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"If the domestic currency differs from the numeraire currency then we need to incorporate the change of measure","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\n  W_t^dn\n  = W_t^d+int_0^talpha_sds\n  = W_t^d+int_0^tGamma^X^dS^d-nsigma_s^d-nds\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This yields the state variable representation with Quanto adjustment as","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"x_t =\nHleft(stright)\nleft\n  x_s + \n  int_s^tHleft(suright)^-1\n  left\n    frac12left(y_uchileft(uright)boldsymbol1 -\n    sigma_u^topleftsigma_uboldsymbol1-2alpha_urightright)du +\n    sigma_u^topdW_u^dn\n  right\nright","category":"page"},{"location":"pages/simulation_framework/#Multi-factor-Gaussian-Model-2","page":"Simulation Framework","title":"Multi-factor Gaussian Model","text":"","category":"section"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"A critical aspect is the specification of the volatility process left(sigma_tright)_t. For the Gaussian Future index model we re-use the methodology from the interest rate model. That is, we assume constant mean reversion parameters chi_1ldotschi_d and benchmark times delta_1ldotsdelta_d. Moreover, denote Gamma^F=leftGamma_ij^Fright the instantaneous correlations between Future prices Fleft(tt+delta_iright) and Fleft(tt+delta_jright).","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then we set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^top=H(t)H^F(t)^-1sigma_t^FleftD^F(t)right^top","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"with","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nH(t)H^F(t)^-1  =left(beginarrayccc\ne^-chi_1delta_1  ldots  e^-chi_ddelta_1\nvdots    vdots\ne^-chi_1delta_d  ldots  e^-chi_ddelta_d\nendarrayright)^-1\nleftD^F(t)right^topD^F(t)  =Gamma^F\nendaligned","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"This methodology reduces the modelling to the specification of a diagonal matrix of benchmark price volatilities","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"sigma_t^F=left(beginarrayccc\nsigma_t^F_1\n  ddots\n    sigma_t^F_d\nendarrayright)","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"For the Gaussian Future index model, we further assume piece-wise constant volatility functions sigma_t^F_i=sigma_ileft(tright). Then, also the model volatility sigma_t=sigmaleft(tright) is deterministic and piece-wise constant. With this specification the auxilliary variable process left(y_tright)_t is deterministic as well. And we can re-use the machinery from interest rate models to calculate y_t=yleft(tright).","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Hybrid model interface.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We specify the hybrid model state variable X_t^k and identify the model component functions Theta^kleft(cdotright), H^kleft(cdotright) and Sigma^kleft(cdotright) for a Gaussian Future price model.","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"We set","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"X_t^k=leftbeginarrayc\nx_t^1\nvdots\nx_t^d\nendarrayright","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"Then","category":"page"},{"location":"pages/simulation_framework/","page":"Simulation Framework","title":"Simulation Framework","text":"beginaligned\nTheta^kleft(stright)\n= frac12int_s^tHleft(utright)\n   left\n     left(\n        yleft(uright)chiboldsymbol1-\n        left\n            sigmaleft(uright)^topsigmaleft(uright)boldsymbol1 - \n            2sigmaleft(uright)^topalphaleft(uright)\n        right\n     right) du\n    right\nH^kleft(stright) = Hleft(stright)\nSigma^kleft(uright)^top\n= Hleft(utright)sigmaleft(uright)^top\nendaligned","category":"page"},{"location":"models/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"In this section we document models for various risk factors.","category":"page"},{"location":"models/models/#Data-Structures-and-Constructors","page":"Models","title":"Data Structures and Constructors","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.Model","category":"page"},{"location":"models/models/#DiffFusion.Model","page":"Models","title":"DiffFusion.Model","text":"abstract type Model end\n\nAn abstract base model type. This type covers component models and hybrid composite models.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.ComponentModel","category":"page"},{"location":"models/models/#DiffFusion.ComponentModel","page":"Models","title":"DiffFusion.ComponentModel","text":"abstract type ComponentModel <: Model end\n\nAn abstract component model type. This type implements the common interface of all component models.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.AssetModel","category":"page"},{"location":"models/models/#DiffFusion.AssetModel","page":"Models","title":"DiffFusion.AssetModel","text":"abstract type AssetModel <: ComponentModel end\n\nAn AssetModel aims at modelling spot prices of tradeable assets like FX, shares and indices.\n\nWe implement several additional functions to handle quanto adjustments.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.LognormalAssetModel","category":"page"},{"location":"models/models/#DiffFusion.LognormalAssetModel","page":"Models","title":"DiffFusion.LognormalAssetModel","text":"struct LognormalAssetModel <: AssetModel\n    alias::String\n    sigma_x::BackwardFlatVolatility\n    state_alias::AbstractVector\n    factor_alias::AbstractVector\n    correlation_holder::CorrelationHolder\n    quanto_model::Union{AssetModel, Nothing}\nend\n\nA LognormalAssetModel is a model for simulating a spot price in a generalised Black-Scholes framework.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.lognormal_asset_model","category":"page"},{"location":"models/models/#DiffFusion.lognormal_asset_model","page":"Models","title":"DiffFusion.lognormal_asset_model","text":"lognormal_asset_model(\n    alias::String,\n    sigma_x::BackwardFlatVolatility,\n    ch::CorrelationHolder,\n    quanto_model::Union{AssetModel, Nothing}\n    )\n\nCreate a LognormalAssetModel.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.SeparableHjmModel","category":"page"},{"location":"models/models/#DiffFusion.SeparableHjmModel","page":"Models","title":"DiffFusion.SeparableHjmModel","text":"abstract type SeparableHjmModel <: ComponentModel end\n\nAn abstract type for separable HJM models.\n\nThis type covers common functions for Gaussian and Quasi-Gaussian models.\n\nThe SeparableHjmModel is supposed to hold a constant vector-valued ParameterTermstructure for mean reversion chi and benchmark rate times delta.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.GaussianHjmModel","category":"page"},{"location":"models/models/#DiffFusion.GaussianHjmModel","page":"Models","title":"DiffFusion.GaussianHjmModel","text":"struct GaussianHjmModel <: SeparableHjmModel\n    alias::String\n    delta::ParameterTermstructure\n    chi::ParameterTermstructure\n    sigma_T::GaussianHjmModelVolatility\n    y::AbstractArray\n    state_alias::AbstractVector\n    factor_alias::AbstractVector\n    correlation_holder::Union{CorrelationHolder, Nothing}\n    quanto_model::Union{AssetModel, Nothing}\nend\n\nA Gaussian HJM model with piece-wise constant benchmark rate volatility and constant mean reversion.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.gaussian_hjm_model","category":"page"},{"location":"models/models/#DiffFusion.gaussian_hjm_model","page":"Models","title":"DiffFusion.gaussian_hjm_model","text":"gaussian_hjm_model(\n    alias::String,\n    delta::ParameterTermstructure,\n    chi::ParameterTermstructure,\n    sigma_f::BackwardFlatVolatility,\n    correlation_holder::Union{CorrelationHolder, Nothing},\n    quanto_model::Union{AssetModel, Nothing},\n    )\n\nCreate a Gausian HJM model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.MarkovFutureModel","category":"page"},{"location":"models/models/#DiffFusion.MarkovFutureModel","page":"Models","title":"DiffFusion.MarkovFutureModel","text":"struct MarkovFutureModel <: SeparableHjmModel\n    hjm_model::GaussianHjmModel\nend\n\nA Markov model for Future prices with piece-wise constant benchmark price volatility and constant mean reversion.\n\nWe implement an object adapter for the GaussianHjmModel to re-use implementation for common modelling parts.\n\nThe MarkovFutureModel differs from the GaussianHjmModel essentially only by the drift Theta.\n\nMoreover, we do not require the integrated state variable and want to identify correlations with Future prices instead of forward rates.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.markov_future_model","category":"page"},{"location":"models/models/#DiffFusion.markov_future_model","page":"Models","title":"DiffFusion.markov_future_model","text":"markov_future_model(\n    alias::String,\n    delta::ParameterTermstructure,\n    chi::ParameterTermstructure,\n    sigma_f::BackwardFlatVolatility,\n    correlation_holder::Union{CorrelationHolder, Nothing},\n    quanto_model::Union{AssetModel, Nothing},\n    )\n\nCreate a Gausian Markov model for Future prices.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.CompositeModel","category":"page"},{"location":"models/models/#DiffFusion.CompositeModel","page":"Models","title":"DiffFusion.CompositeModel","text":"abstract type CompositeModel <: Model\n\nA CompositeModel represents a collection of (coupled) component models.\n\nCompositeModels are supposed to hold the following elements\n\nalias::String\nmodels::Tuple\nstate_alias\nfactor_alias\nmodel_dict::Dict{String,Int}\n\nFor concrete types, see SimpleModel.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.SimpleModel","category":"page"},{"location":"models/models/#DiffFusion.SimpleModel","page":"Models","title":"DiffFusion.SimpleModel","text":"struct SimpleModel <: Model\n    alias::String\n    models::Tuple\n    state_alias\n    factor_alias\n    model_dict::Dict{String,Int}\nend\n\nA SimpleModel represents a collection of (coupled) state-independent component models.\n\nIt is supposed to be used with a simple_simulation() method.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.simple_model","category":"page"},{"location":"models/models/#DiffFusion.simple_model","page":"Models","title":"DiffFusion.simple_model","text":"simple_model(alias::String, models::AbstractVector)\n\nCreate a SimpleModel.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#State-Variable","page":"Models","title":"State Variable","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"A model allows to simulate a stochastic process left(X_tright). For a given t the vector X_t is represented by a ModelState. ","category":"page"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.ModelState","category":"page"},{"location":"models/models/#DiffFusion.ModelState","page":"Models","title":"DiffFusion.ModelState","text":"struct ModelState\n    X::AbstractMatrix\n    idx::Dict{String,Int}\nend\n\nA ModelState is a matrix of state variables decorated by a dictionary of alias strings and optional additional parameters.\n\nIt allows to decouple simulation of state variables and usage of state variables.\n\nX is of size (n, p) where n represents the number of state aliases and p represents the number of paths. A matrix with a large number of paths is typically used when calling model functions for payoff evaluation.\n\nA single realisation of risk factors is represented by an (n, 1) matrix. We use (n,1) matrix instead of (n,) vector to avoid size-dependent switches.\n\nidx is a dictionary with n entries. Keys represent state state alias entries and values represent the corresponding positions in X.\n\nparams is a struct or dictionary that holds additional pre-calculated state-independent data which is used in subsequent Theta and Sigma calculations. This aims at avoiding duplicate calculations for state-dependent Theta and Sigma calculations. The params is supposed to be calculated by method simulation_parameters(...).\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.model_state","category":"page"},{"location":"models/models/#DiffFusion.model_state","page":"Models","title":"DiffFusion.model_state","text":"model_state(X::AbstractMatrix, idx::Dict{String,Int})\n\nCreate a ModelState object and make sure it is consistent.\n\n\n\n\n\nmodel_state(X::AbstractMatrix, m::Model, params = nothing)\n\nCreate a model state for a given model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.alias_dictionary","category":"page"},{"location":"models/models/#DiffFusion.alias_dictionary","page":"Models","title":"DiffFusion.alias_dictionary","text":"alias_dictionary(alias_list)\n\nCreate an alias dictionary\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Auxilliary-Methods","page":"Models","title":"Auxilliary Methods","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.alias(m::DiffFusion.Model)","category":"page"},{"location":"models/models/#DiffFusion.alias-Tuple{DiffFusion.Model}","page":"Models","title":"DiffFusion.alias","text":"alias(m::Model)\n\nReturn the model's own alias. This is the default implementation.\n\n\n\n\n\n","category":"method"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.model_alias","category":"page"},{"location":"models/models/#DiffFusion.model_alias","page":"Models","title":"DiffFusion.model_alias","text":"model_alias(m::Model)\n\nReturn the aliases modelled by a model.\n\nTypically, this coincides with the model's own alias. For composite models this is a list of component model aliases.\n\n\n\n\n\nmodel_alias(m::CompositeModel)\n\nReturn the aliases modelled by a model.\n\nTypical this coincides with the model's own alias. For composite models this is a list of component model aliases.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_alias","category":"page"},{"location":"models/models/#DiffFusion.state_alias","page":"Models","title":"DiffFusion.state_alias","text":"state_alias(m::Model)\n\nReturn a list of state alias strings that represent the model components.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.factor_alias","category":"page"},{"location":"models/models/#DiffFusion.factor_alias","page":"Models","title":"DiffFusion.factor_alias","text":"factor_alias(m::Model)\n\nReturn a list of risk factor alias strings that represent the components of the multi-variate Brownian motion risk factors. \n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.parameter_grid","category":"page"},{"location":"models/models/#DiffFusion.parameter_grid","page":"Models","title":"DiffFusion.parameter_grid","text":"parameter_grid(m::Model)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(models::AbstractVector)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::LognormalAssetModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::CompositeModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::GaussianHjmModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\nparameter_grid(m::MarkovFutureModel)\n\nReturn a list of times representing the (joint) grid points of piece-wise constant model parameters.\n\nThis method is intended to be used in conjunction with time-integration mehods that require smooth integrand functions.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Model-Functions-for-Payoff-Evaluation","page":"Models","title":"Model Functions for Payoff Evaluation","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_asset","category":"page"},{"location":"models/models/#DiffFusion.log_asset","page":"Models","title":"DiffFusion.log_asset","text":"log_asset(m::Model, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_asset(m::LognormalAssetModel, model_alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\n\n\n\n\nlog_asset(m::CompositeModel, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the normalised state variable from an asset model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_bank_account","category":"page"},{"location":"models/models/#DiffFusion.log_bank_account","page":"Models","title":"DiffFusion.log_bank_account","text":"log_bank_account(m::Model, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the integral over sum of state variables s(t) from interest rate model.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_bank_account(m::CompositeModel, alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the integral over sum of state variables s(t) from interest rate model.\n\n\n\n\n\nlog_bank_account(m::GaussianHjmModel, model_alias::String, t::ModelTime, X::ModelState)\n\nRetrieve the integral over sum of state variables s(t) from interest rate model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_zero_bond","category":"page"},{"location":"models/models/#DiffFusion.log_zero_bond","page":"Models","title":"DiffFusion.log_zero_bond","text":"log_zero_bond(m::Model, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the zero bond term [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\nReturns a vector of size (p,) for X with size (n,p).\n\n\n\n\n\nlog_zero_bond(m::CompositeModel, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the zero bond term [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\n\n\n\n\nlog_zero_bond(m::GaussianHjmModel, model_alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the zero bond term [G(t,T)' x(t) + 0.5 G(t,T)' y(t) G(t,T)]' from rates model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_asset_convexity_adjustment","category":"page"},{"location":"models/models/#DiffFusion.log_asset_convexity_adjustment","page":"Models","title":"DiffFusion.log_asset_convexity_adjustment","text":"log_asset_convexity_adjustment(\n    m::Model,\n    dom_alias::String,\n    for_alias::String,\n    ast_alias::String,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    )\n\nCalculate the YoY convexity adjustment term for OU models.\n\nReturns a scalar quantity.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.log_future","category":"page"},{"location":"models/models/#DiffFusion.log_future","page":"Models","title":"DiffFusion.log_future","text":"log_future(m::Model, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the Future price term h(t,T)'[x(t) + 0.5y(t)(1 - h(t,T))].\n\n\n\n\n\nlog_future(m::CompositeModel, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the Future price term h(t,T)'[x(t) + 0.5y(t)(1 - h(t,T))].\n\n\n\n\n\nlog_future(m::MarkovFutureModel, alias::String, t::ModelTime, T::ModelTime, X::ModelState)\n\nCalculate the Future price term (h(t,T)'[x(t) + 0.5y(t)(1 - h(t,T))])'.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.forward_rate_variance","category":"page"},{"location":"models/models/#DiffFusion.forward_rate_variance","page":"Models","title":"DiffFusion.forward_rate_variance","text":"forward_rate_variance(\n    m::Model,\n    alias::String,\n    t::ModelTime,\n    T::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    )\n\nCalculate the lognormal model variance of a forward looking or backward looking forward rate.\n\n\n\n\n\nforward_rate_variance(\np::AbstractPath,\nt::ModelTime,\nT::ModelTime,\nT0::ModelTime,\nT1::ModelTime,\nkey::String,\n)\n\nCalculate the lognormal model variance of a forward looking or backward looking forward rate.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Model-Functions-for-Simulation","page":"Models","title":"Model Functions for Simulation","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.Theta","category":"page"},{"location":"models/models/#DiffFusion.Theta","page":"Models","title":"DiffFusion.Theta","text":"Theta(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t]. If Theta is state-dependent a state vector X must be supplied. The method returns a vector of length(state_alias).\n\n\n\n\n\nTheta(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t].\n\n\n\n\n\nTheta(\n    m::SimpleModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t].\n\n\n\n\n\nTheta(\n    m::GaussianHjmModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t]. If Theta is state-dependent a state vector X must be supplied. The method returns a vector of length(state_alias).\n\n\n\n\n\nTheta(\n    m::MarkovFutureModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the deterministic drift component for simulation over the time period [s, t]. If Theta is state-dependent a state vector X must be supplied. The method returns a vector of length(state_alias).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.H_T","category":"page"},{"location":"models/models/#DiffFusion.H_T","page":"Models","title":"DiffFusion.H_T","text":"H_T(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t]. If H is state-dependent a state vector X must be supplied. We use the transposed of H to\n\nallow for efficient sparse CSC matrix insertion and\nallow for efficient multiplication X' * H' = (H * X)'.\n\nThe state vector X may effectively be a subset of all states. To accommodate this, we use a dedicated list of state aliases state_alias_H for the result matrix. The method returns a (sparse) matrix of size (length(state_alias_H), length(state_alias)).\n\n\n\n\n\nH_T(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::SimpleModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::GaussianHjmModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\nH_T(\n    m::MarkovFutureModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn the transposed of the convection matrix H for simulation over the time period [s, t].\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.Sigma_T","category":"page"},{"location":"models/models/#DiffFusion.Sigma_T","page":"Models","title":"DiffFusion.Sigma_T","text":"Sigma_T(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\nThe state vector is required if Sigma(u) depends on X_s.\n\nThe result of an evaluation of Sigma_T(...)(u) is a matrix of size (length(state_alias), length(factor_alias_Sigma)).\n\nThe Brownian motion relevant for a model may effectively be a subset of all Brownian motions. To accommodate this, we use a dedicated list of factor aliases factor_alias_Sigma for the size of the result matrix of a function evaluation.\n\nThe transposed '_T' is convention to simplify notation for covariance calculation.\n\n\n\n\n\nSigma_T(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\n\n\n\n\nSigma_T(\n    m::SimpleModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\nThe signature of the resulting function is (u::ModelTime). Here, u represents the observation time.\n\n\n\n\n\nSigma_T(\n    m::GaussianHjmModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\n\n\n\n\nSigma_T(\n    m::MarkovFutureModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a matrix-valued function representing the volatility matrix function.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_dependent_Theta","category":"page"},{"location":"models/models/#DiffFusion.state_dependent_Theta","page":"Models","title":"DiffFusion.state_dependent_Theta","text":"state_dependent_Theta(m::Model)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::LognormalAssetModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::CompositeModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::GaussianHjmModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\nstate_dependent_Theta(m::MarkovFutureModel)\n\nReturn whether Theta requires a state vector input X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_dependent_H","category":"page"},{"location":"models/models/#DiffFusion.state_dependent_H","page":"Models","title":"DiffFusion.state_dependent_H","text":"state_dependent_H(m::Model)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::LognormalAssetModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::CompositeModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::GaussianHjmModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\nstate_dependent_H(m::MarkovFutureModel)\n\nReturn whether H requires a state vector input X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_dependent_Sigma","category":"page"},{"location":"models/models/#DiffFusion.state_dependent_Sigma","page":"Models","title":"DiffFusion.state_dependent_Sigma","text":"state_dependent_Sigma(m::Model)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::LognormalAssetModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::CompositeModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::GaussianHjmModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\nstate_dependent_Sigma(m::MarkovFutureModel)\n\nReturn whether Sigma requires a state vector input X.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.state_alias_H","category":"page"},{"location":"models/models/#DiffFusion.state_alias_H","page":"Models","title":"DiffFusion.state_alias_H","text":"state_alias_H(m::Model)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::LognormalAssetModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::CompositeModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::GaussianHjmModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\nstate_alias_H(m::MarkovFutureModel)\n\nReturn a list of state alias strings required for (H * X) calculation.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.factor_alias_Sigma","category":"page"},{"location":"models/models/#DiffFusion.factor_alias_Sigma","page":"Models","title":"DiffFusion.factor_alias_Sigma","text":"factor_alias_Sigma(m::Model)\n\nReturn a list of factor alias strings required for (Sigma(u)' Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::LognormalAssetModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::CompositeModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::GaussianHjmModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\nfactor_alias_Sigma(m::MarkovFutureModel)\n\nReturn a list of factor alias strings required for (Sigma(u)^T Gamma Sigma(u)) calculation.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.covariance","category":"page"},{"location":"models/models/#DiffFusion.covariance","page":"Models","title":"DiffFusion.covariance","text":"covariance(\n    m::Model,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nCalculate the covariance matrix over a time interval.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.volatility_and_correlation","category":"page"},{"location":"models/models/#DiffFusion.volatility_and_correlation","page":"Models","title":"DiffFusion.volatility_and_correlation","text":"volatility_and_correlation(\n    m::Model,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    vol_eps::ModelValue = 1.0e-8,  # avoid division by zero\n    )\n\nCalculate the volatility vector and correlation matrix over a time interval.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.simulation_parameters","category":"page"},{"location":"models/models/#DiffFusion.simulation_parameters","page":"Models","title":"DiffFusion.simulation_parameters","text":"simulation_parameters(\n    m::Model,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\n\n\n\n\nsimulation_parameters(\n    m::GaussianHjmModel,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\nFor LognormalAssetModel there are no valuations that should be cached.\n\n\n\n\n\nsimulation_parameters(\n    m::GaussianHjmModel,\n    ch::Union{CorrelationHolder, Nothing},\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nPre-calculate parameters that are used in state-dependent Theta and Sigma calculation.\n\nFor GaussianHjmModel there are no valuations that should be cached.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.diagonal_volatility","category":"page"},{"location":"models/models/#DiffFusion.diagonal_volatility","page":"Models","title":"DiffFusion.diagonal_volatility","text":"diagonal_volatility(\n    m::Model,\n    s::ModelTime,\n    t::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the path-dependent volatilities for a given model.\n\nX is supposed to hold a state matrix of size (n, p). Here, n is length(state_alias(m)) and p is the number of paths.\n\nThe method returns a matrix of size (n, p).\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Additional-Asset-Model-Functions","page":"Models","title":"Additional Asset Model Functions","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.asset_volatility","category":"page"},{"location":"models/models/#DiffFusion.asset_volatility","page":"Models","title":"DiffFusion.asset_volatility","text":"asset_volatility(\n    m::AssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a state-independent volatility function sigma(u) for the interval (s,t).\n\n\n\n\n\nasset_volatility(\n    m::LognormalAssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a state-independent volatility function sigma(u) for the interval (s,t).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.correlation_holder(m::DiffFusion.AssetModel)","category":"page"},{"location":"models/models/#DiffFusion.correlation_holder-Tuple{DiffFusion.AssetModel}","page":"Models","title":"DiffFusion.correlation_holder","text":"correlation_holder(m::AssetModel)\n\nReturn the correlation holder term structure.\n\n\n\n\n\n","category":"method"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.quanto_drift","category":"page"},{"location":"models/models/#DiffFusion.quanto_drift","page":"Models","title":"DiffFusion.quanto_drift","text":"quanto_drift(\n    dom_factor_alias::AbstractVector,\n    quanto_model::Nothing,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a zero quanto adjustment function alpha(u).\n\n\n\n\n\nquanto_drift(\n    dom_factor_alias::AbstractVector,\n    quanto_model::AssetModel,\n    s::ModelTime,\n    t::ModelTime,\n    X::Union{ModelState, Nothing} = nothing,\n    )\n\nReturn a function alpha(u) that allows to calculate the quanto adjustment on the time interval (s,t).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.asset_variance","category":"page"},{"location":"models/models/#DiffFusion.asset_variance","page":"Models","title":"DiffFusion.asset_variance","text":"asset_variance(\n    m::Model,\n    ast_alias::Union{String, Nothing},\n    dom_alias::Union{String, Nothing},\n    for_alias::Union{String, Nothing},\n    t::ModelTime,\n    T::ModelTime,\n    X::ModelState,\n    )\n\nCalculate the lognormal model variance of an asset spot price over the time period [t,T]. If Model is state-dependent then variance calculation takes into account model state X.\n\n\n\n\n\nasset_variance(\n    p::AbstractPath,\n    t::ModelTime,\n    T::ModelTime,\n    key::String,\n    )\n\nCalculate the lognormal model variance of an asset spot price over the time period [t,T].\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Additional-Rates-Model-Functions","page":"Models","title":"Additional Rates Model Functions","text":"","category":"section"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_y","category":"page"},{"location":"models/models/#DiffFusion.func_y","page":"Models","title":"DiffFusion.func_y","text":"func_y(\n    y0::AbstractMatrix,\n    chi::AbstractVector,\n    sigmaT::AbstractMatrix,\n    s::ModelTime,\n    t::ModelTime,\n    )\n\nCalculate variance/auxiliary state variable y(t) given y(s)=y_0.\n\nIn this function we assume that sigma is constant over the time interval (st).\n\n\n\n\n\nfunc_y(m::GaussianHjmModel, t::ModelTime)\n\nCalculate variance/auxiliary state variable y(t).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.chi_hjm","category":"page"},{"location":"models/models/#DiffFusion.chi_hjm","page":"Models","title":"DiffFusion.chi_hjm","text":"chi_hjm(m::SeparableHjmModel)\n\nReturn vector of constant mean reversion rates.\n\n\n\n\n\nchi_hjm(m::MarkovFutureModel)\n\nReturn vector of constant mean reversion rates.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.benchmark_times","category":"page"},{"location":"models/models/#DiffFusion.benchmark_times","page":"Models","title":"DiffFusion.benchmark_times","text":"benchmark_times(m::SeparableHjmModel)\n\nReturn vector of reference/benchmark times\n\n\n\n\n\nbenchmark_times(m::MarkovFutureModel)\n\nReturn vector of reference/benchmark times\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.H_hjm","category":"page"},{"location":"models/models/#DiffFusion.H_hjm","page":"Models","title":"DiffFusion.H_hjm","text":"H_hjm(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nDiagonal entries of H(st).\n\n\n\n\n\nH_hjm(m::SeparableHjmModel, s::ModelTime, t::ModelTime)\n\nDiagonal entries of H(st).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.G_hjm","category":"page"},{"location":"models/models/#DiffFusion.G_hjm","page":"Models","title":"DiffFusion.G_hjm","text":"G_hjm(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nVector function G(st).\n\n\n\n\n\nG_hjm(m::SeparableHjmModel, s::ModelTime, t::ModelTime)\n\nVector function G(st).\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.benchmark_times_scaling","category":"page"},{"location":"models/models/#DiffFusion.benchmark_times_scaling","page":"Models","title":"DiffFusion.benchmark_times_scaling","text":"benchmark_times_scaling(chi::AbstractVector, delta::AbstractVector)\n\nBenchmark times volatility scaling matrix H H^f^-1 = H^f H^-1^-1.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Theta_x","category":"page"},{"location":"models/models/#DiffFusion.func_Theta_x","page":"Models","title":"DiffFusion.func_Theta_x","text":"func_Theta_x(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for state variable x.\n\nIn this function we assume for the interval (st) that     - variance y(s) is known,     - volatility σ is state-independent and     - quanto adjustment alpha is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Theta_x_integrate_y","category":"page"},{"location":"models/models/#DiffFusion.func_Theta_x_integrate_y","page":"Models","title":"DiffFusion.func_Theta_x_integrate_y","text":"func_Theta_x_integrate_y(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for state variable x.\n\nAvoidance of explicit σ^top σ dependence may help with integrating over jumps in piece-wise constant volatility. \n\nIn this function we assume for the interval (st) that     - variance y is state-independent,     - volatility σ is state-independent and     - quanto adjustment α is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Theta_s","category":"page"},{"location":"models/models/#DiffFusion.func_Theta_s","page":"Models","title":"DiffFusion.func_Theta_s","text":"func_Theta_s(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for integrated state variable s.\n\nIn this function we assume for the interval (st) that     - variance y state-independent,     - volatility σ is state-independent and     - quanto adjustment α is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Theta","category":"page"},{"location":"models/models/#DiffFusion.func_Theta","page":"Models","title":"DiffFusion.func_Theta","text":"func_Theta(\n    chi::AbstractVector,\n    y::Function,       # (u) -> Matrix\n    sigmaT::Function,  # (u) -> Matrix\n    alpha::Function,   # (u) -> Vector\n    s::ModelTime,\n    t::ModelTime,\n    param_grid::Union{AbstractVector, Nothing},\n    )\n\nCalculate Theta function for component model state variable X.\n\nIn this function we assume for the interval (st) that     - variance y state-independent,     - volatility σ is state-independent and     - quanto adjustment α is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_H_T","category":"page"},{"location":"models/models/#DiffFusion.func_H_T","page":"Models","title":"DiffFusion.func_H_T","text":"func_H_T(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nCalculate H function for component model.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_H_T_dense","category":"page"},{"location":"models/models/#DiffFusion.func_H_T_dense","page":"Models","title":"DiffFusion.func_H_T_dense","text":"func_H_T_dense(chi::AbstractVector, s::ModelTime, t::ModelTime)\n\nAlternative H function implementation for debugging.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.func_Sigma_T","category":"page"},{"location":"models/models/#DiffFusion.func_Sigma_T","page":"Models","title":"DiffFusion.func_Sigma_T","text":"func_Sigma_T(\n    chi::AbstractVector,\n    sigmaT::Function,\n    s::ModelTime,\n    t::ModelTime\n    )\n\nCalculate Σ(u)^top function for component model.\n\nIn this function we assume for the interval (st) that     - volatility σ is state-independent.\n\n\n\n\n\n","category":"function"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.GaussianHjmModelVolatility","category":"page"},{"location":"models/models/#DiffFusion.GaussianHjmModelVolatility","page":"Models","title":"DiffFusion.GaussianHjmModelVolatility","text":"struct GaussianHjmModelVolatility\n    HHfInv::AbstractMatrix\n    sigma_f::BackwardFlatVolatility\n    DfT::AbstractMatrix\nend\n\nA dedicated matrix-valued volatility term structure for Gaussian HJM Models.\n\n\n\n\n\n","category":"type"},{"location":"models/models/","page":"Models","title":"Models","text":"DiffFusion.swap_rate_variance","category":"page"},{"location":"models/models/#DiffFusion.swap_rate_variance","page":"Models","title":"DiffFusion.swap_rate_variance","text":"swap_rate_variance(\n    m::Model,\n    alias::String,\n    yts::YieldTermstructure,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    X::ModelState,\n    )\n\nCalculate the normal model variance of a swap rate via Gaussian swap rate approximation.\n\n\n\n\n\nswap_rate_variance(\n    p::AbstractPath,\n    t::ModelTime,\n    T::ModelTime,\n    swap_times::AbstractVector,\n    yf_weights::AbstractVector,\n    key::String,\n    )\n\nCalculate the normal model variance of a swap rate via Gaussian swap rate approximation.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"In this section we document data and functions to work with the product and model examples.","category":"page"},{"location":"examples/examples/#Product-Setup","page":"Examples","title":"Product Setup","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"DiffFusion.Examples.fixed_rate_leg","category":"page"},{"location":"examples/examples/#DiffFusion.Examples.fixed_rate_leg","page":"Examples","title":"DiffFusion.Examples.fixed_rate_leg","text":"fixed_rate_leg(\n    alias::String,\n    effective_time::ModelTime,\n    maturity_time::ModelTime,\n    coupons_per_year::Int,\n    fixed_rate::ModelValue,\n    notional::ModelValue,\n    discount_curve_key::String,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a fixed rate cash flow leg.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"DiffFusion.Examples.simple_rate_leg","category":"page"},{"location":"examples/examples/#DiffFusion.Examples.simple_rate_leg","page":"Examples","title":"DiffFusion.Examples.simple_rate_leg","text":"simple_rate_leg(\n    alias::String,\n    effective_time::ModelTime,\n    maturity_time::ModelTime,\n    coupons_per_year::Int,\n    forward_curve_key::String,\n    fixing_key::Union{String, Nothing},\n    spread_rate::Union{ModelValue, Nothing},\n    notional::ModelValue,\n    discount_curve_key::String,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a Libor cash flow leg.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"DiffFusion.Examples.compounded_rate_leg","category":"page"},{"location":"examples/examples/#DiffFusion.Examples.compounded_rate_leg","page":"Examples","title":"DiffFusion.Examples.compounded_rate_leg","text":"compounded_rate_leg(\n    alias::String,\n    effective_time::ModelTime,\n    maturity_time::ModelTime,\n    coupons_per_year::Int,\n    forward_curve_key::String,\n    fixing_key::Union{String, Nothing},\n    spread_rate::Union{ModelValue, Nothing},\n    notional::ModelValue,\n    discount_curve_key::String,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a RFR compounded leg.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"DiffFusion.Examples.random_swap","category":"page"},{"location":"examples/examples/#DiffFusion.Examples.random_swap","page":"Examples","title":"DiffFusion.Examples.random_swap","text":"random_swap(example::OrderedDict{String,Any}, type_key::Union{String,Nothing} = nothing)\n\nSample a random swap.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"DiffFusion.Examples.portfolio!","category":"page"},{"location":"examples/examples/#DiffFusion.Examples.portfolio!","page":"Examples","title":"DiffFusion.Examples.portfolio!","text":"portfolio!(example::OrderedDict{String,Any}, n_swaps::Int = 10)\n\nCreate a portfolio of swaps and store it in the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"DiffFusion.Examples.display_portfolio","category":"page"},{"location":"examples/examples/#DiffFusion.Examples.display_portfolio","page":"Examples","title":"DiffFusion.Examples.display_portfolio","text":"Print portfolio in terminal.\n\n\n\n\n\n","category":"function"},{"location":"payoffs/payoffs/#Payoffs","page":"Payoffs","title":"Payoffs","text":"","category":"section"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"In this section we document the payoff scripting framework.","category":"page"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Payoff","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Payoff","page":"Payoffs","title":"DiffFusion.Payoff","text":"abstract type Payoff end\n\nA Payoff is a random variable X in our stochastic model.\n\nIt represents a market object that can be evaluated in conjunction with a given path.\n\nWe are interested in realisations of a payoff at a given path, i.e. X(omega). Moreover, for risk-neutral valuation we are also interested in discounted payoffs at a given path.\n\nWe implement a Payoff as a root of a computational graph. The nodes of the computational graph are itself Payoff objects which represent mathematical operations or use the path omega to determine its realisations.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.obs_time(p::DiffFusion.Payoff)","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.obs_time-Tuple{DiffFusion.Payoff}","page":"Payoffs","title":"DiffFusion.obs_time","text":"obs_time(p::Payoff)\n\nA Payoff is typically observed at a particular time. In that sense, a Payoff is an F_t-measurable random variable.\n\nThe observation time represents the time, after which the payoff is known.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.obs_times(p::DiffFusion.Payoff)","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.obs_times-Tuple{DiffFusion.Payoff}","page":"Payoffs","title":"DiffFusion.obs_times","text":"obs_times(p::Payoff)\n\nA payoff is typically linked to other payoffs and forms a DAG. This function returns all observation times associated with a given payoff.\n\nThis functionality is required to determine relevant simulation grid points.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.at(p::DiffFusion.Payoff, path::DiffFusion.AbstractPath)","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.at-Tuple{DiffFusion.Payoff, DiffFusion.AbstractPath}","page":"Payoffs","title":"DiffFusion.at","text":"at(p::Payoff, path::AbstractPath)\n\nEvaluate a Payoff at a given path, X(omega).\n\nDepending on the functionality associated with the path, this function typically returns a vector of realisations.\n\nThis function is invoked when using call operator on a Payoff,\n\n(p::Payoff)(path::AbstractPath) = at(p::Payoff, path::AbstractPath)\n\n\n\n\n\n","category":"method"},{"location":"payoffs/payoffs/#Leafs","page":"Payoffs","title":"Leafs","text":"","category":"section"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Leaf","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Leaf","page":"Payoffs","title":"DiffFusion.Leaf","text":"abstract type Leaf <: Payoff end\n\nA Leaf is a particular Payoff which has no outgoing links to other Payoff objects. A Leaf typically uses the path to determine its realisations.\n\nWe assume that a Leaf has a field obs_time.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Numeraire","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Numeraire","page":"Payoffs","title":"DiffFusion.Numeraire","text":"struct Numeraire <: Leaf\n    obs_time::ModelTime\n    curve_key::String\nend\n\nThe price of our numeraire asset price N(t) at observation time t.\n\nTypically, this coincides with the bank account price in numeraire (i.e. domestic) currency.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.BankAccount","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.BankAccount","page":"Payoffs","title":"DiffFusion.BankAccount","text":"struct BankAccount <: Leaf\n    obs_time::ModelTime\n    key::String\nend\n\nThe price of a continuous compounded bank account B(t) at observation time t and with unit notional at inception.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.ZeroBond","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.ZeroBond","page":"Payoffs","title":"DiffFusion.ZeroBond","text":"struct ZeroBond <: Leaf\n    obs_time::ModelTime\n    maturity_time::ModelTime\n    key::String\nend\n\nThe price of a zero coupon bond P(t,T) with observation time t and bond maturity time T.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Asset","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Asset","page":"Payoffs","title":"DiffFusion.Asset","text":"struct Asset <: Leaf\n    obs_time::ModelTime\n    key::String\nend\n\nThe price of a tradeable asset S(t) at observation time t.\n\nA tradeable asset is typically an FX rate, equity/index price or spot inflation index.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.ForwardAsset","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.ForwardAsset","page":"Payoffs","title":"DiffFusion.ForwardAsset","text":"struct ForwardAsset <: Leaf\n    obs_time::ModelTime\n    maturity_time::ModelTime\n    key::String\nend\n\nThe forward price E_t[S(T)] of a tradeable asset S at observation time t and with maturity time T. Expectation is calculated in T-forward measure.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Fixing","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Fixing","page":"Payoffs","title":"DiffFusion.Fixing","text":"struct Fixing <: Leaf\n    obs_time::ModelTime\n    key::String\nend\n\nThe value of an index fixing Idx(t) at observation time t.\n\nThe value is obtained from a term structure linked to the path.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Fixed","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Fixed","page":"Payoffs","title":"DiffFusion.Fixed","text":"struct Fixed <: Leaf\n    value::ModelValue\nend\n\nA deterministic quantity.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#Unary-Nodes","page":"Payoffs","title":"Unary Nodes","text":"","category":"section"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.UnaryNode","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.UnaryNode","page":"Payoffs","title":"DiffFusion.UnaryNode","text":"abstract type UnaryNode <: Payoff end\n\nA UnaryNode is a particular Payoff which has exactly one outgoing link to another Payoff object.\n\nWe assume that the reference to the outgoing Payoff object is a field denoted x.\n\nA UnaryNode is typically a decorator of the linked Payoff.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Pay","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Pay","page":"Payoffs","title":"DiffFusion.Pay","text":"struct Pay <: UnaryNode\n    x::Payoff\n    obs_time::ModelTime\n    test_times::Bool\nend\n\nA Pay payoff allows the user to modify the observation time of a given payoff. This is relevant for discounting.\n\nTypically, we use Pay to specify the pay time for a payoff.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Cache","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Cache","page":"Payoffs","title":"DiffFusion.Cache","text":"mutable struct Cache <: UnaryNode\n    x::Payoff\n    path::Union{AbstractPath, Nothing}\n    value::Union{AbstractVector, Nothing}\nend\n\nA Cache payoff aims at avoiding repeated calculations of the same payoff.\n\nIf a Payoff object is referenced by several parent Payoff objects then each call of at() of the parent object triggers a call of at() of the child object that all return the same value(s).\n\nA Cache payoff checks whether the payoff was already evaluated and if yes then returns a cached value.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#Binary-Nodes","page":"Payoffs","title":"Binary Nodes","text":"","category":"section"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.BinaryNode","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.BinaryNode","page":"Payoffs","title":"DiffFusion.BinaryNode","text":"abstract type BinaryNode <: Payoff end\n\nA BinaryNode is a particular Payoff which has exactly two outgoing links to other Payoff objects.\n\nWe assume that the references to the outgoing Payoff objects are fields denoted x and y.\n\nA BinaryNode is typically a mathematical operation.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Add","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Add","page":"Payoffs","title":"DiffFusion.Add","text":"struct Add <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nAddition of payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Sub","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Sub","page":"Payoffs","title":"DiffFusion.Sub","text":"struct Sub <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nSubtraction of payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Mul","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Mul","page":"Payoffs","title":"DiffFusion.Mul","text":"struct Mul <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nMultiplication of payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Div","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Div","page":"Payoffs","title":"DiffFusion.Div","text":"struct Div <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nDivision of payoffs.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Max","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Max","page":"Payoffs","title":"DiffFusion.Max","text":"struct Max <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nPath-wise maximum\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Min","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Min","page":"Payoffs","title":"DiffFusion.Min","text":"struct Min <: BinaryNode\n    x::Payoff\n    y::Payoff\nend\n\nPath-wise minimum\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.Logical","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.Logical","page":"Payoffs","title":"DiffFusion.Logical","text":"struct Logical <: BinaryNode\n    x::Payoff\n    y::Payoff\n    op::String\nend\n\nLogical operations\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/#Rates-Payoffs","page":"Payoffs","title":"Rates Payoffs","text":"","category":"section"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.LiborRate","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.LiborRate","page":"Payoffs","title":"DiffFusion.LiborRate","text":"struct LiborRate <: Leaf\n    obs_time::ModelTime\n    start_time::ModelTime\n    end_time::ModelTime\n    year_fraction::ModelValue\n    key::String\nend\n\nA simple compounded forward Libor rate.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.LiborRate(\n    obs_time::ModelTime,\n    start_time::ModelTime,\n    end_time::ModelTime,\n    key::String,\n    )","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.LiborRate-Tuple{Number, Number, Number, String}","page":"Payoffs","title":"DiffFusion.LiborRate","text":"LiborRate(\n   obs_time::ModelTime,\n   start_time::ModelTime,\n   end_time::ModelTime,\n   key::String,\n   )\n\nA simple compounded forward Libor rate with year fraction from model time.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.CompoundedRate","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.CompoundedRate","page":"Payoffs","title":"DiffFusion.CompoundedRate","text":"struct CompoundedRate <: Payoff\n    obs_time::ModelTime\n    start_time::ModelTime\n    end_time::ModelTime\n    year_fraction::ModelValue\n    fixed_compounding::Union{Payoff, Nothing}\n    key::String\n    fixed_type::DataType  # distinguish from constructors\nend\n\nA continuously compounded backward looking rate.\n\nThis is a proxy for daily compounded RFR coupon rates.\n\nFor obstime less starttime it is equivalent to a Libor rate.\n\n\n\n\n\n","category":"type"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.CompoundedRate(\n    obs_time::ModelTime,\n    start_time::ModelTime,\n    end_time::ModelTime,\n    key::String,\n    )","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.CompoundedRate-Tuple{Number, Number, Number, String}","page":"Payoffs","title":"DiffFusion.CompoundedRate","text":"CompoundedRate(\n    obs_time::ModelTime,\n    start_time::ModelTime,\n    end_time::ModelTime,\n    key::String,\n    fixed_compounding::Union{Payoff, Nothing} = nothing,\n    )\n\nA continuously compounded backward looking rate with year fraction from model time.\n\n\n\n\n\n","category":"method"},{"location":"payoffs/payoffs/#Common-Methods-Overview","page":"Payoffs","title":"Common Methods Overview","text":"","category":"section"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.obs_time","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.obs_time","page":"Payoffs","title":"DiffFusion.obs_time","text":"obs_time(p::Payoff)\n\nA Payoff is typically observed at a particular time. In that sense, a Payoff is an F_t-measurable random variable.\n\nThe observation time represents the time, after which the payoff is known.\n\n\n\n\n\nobs_time(p::Leaf)\n\nReturn the observation time for a Leaf object.\n\n\n\n\n\nobs_time(p::UnaryNode)\n\nReturn the observation time of the linked payoff.\n\n\n\n\n\nobs_time(p::BinaryNode)\n\nDerive the observation time from linked payoffs.\n\n\n\n\n\nobs_time(p::Fixed)\n\nObservation time for Fixed payoffs is zero because they are deterministic.\n\n\n\n\n\nobs_time(p::Pay)\n\nReturn decorating observation time.\n\n\n\n\n\nobs_time(p::CompoundedRate)\n\nCalculate observation time for CompoundedRate payoff.\n\n\n\n\n\nobs_time(p::AmcPayoff)\n\nReturn the AMC payoff observation time\n\n\n\n\n\n","category":"function"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.obs_times","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.obs_times","page":"Payoffs","title":"DiffFusion.obs_times","text":"obs_times(p::Payoff)\n\nA payoff is typically linked to other payoffs and forms a DAG. This function returns all observation times associated with a given payoff.\n\nThis functionality is required to determine relevant simulation grid points.\n\n\n\n\n\nobs_times(p::Leaf)\n\nDerive the set of observation times from the single observation time of the Leaf object.\n\n\n\n\n\nobs_times(p::UnaryNode)\n\nReturn all observation times of the linked payoff.\n\n\n\n\n\nobs_times(p::BinaryNode)\n\nDerive all observation times from linked payoff.\n\n\n\n\n\nobs_times(p::Pay)\n\nReturn all observation times of the linked payoff.\n\n\n\n\n\nobs_times(p::CompoundedRate)\n\nCalculate all observation times (i.e. event times) for CompoundedRate payoff.\n\n\n\n\n\nobs_times(p::AmcPayoff)\n\nReturn observation times of all referenced payoffs.\n\n\n\n\n\n","category":"function"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.at","category":"page"},{"location":"payoffs/payoffs/#DiffFusion.at","page":"Payoffs","title":"DiffFusion.at","text":"at(p::Payoff, path::AbstractPath)\n\nEvaluate a Payoff at a given path, X(omega).\n\nDepending on the functionality associated with the path, this function typically returns a vector of realisations.\n\nThis function is invoked when using call operator on a Payoff,\n\n(p::Payoff)(path::AbstractPath) = at(p::Payoff, path::AbstractPath)\n\n\n\n\n\nat(p::Numeraire, path::AbstractPath)\n\nDerive the numeraire price at a given path.\n\n\n\n\n\nat(p::BankAccount, path::AbstractPath)\n\nDerive the bank account price at a given path.\n\n\n\n\n\nat(p::ZeroBond, path::AbstractPath)\n\nDerive the zero bond price at a given path.\n\n\n\n\n\nat(p::Asset, path::AbstractPath)\n\nDerive the asset price at a given path.\n\n\n\n\n\nat(p::ForwardAsset, path::AbstractPath)\n\nDerive the asset price at a given path.\n\n\n\n\n\nat(p::Fixing, path::AbstractPath)\n\nDerive the fixing value at a given path.\n\n\n\n\n\nat(p::Fixed, path::AbstractPath)\n\nReturn the deterministic value broadcasted to the length of the path.\n\n\n\n\n\nat(p::Pay, path::AbstractPath)\n\nDerive payoff of the child payoff.\n\n\n\n\n\nat(p::Cache, path::AbstractPath)\n\nDerive payoff of the child payoff only if not yet calculated.\n\n\n\n\n\nAddition.\n\n\n\n\n\nSubtraction.\n\n\n\n\n\nMultiplication.\n\n\n\n\n\nDivision.\n\n\n\n\n\nMaximum\n\n\n\n\n\nMinimum\n\n\n\n\n\nLogical\n\n\n\n\n\nat(p::LiborRate, path::AbstractPath)\n\nDerive the forward Libor rate at a given path.\n\n\n\n\n\nat(p::CompoundedRate, path::AbstractPath)\n\nDerive the compounded backward looking rate at a given path.\n\n\n\n\n\nat(links::AmcPayoffLinks, regr::AmcPayoffRegression, path::AbstractPath)\n\nCalculate the common components of AMC payoffs for a given valuation path.\n\n\n\n\n\nat(p::AmcMax, path::AbstractPath)\n\nEvaluate an AmcMax payoff at a given path.\n\n\n\n\n\nat(p::AmcMin, path::AbstractPath)\n\nEvaluate an AmcMin payoff at a given path.\n\n\n\n\n\nat(p::AmcOne, path::AbstractPath)\n\nEvaluate an AmcOne payoff at a given path.\n\n\n\n\n\nat(p::AmcSum, path::AbstractPath)\n\nEvaluate an AmcSum payoff at a given path.\n\n\n\n\n\n","category":"function"},{"location":"payoffs/payoffs/","page":"Payoffs","title":"Payoffs","text":"DiffFusion.string","category":"page"},{"location":"payoffs/payoffs/#Base.string","page":"Payoffs","title":"Base.string","text":"string(p::Numeraire)\n\nFormatted (and shortened) output for Numeraire payoff.\n\n\n\n\n\nstring(p::BankAccount)\n\nFormatted (and shortened) output for BankAccount payoff.\n\n\n\n\n\nstring(p::ZeroBond)\n\nFormatted (and shortened) output for ZeroBond payoff.\n\n\n\n\n\nstring(p::Asset)\n\nFormatted (and shortened) output for Asset payoff.\n\n\n\n\n\nstring(p::ForwardAsset)\n\nFormatted (and shortened) output for ForwardAsset payoff.\n\n\n\n\n\nstring(p::Fixing)\n\nFormatted (and shortened) output for Fixing payoff.\n\n\n\n\n\nstring(p::Fixed)\n\nFormatted (and shortened) output for deterministic payoff.\n\n\n\n\n\nstring(p::Pay)\n\nFormatted (and shortened) output for Pay payoff.\n\n\n\n\n\nstring(p::Cache)\n\nFormatted (and shortened) output for Cache payoff.\n\n\n\n\n\nFormatted addition.\n\n\n\n\n\nFormatted subtraction.\n\n\n\n\n\nFormatted multiplication.\n\n\n\n\n\nFormatted division.\n\n\n\n\n\nFormatted maximum.\n\n\n\n\n\nFormatted minimum.\n\n\n\n\n\nFormatted logical.\n\n\n\n\n\nstring(p::LiborRate)\n\nFormatted (and shortened) output for LiborRate payoff.\n\n\n\n\n\nstring(p::CompoundedRate)\n\nFormatted (and shortened) output for CompoundedRate payoff.\n\n\n\n\n\nstring(links::AmcPayoffLinks)\n\nFormatted (and shortened) output for AMC payoff links.\n\n\n\n\n\nstring(p::AmcMax)\n\nFormatted (and shortened) output for AmcMax payoff.\n\n\n\n\n\nstring(p::AmcMin)\n\nFormatted (and shortened) output for AmcMin payoff.\n\n\n\n\n\nstring(p::AmcOne)\n\nFormatted (and shortened) output for AmcOne payoff.\n\n\n\n\n\nstring(p::AmcSum)\n\nFormatted (and shortened) output for AmcSum payoff.\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/#Analytics","page":"Analytics","title":"Analytics","text":"","category":"section"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"In this section we document methods for instrument pricing, exposure and collateral simulation.","category":"page"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"DiffFusion.ScenarioCube","category":"page"},{"location":"analytics/analytics/#DiffFusion.ScenarioCube","page":"Analytics","title":"DiffFusion.ScenarioCube","text":"struct ScenarioCube\n    X::AbstractArray\n    times::AbstractVector\n    leg_aliases::AbstractVector\n    numeraire_context_key::String\n    discount_curve_key::Union{String,Nothing}\nend\n\nA ScenarioCube represents the result of MC pricing results of a list of product legs and is calculated for a list of observation times.\n\nElements are\n\nX - tensor of size (N_1, N_2, N_3) and type ModelValue where\nN_1 is number of Monte Carlo paths,\nN_2 is number of time steps,\nN_3 is number of legs.\ntimes - a vector representing observation times.\nleg_aliases - a list of aliases (identifiers) corresponding to each leg\nnumeraire_context_key - the context_key of the NumeraireEntry; this label should indicate the cash flow currency.\ndiscount_curve_key - a flag specifying whether prices in X are discounted prices (for XVA) or undiscounted prices (for CCR).\n\n\n\n\n\n","category":"type"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"DiffFusion.scenarios","category":"page"},{"location":"analytics/analytics/#DiffFusion.scenarios","page":"Analytics","title":"DiffFusion.scenarios","text":"scenarios(\n    legs::AbstractVector,\n    times::AbstractVector,\n    path::Path,\n    discount_curve_key::Union{String,Nothing};\n    with_progress_bar::Bool = true,\n    )\n\nCalculate ScenarioCube for a vector of CashFlowLeg objects and a vector of scenario observation times.\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"DiffFusion.join_scenarios","category":"page"},{"location":"analytics/analytics/#DiffFusion.join_scenarios","page":"Analytics","title":"DiffFusion.join_scenarios","text":"join_scenarios(cube1::ScenarioCube, cube2::ScenarioCube)\n\nJoin two scenario cubes along leg-axis.\n\n\n\n\n\njoin_scenarios(cubes::AbstractVector{ScenarioCube})\n\nJoin a list of scenario cubes along leg-axis.\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"DiffFusion.interpolate_scenarios","category":"page"},{"location":"analytics/analytics/#DiffFusion.interpolate_scenarios","page":"Analytics","title":"DiffFusion.interpolate_scenarios","text":"interpolate_scenarios(\n    t::ModelTime,\n    cube::ScenarioCube,\n    )\n\nInterpolation scenarios along time axis.\n\nWe implement linear interpolation with flat extrapolation.\n\nOther interpolations, e.g., piece-wise flat or Brownian Bridge should be incorporated here.\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"DiffFusion.concatenate_scenarios","category":"page"},{"location":"analytics/analytics/#DiffFusion.concatenate_scenarios","page":"Analytics","title":"DiffFusion.concatenate_scenarios","text":"concatenate_scenarios(cubes::AbstractVector{ScenarioCube})\n\nConcatenate a list of scenarios along time axis.\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"DiffFusion.aggregate","category":"page"},{"location":"analytics/analytics/#DiffFusion.aggregate","page":"Analytics","title":"DiffFusion.aggregate","text":"aggregate(\n    scens::ScenarioCube,\n    average_paths::Bool=true,\n    aggregate_legs::Bool=true,\n    )\n\nAverage paths and aggregate legs in ScenarioCube.\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"DiffFusion.expected_exposure","category":"page"},{"location":"analytics/analytics/#DiffFusion.expected_exposure","page":"Analytics","title":"DiffFusion.expected_exposure","text":"expected_exposure(\n    scens::ScenarioCube,\n    gross_leg::Bool = false,\n    average_paths::Bool = true,\n    aggregate_legs::Bool = true,\n    )\n\nCalculate expected positive exposure (EPE or EE).\n\n\n\n\n\n","category":"function"},{"location":"analytics/analytics/","page":"Analytics","title":"Analytics","text":"DiffFusion.potential_future_exposure","category":"page"},{"location":"analytics/analytics/#DiffFusion.potential_future_exposure","page":"Analytics","title":"DiffFusion.potential_future_exposure","text":"potential_future_exposure(\n    scens::ScenarioCube,\n    quantile_::ModelValue,\n    gross_leg::Bool = false,\n    )\n\nCalculate the potential future exposure (PFE).\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/#Paths","page":"Paths","title":"Paths","text":"","category":"section"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"In this section we document data structures and methods for path setup.","category":"page"},{"location":"paths/paths/#Simulation-Context","page":"Paths","title":"Simulation Context","text":"","category":"section"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.Context","category":"page"},{"location":"paths/paths/#DiffFusion.Context","page":"Paths","title":"DiffFusion.Context","text":"struct Context\n    alias::String\n    numeraire::NumeraireEntry\n    rates::Dict{String, RatesEntry}\n    assets::Dict{String, AssetEntry}\n    forward_indices::Dict{String, ForwardIndexEntry}\n    future_indices::Dict{String, FutureIndexEntry}\n    fixings::Dict{String, FixingEntry}\nend\n\nA Context represents a mapping from market references (keys) to model and term structure references (aliases).\n\nLinks are represented as key/alias pairs. market references are used in the specification of payoffs and products. Model and term structure references are used to set up models and model parameters.\n\nIn simple settings there can be a one-to-one mapping between market references and model/term structure references. However, more realistic settings benefit from an additional mapping. For example, discount factors for two (or more) market reference (say EUR ESTR and EUR Euribor)  can be calculated from a single model (with model reference EUR) and two (or more) yield curves (with term structure reference ESTR and Euribor).\n\nA Context\n\nadds a layer of abstraction to disentangle models and products and\nlinks models and term structures according to business logic.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.ContextEntry","category":"page"},{"location":"paths/paths/#DiffFusion.ContextEntry","page":"Paths","title":"DiffFusion.ContextEntry","text":"abstract type ContextEntry end\n\nA ContextEntry represents a mapping from a context key to model aliases and term structure aliases.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.NumeraireEntry","category":"page"},{"location":"paths/paths/#DiffFusion.NumeraireEntry","page":"Paths","title":"DiffFusion.NumeraireEntry","text":"struct NumeraireEntry <: ContextEntry\n    context_key::String\n    model_alias::Union{String, Nothing}\n    termstructure_dict::Dict{String,String}\nend\n\nA NumeraireEntry represents a link to an interest rate model and yield curves used for numeraire calculation.\n\nWe opt to allow for different yield curves in numeraire application. This should allow e.g. AMC methods wih trade-specific discounting.\n\nAn empty model alias (nothing) represents a deterministic model.\n\nThe termstructure_dict maps term structure keys to term structure aliases.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.numeraire_entry","category":"page"},{"location":"paths/paths/#DiffFusion.numeraire_entry","page":"Paths","title":"DiffFusion.numeraire_entry","text":"numeraire_entry(\n    context_key::String,\n    model_alias::Union{String, Nothing} = nothing,\n    termstructure_dict::Union{AbstractDict, Nothing} = nothing,\n    )\n\nSimplify NumeraireEntry setup.\n\n\n\n\n\nnumeraire_entry(\n    context_key::String,\n    model_alias::Union{String, Nothing},\n    termstructure_alias::String,\n    )\n\nSimplify NumeraireEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.RatesEntry","category":"page"},{"location":"paths/paths/#DiffFusion.RatesEntry","page":"Paths","title":"DiffFusion.RatesEntry","text":"struct RatesEntry <: ContextEntry\n    context_key::String\n    model_alias::Union{String, Nothing}\n    termstructure_dict::Dict{String,String}\nend\n\nA RatesEntry represents a link to an interest rate model and yield curves used for zero coupon bond calculation.\n\nAn empty model alias (nothing) represents a deterministic model.\n\nThe termstructure_dict maps term structure keys to term structure aliases.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.rates_entry","category":"page"},{"location":"paths/paths/#DiffFusion.rates_entry","page":"Paths","title":"DiffFusion.rates_entry","text":"rates_entry(\n    context_key::String,\n    model_alias::Union{String, Nothing} = nothing,\n    termstructure_dict::Union{AbstractDict, Nothing} = nothing,\n    )\n\nSimplify RatesEntry setup.\n\n\n\n\n\nratesentry(         contextkey::String,         modelalias::Union{String, Nothing},         termstructurealias::String,         )\n\nSimplify RatesEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.AssetEntry","category":"page"},{"location":"paths/paths/#DiffFusion.AssetEntry","page":"Paths","title":"DiffFusion.AssetEntry","text":"struct AssetEntry <: ContextEntry\n    context_key::String\n    asset_model_alias::Union{String, Nothing}\n    domestic_model_alias::Union{String, Nothing}\n    foreign_model_alias::Union{String, Nothing}\n    asset_spot_alias::String\n    domestic_termstructure_dict::Dict{String,String}\n    foreign_termstructure_dict::Dict{String,String}\nend\n\nAn AssetEntry represents a link to an asset model, two interest rate models and yield curves. This entry is used to calculate future simulated asset values.\n\nWe use the foreign currency analogy to represent tradeable assets.\n\nAn empty model alias (nothing) represents a deterministic model.\n\ndomestic_termstructure_dict and foreign_termstructure_dict map term structure keys to term structure aliases.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.asset_entry","category":"page"},{"location":"paths/paths/#DiffFusion.asset_entry","page":"Paths","title":"DiffFusion.asset_entry","text":"asset_entry(\n    context_key::String,\n    asset_model_alias::Union{String, Nothing} = nothing,\n    domestic_model_alias::Union{String, Nothing} = nothing,\n    foreign_model_alias::Union{String, Nothing} = nothing,\n    asset_spot_alias::Union{String, Nothing} = nothing,\n    domestic_termstructure_dict::Union{AbstractDict, Nothing} = nothing,\n    foreign_termstructure_dict::Union{AbstractDict, Nothing} = nothing,\n    )\n\nSimplify AssetEntry setup.\n\n\n\n\n\nasset_entry(\n    context_key::String,\n    asset_model_alias::Union{String, Nothing} = nothing,\n    domestic_model_alias::Union{String, Nothing} = nothing,\n    foreign_model_alias::Union{String, Nothing} = nothing,\n    asset_spot_alias::Union{String, Nothing} = nothing,\n    domestic_termstructure_alias::String,\n    foreign_termstructure_alias::String,\n    )\n\nSimplify AssetEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.ForwardIndexEntry","category":"page"},{"location":"paths/paths/#DiffFusion.ForwardIndexEntry","page":"Paths","title":"DiffFusion.ForwardIndexEntry","text":"struct ForwardIndexEntry <: ContextEntry\n    context_key::String\n    asset_model_alias::Union{String, Nothing}\n    domestic_model_alias::Union{String, Nothing}\n    foreign_model_alias::Union{String, Nothing}\n    forward_index_alias::String\nend\n\nA ForwardIndexEntry represents a link to an asset model, two interest rate models and a forward index curves. This entry is used to calculate future simulated forward asset prices.\n\nWe use the foreign currency analogy to represent tradeable assets.\n\nAn empty model alias (nothing) represents a deterministic model.\n\nforward_index_alias represents the link to the forward index curve.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.forward_index_entry","category":"page"},{"location":"paths/paths/#DiffFusion.forward_index_entry","page":"Paths","title":"DiffFusion.forward_index_entry","text":"forward_index_entry(\n    context_key::String,\n    asset_model_alias::Union{String, Nothing} = nothing,\n    domestic_model_alias::Union{String, Nothing} = nothing,\n    foreign_model_alias::Union{String, Nothing} = nothing,\n    forward_index_alias::Union{String, Nothing} = nothing,\n    )\n\nSimplify ForwardIndexEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.FutureIndexEntry","category":"page"},{"location":"paths/paths/#DiffFusion.FutureIndexEntry","page":"Paths","title":"DiffFusion.FutureIndexEntry","text":"struct FutureIndexEntry <: ContextEntry\n    context_key::String\n    future_model_alias::Union{String, Nothing}\n    future_index_alias::String\nend\n\nA FutureIndexEntry represents a link to a Futures model and a future index curve. This entry is used to calculate future simulated Future prices.\n\nKey proposition is that the Future price is a martingale in the corresponding domestic risk-neutral measure.\n\nAn empty model alias (nothing) represents a deterministic model.\n\nfuture_index_alias represents the link to the Future index curve.\n\nWe use the convention that keys are UPPERCASE strings. This aims at helping to distinguish between keys and alias.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.future_index_entry","category":"page"},{"location":"paths/paths/#DiffFusion.future_index_entry","page":"Paths","title":"DiffFusion.future_index_entry","text":"future_index_entry(\n    context_key::String,\n    future_model_alias::Union{String, Nothing} = nothing,\n    future_index_alias::String = nothing,\n    )\n\nSimplify FutureIndexEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.FixingEntry","category":"page"},{"location":"paths/paths/#DiffFusion.FixingEntry","page":"Paths","title":"DiffFusion.FixingEntry","text":"struct FixingEntry <: ContextEntry\n    context_key::String\n    termstructure_alias::String\nend\n\nA FixingEntry represents a link to a parameter term structure used to obtain fixings for indices etc.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.fixing_entry","category":"page"},{"location":"paths/paths/#DiffFusion.fixing_entry","page":"Paths","title":"DiffFusion.fixing_entry","text":"fixing_entry(\n    context_key::String,\n    termstructure_alias::Union{String, Nothing} = nothing,\n    )\n\nSimplify FixingEntry setup.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.key(ce::DiffFusion.ContextEntry)","category":"page"},{"location":"paths/paths/#DiffFusion.key-Tuple{DiffFusion.ContextEntry}","page":"Paths","title":"DiffFusion.key","text":"key(ce::ContextEntry)\n\nReturn the context key of a context entry.\n\n\n\n\n\n","category":"method"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.context","category":"page"},{"location":"paths/paths/#DiffFusion.context","page":"Paths","title":"DiffFusion.context","text":"context(\n    alias::String,\n    num_entry::NumeraireEntry,\n    rates_entries::Union{AbstractVector, Nothing} = nothing,\n    asset_entries::Union{AbstractVector, Nothing} = nothing,\n    forward_index_entries::Union{AbstractVector, Nothing} = nothing,\n    future_index_entries::Union{AbstractVector, Nothing} = nothing,\n    fixing_entries::Union{AbstractVector, Nothing} = nothing,\n    )\n\nSimplify Context setup.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.simple_context","category":"page"},{"location":"paths/paths/#DiffFusion.simple_context","page":"Paths","title":"DiffFusion.simple_context","text":"simple_context(alias::String, alias_list::AbstractVector)\n\nGenerate a simple Context based on a list of currency aliases.\n\nUser must ensure that aliases can be referenced as normalised keys.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.deterministic_model_context","category":"page"},{"location":"paths/paths/#DiffFusion.deterministic_model_context","page":"Paths","title":"DiffFusion.deterministic_model_context","text":"deterministic_model_context(alias::String, alias_list::AbstractVector)\n\nGenerate a simple Context for fully deterministic modelling based on a list of currency aliases.\n\nUser must ensure that aliases can be referenced as normalised keys.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.context_keys","category":"page"},{"location":"paths/paths/#DiffFusion.context_keys","page":"Paths","title":"DiffFusion.context_keys","text":"context_keys(key::String)\n\nParse the context entry key and term structure keys from an input key string.\n\nWe implement a simple syntax for input key strings:\n\ncontext_key:[ts_key_1][-,+][ts_key_2]\n\nResult is a tuple of the form\n\n(context_key, ts_key_1, ts_key_2, [-,+])\n\nElements that are not found are returned as emptycontextkey value.\n\nWe apply normalisation of keys to mitigate risk of key errors by the user.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/#Simulated-Paths","page":"Paths","title":"Simulated Paths","text":"","category":"section"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"The concept of a path adds a layer of abstraction. On the one-hand side we have models and simulations. These objects are specified by the mathematical details of stochastic processes. On the other hand-side we have payoffs and products. These objects are specified by the business context.","category":"page"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"A path is used to link business context and payoff evaluation to models and simulations.","category":"page"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.AbstractPath","category":"page"},{"location":"paths/paths/#DiffFusion.AbstractPath","page":"Paths","title":"DiffFusion.AbstractPath","text":"abstract type AbstractPath end\n\nAn AbstractPath specifies the interface for path implementations.\n\nThis aims at providing the flexibility to add other types of paths in the future.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.Path","category":"page"},{"location":"paths/paths/#DiffFusion.Path","page":"Paths","title":"DiffFusion.Path","text":"struct Path <: AbstractPath\n    sim::Simulation\n    ts_dict::Dict{String,<:Termstructure}\n    state_alias_dict::Dict{String,Int}\n    context::Context\n    interpolation::PathInterpolation\nend\n\nA Path combines a model, simulated model states and term structures. The interface to market references is established by a valuation context.\n\nPaths are used by payoffs to calculate simulated zero bonds, asset prices and further building blocks of financial instrument payoffs.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.path","category":"page"},{"location":"paths/paths/#DiffFusion.path","page":"Paths","title":"DiffFusion.path","text":"path(\n    sim::Simulation,\n    ts_dict::Dict{String,<:Termstructure},\n    cxt::Context,\n    ip::PathInterpolation = NoPathInterpolation\n    )\n\nCreate a Path object.\n\n\n\n\n\npath(\n    sim::Simulation,\n    ts::Vector{Termstructure},\n    cxt::Context,\n    ip::PathInterpolation = NoPathInterpolation\n    )\n\nCreate a Path object from a list of term structures.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.PathInterpolation","category":"page"},{"location":"paths/paths/#DiffFusion.PathInterpolation","page":"Paths","title":"DiffFusion.PathInterpolation","text":"@enum(\n    PathInterpolation,\n    NoPathInterpolation,\n    LinearPathInterpolation,\n)\n\nPathInterpolation encodes how simulated states can be interpolates.\n\n\n\n\n\n","category":"type"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.length","category":"page"},{"location":"paths/paths/#Base.length","page":"Paths","title":"Base.length","text":"length(p::AbstractPath)\n\nReturn the number of realisations represented by the AbstractPath object.\n\nWe assume that model functions applied to an AbstractPath return a vector of length(p) where p is the number realisations.\n\n\n\n\n\nlength(p::Path)\n\nDerive the number of realisations from the linked simulation.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.numeraire","category":"page"},{"location":"paths/paths/#DiffFusion.numeraire","page":"Paths","title":"DiffFusion.numeraire","text":"numeraire(p::AbstractPath, t::ModelTime, curve_key::String)\n\nCalculate the numeraire in the domestic currency.\n\nWe allow for curve-specific numeraire calculation e.g. to allow for trade-specific discounting in AMC valuation.\n\n\n\n\n\nnumeraire(p::Path, t::ModelTime, curve_key::String)\n\nCalculate the numeraire in the domestic currency.\n\nWe allow for curve-specific numeraire calculation e.g. to allow for trade-specific discounting in AMC valuation.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.bank_account","category":"page"},{"location":"paths/paths/#DiffFusion.bank_account","page":"Paths","title":"DiffFusion.bank_account","text":"bank_account(p::AbstractPath, t::ModelTime, key::String)\n\nCalculate a continuous compounded bank account value.\n\n\n\n\n\nbank_account(p::Path, t::ModelTime, key::String)\n\nCalculate a continuous compounded bank account value.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.zero_bond","category":"page"},{"location":"paths/paths/#DiffFusion.zero_bond","page":"Paths","title":"DiffFusion.zero_bond","text":"zero_bond(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nCalculate a zero coupon bond price.\n\n\n\n\n\nzero_bond(p::Path, t::ModelTime, T::ModelTime, key::String)\n\nCalculate a zero coupon bond price.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.asset","category":"page"},{"location":"paths/paths/#DiffFusion.asset","page":"Paths","title":"DiffFusion.asset","text":"asset(p::AbstractPath, t::ModelTime, key::String)\n\nCalculate asset price.\n\n\n\n\n\nasset(p::Path, t::ModelTime, key::String)\n\nCalculate asset price.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.forward_asset","category":"page"},{"location":"paths/paths/#DiffFusion.forward_asset","page":"Paths","title":"DiffFusion.forward_asset","text":"forward_asset(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nCalculate forward asset price as expectation in T-forward measure.\n\n\n\n\n\nforward_asset(p::Path, t::ModelTime, T::ModelTime, key::String)\n\nCalculate forward asset price as expectation in T-forward measure, conditional on time-t.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.fixing","category":"page"},{"location":"paths/paths/#DiffFusion.fixing","page":"Paths","title":"DiffFusion.fixing","text":"fixing(p::AbstractPath, t::ModelTime, key::String)\n\nReturn a fixing from a term structure.\n\nThis is used to handle fixings for indices etc.\n\n\n\n\n\nfixing(p::Path, t::ModelTime, key::String)\n\nReturn a fixing from a term structure.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.asset_convexity_adjustment","category":"page"},{"location":"paths/paths/#DiffFusion.asset_convexity_adjustment","page":"Paths","title":"DiffFusion.asset_convexity_adjustment","text":"asset_convexity_adjustment(\n    p::AbstractPath,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    key::String\n    )\n\nReturn the convexity adjustment for a YoY asset payoff.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.forward_index","category":"page"},{"location":"paths/paths/#DiffFusion.forward_index","page":"Paths","title":"DiffFusion.forward_index","text":"forward_index(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nExpectation Et^T[ST] of a tradeable asset.\n\n\n\n\n\nforward_index(p::Path, t::ModelTime, T::ModelTime, key::String)\n\nExpectation Et^T[ST] of a tradeable asset.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.index_convexity_adjustment","category":"page"},{"location":"paths/paths/#DiffFusion.index_convexity_adjustment","page":"Paths","title":"DiffFusion.index_convexity_adjustment","text":"index_convexity_adjustment(\n    p::AbstractPath,\n    t::ModelTime,\n    T0::ModelTime,\n    T1::ModelTime,\n    T2::ModelTime,\n    key::String\n    )\n\nReturn the convexity adjustment for a YoY index payoff.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.future_index","category":"page"},{"location":"paths/paths/#DiffFusion.future_index","page":"Paths","title":"DiffFusion.future_index","text":"future_index(p::AbstractPath, t::ModelTime, T::ModelTime, key::String)\n\nExpectation E_t^Q[F(T,T)] of a Future index/price.\n\n\n\n\n\nfuture_index(p::Path, t::ModelTime, T::ModelTime, key::String)\n\nExpectation E_t^Q[F(T,T)] of a Future index/price.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"Auxiliary methods:","category":"page"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.state_variable","category":"page"},{"location":"paths/paths/#DiffFusion.state_variable","page":"Paths","title":"DiffFusion.state_variable","text":"state_variable(sim::Simulation, t::ModelTime, ip::PathInterpolation)\n\nDerive a state variable for a given observation time.\n\n\n\n\n\n","category":"function"},{"location":"paths/paths/","page":"Paths","title":"Paths","text":"DiffFusion.discount(\n    t::ModelTime,\n    ts_dict::Dict{String,DiffFusion.Termstructure},\n    first_alias::String,\n    second_alias::Union{String,Nothing} = nothing,\n    operation::Union{String,Nothing} = nothing,\n    )","category":"page"},{"location":"paths/paths/#DiffFusion.discount","page":"Paths","title":"DiffFusion.discount","text":"discount(\n    t::ModelTime,\n    ts_dict::Dict{String,Termstructure},\n    first_alias::String,\n    second_alias::Union{String,Nothing} = nothing,\n    operation::Union{String,Nothing} = nothing,\n    )\n\nDerive the discount factor for one or two of curve alias and a curve operation.\n\n\n\n\n\n","category":"function"},{"location":"serialisation/serialisation/#Serialisation","page":"Serialisation","title":"Serialisation","text":"","category":"section"},{"location":"serialisation/serialisation/","page":"Serialisation","title":"Serialisation","text":"In this section we document methods for serialising and de-serialising objects.","category":"page"},{"location":"simulations/simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"simulations/simulations/","page":"Simulations","title":"Simulations","text":"In this section we document data structures and methods for Monte Carlo  simulation and path setup.","category":"page"},{"location":"simulations/simulations/#Monte-Carlo-Simulation","page":"Simulations","title":"Monte Carlo Simulation","text":"","category":"section"},{"location":"simulations/simulations/","page":"Simulations","title":"Simulations","text":"DiffFusion.Simulation","category":"page"},{"location":"simulations/simulations/#DiffFusion.Simulation","page":"Simulations","title":"DiffFusion.Simulation","text":"struct Simulation\n    model::Model\n    times::AbstractVector\n    X::AbstractArray\nend\n\nA Simulation object represents the result of a Monte Carlo simulation.\n\nElements are:\n\nmodel - the model used for simulation.\ntimes - vector of simulation times starting with 0.\nX - tensor of size (N_1, N_2, N_3) and type ModelValue where\nN_1 is length(m.state_alias),\nN_2 is number of Monte Carlo paths,\nN_3 is length(times).\n\n\n\n\n\n","category":"type"},{"location":"simulations/simulations/","page":"Simulations","title":"Simulations","text":"DiffFusion.pseudo_brownian_increments","category":"page"},{"location":"simulations/simulations/#DiffFusion.pseudo_brownian_increments","page":"Simulations","title":"DiffFusion.pseudo_brownian_increments","text":"pseudo_brownian_increments(\n    n_states::Int,\n    n_paths::Int,\n    n_times::Int,  # without zero\n    seed::Int = 271828182846,\n    )\n\nA simple method to generate Brownian motion increments.\n\n\n\n\n\n","category":"function"},{"location":"simulations/simulations/","page":"Simulations","title":"Simulations","text":"DiffFusion.sobol_brownian_increments","category":"page"},{"location":"simulations/simulations/#DiffFusion.sobol_brownian_increments","page":"Simulations","title":"DiffFusion.sobol_brownian_increments","text":"sobol_brownian_increments(\n    n_states::Int,\n    n_paths::Int,\n    n_times::Int,  # without zero\n    )\n\nGenerate Brownian motion increments via Sobol sequence.\n\n\n\n\n\n","category":"function"},{"location":"simulations/simulations/","page":"Simulations","title":"Simulations","text":"DiffFusion.simple_simulation","category":"page"},{"location":"simulations/simulations/#DiffFusion.simple_simulation","page":"Simulations","title":"DiffFusion.simple_simulation","text":"simple_simulation(\n    model::Model,\n    ch::CorrelationHolder,\n    times::AbstractVector,\n    n_paths::Int;\n    with_progress_bar::Bool = true,\n    brownian_increments::Function = pseudo_brownian_increments\n    )\n\nA simple Monte Carlo simulation method assuming all model components are state-independent.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/#Term-Structures","page":"Term Structures","title":"Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"In this section we document term structures.","category":"page"},{"location":"termstructures/termstructures/#Term-Structure-Types-and-Methods","page":"Term Structures","title":"Term Structure Types and Methods","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.Termstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.Termstructure","page":"Term Structures","title":"DiffFusion.Termstructure","text":"abstract type Termstructure end\n\nAn abstract term structure that provides an alias for identification.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.alias(ts::DiffFusion.Termstructure)","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.alias-Tuple{DiffFusion.Termstructure}","page":"Term Structures","title":"DiffFusion.alias","text":"alias(ts::Termstructure)\n\nReturn the term structure's alias.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.TermstructureResultSize","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.TermstructureResultSize","page":"Term Structures","title":"DiffFusion.TermstructureResultSize","text":"@enum(\n    TermstructureResultSize,\n    TermstructureVector,\n    TermstructureScalar\n)\n\nSpecify the dimensions/shape of the values modelled by a term structure.\n\nFor some term structures (e.g. ParameterTermstructure and VolatilityTermstructure) the result may be either a vector or a scalar.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/#CorrelationTermstructure","page":"Term Structures","title":"CorrelationTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.CorrelationTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.CorrelationTermstructure","page":"Term Structures","title":"DiffFusion.CorrelationTermstructure","text":"abstract type CorrelationTermstructure <: Termstructure end\n\nAn abstract correlation term structure that provides methods to calculate instantaneous correlations.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for CorrelationTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::CorrelationTermstructure)(args...) = correlation(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    alias1::String,\n    alias2::String,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, String, String}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, alias1::String, alias2::String)\n\nReturn a scalar instantaneous correlation.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    aliases::AbstractVector{String},\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, AbstractVector{String}}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, aliases::AbstractVector{String})\n\nReturn a symmetric matrix of instantaneous correlations.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    aliases1::AbstractVector{String},\n    aliases2::AbstractVector{String},\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, AbstractVector{String}, AbstractVector{String}}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, aliases2::AbstractVector{String})\n\nReturn a matrix of instantaneous correlations, each element of aliases1 versus each element of aliases2. The size of the resulting matrix is (length(aliases1), length(aliases2)).\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    alias1::String,\n    aliases2::AbstractVector{String},\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, String, AbstractVector{String}}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, alias1::String, aliases2::AbstractVector{String})\n\nReturn an (1,N) matrix of instantaneous correlations.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation(\n    ts::DiffFusion.CorrelationTermstructure,\n    aliases1::AbstractVector{String},\n    alias2::String,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation-Tuple{DiffFusion.CorrelationTermstructure, AbstractVector{String}, String}","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, alias2::String)\n\nReturn an (N, 1) matrix of instantaneous correlations.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#CreditDefaultTermstructure","page":"Term Structures","title":"CreditDefaultTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.CreditDefaultTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.CreditDefaultTermstructure","page":"Term Structures","title":"DiffFusion.CreditDefaultTermstructure","text":"abstract type CreditDefaultTermstructure <: Termstructure end\n\nAn abstract credit default term structure that provides methods to calculate survival probabilities.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for CreditDefaultTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::CreditDefaultTermstructure)(args...) = survival(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.survival(\n    ts::DiffFusion.CreditDefaultTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.survival-Tuple{DiffFusion.CreditDefaultTermstructure, Number}","page":"Term Structures","title":"DiffFusion.survival","text":"survival(ts::CreditDefaultTermstructure, t::ModelTime)\n\nReturn the survival probability with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#FuturesTermstructure","page":"Term Structures","title":"FuturesTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.FuturesTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.FuturesTermstructure","page":"Term Structures","title":"DiffFusion.FuturesTermstructure","text":"abstract type FuturesTermstructure <: Termstructure end\n\nAn abstract futures term structure that provides methods to calculate prices of futures. Such prices represent risk-neutral expectations of spot prices.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for FuturesTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::FuturesTermstructure)(args...) = future_price(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.future_price(\n    ts::DiffFusion.FuturesTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.future_price-Tuple{DiffFusion.FuturesTermstructure, Number}","page":"Term Structures","title":"DiffFusion.future_price","text":"future_price(ts::FuturesTermstructure, t::ModelTime)\n\nReturn the price of a future with settlement time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#InflationTermstructure","page":"Term Structures","title":"InflationTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.InflationTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.InflationTermstructure","page":"Term Structures","title":"DiffFusion.InflationTermstructure","text":"abstract type InflationTermstructure <: Termstructure end\n\nAn abstract inflation term structure that provides methods to calculate forward inflation index. Forward inflation index is a T-forward measure expectation of (spot) inflation index values.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for InflationTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::InflationTermstructure)(args...) = inflation_index(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.inflation_index(\n    ts::DiffFusion.InflationTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.inflation_index-Tuple{DiffFusion.InflationTermstructure, Number}","page":"Term Structures","title":"DiffFusion.inflation_index","text":"inflation_index(ts::InflationTermstructure, t::ModelTime)\n\nReturn the forward inflation index with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#ParameterTermstructure","page":"Term Structures","title":"ParameterTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.ParameterTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.ParameterTermstructure","page":"Term Structures","title":"DiffFusion.ParameterTermstructure","text":"abstract type ParameterTermstructure <: Termstructure end\n\nAn abstract generic parameter term structure that provides methods to retrieve parameter values for various incarnations of signatures.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for ParameterTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::ParameterTermstructure)(args...) = value(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.value(\n    ts::DiffFusion.ParameterTermstructure,\n    result_size::DiffFusion.TermstructureResultSize = DiffFusion.TermstructureVector,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.value","page":"Term Structures","title":"DiffFusion.value","text":"value(ts::ParameterTermstructure, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for constant/time-homogeneous parameters.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.value(\n    ts::DiffFusion.ParameterTermstructure,\n    t::ModelTime,\n    result_size::DiffFusion.TermstructureResultSize = DiffFusion.TermstructureVector,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.value-2","page":"Term Structures","title":"DiffFusion.value","text":"value(ts::ParameterTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/#YieldTermstructure","page":"Term Structures","title":"YieldTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.YieldTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.YieldTermstructure","page":"Term Structures","title":"DiffFusion.YieldTermstructure","text":"abstract type YieldTermstructure <: Termstructure end\n\nAn abstract yield term structure that provides methods to calculate discount factors zero rates and forward rates.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for YieldTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::YieldTermstructure)(args...) = discount(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.discount(\n    ts::DiffFusion.YieldTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.discount-Tuple{DiffFusion.YieldTermstructure, Number}","page":"Term Structures","title":"DiffFusion.discount","text":"discount(ts::YieldTermstructure, t::ModelTime)\n\nReturn the discount factor with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.zero_rate(\n    ts::DiffFusion.YieldTermstructure,\n    t0::ModelTime,\n    t1::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.zero_rate-Tuple{DiffFusion.YieldTermstructure, Number, Number}","page":"Term Structures","title":"DiffFusion.zero_rate","text":"zero_rate(ts::YieldTermstructure, t0::ModelTime, t1::ModelTime)\n\nReturn the continuous compounded zero rate over a period t0 to t1.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.zero_rate(\n    ts::DiffFusion.YieldTermstructure,\n    t::ModelTime,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.zero_rate-Tuple{DiffFusion.YieldTermstructure, Number}","page":"Term Structures","title":"DiffFusion.zero_rate","text":"zero_rate(ts::YieldTermstructure, t::ModelTime)\n\nReturn the continuous compounded zero rate as of today with observation time t.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.forward_rate(\n    ts::DiffFusion.YieldTermstructure,\n    t::ModelTime,\n    dt=1.0e-6,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.forward_rate","page":"Term Structures","title":"DiffFusion.forward_rate","text":"forward_rate(ts::YieldTermstructure, t::ModelTime, dt=1.0e-6)\n\nReturn the instantaneous forward rate with observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/#VolatilityTermstructure","page":"Term Structures","title":"VolatilityTermstructure","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.VolatilityTermstructure","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.VolatilityTermstructure","page":"Term Structures","title":"DiffFusion.VolatilityTermstructure","text":"abstract type VolatilityTermstructure <: Termstructure end\n\nAn abstract volatility term structure that provides methods to calculate volatility values for various incarnations of signatures.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"Call operator for VolatilityTermstructure is defined as","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"(ts::VolatilityTermstructure)(args...) = volatility(ts, args...)","category":"page"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.volatility(\n    ts::DiffFusion.VolatilityTermstructure,\n    t::ModelTime,\n    result_size::DiffFusion.TermstructureResultSize = DiffFusion.TermstructureVector,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.volatility","page":"Term Structures","title":"DiffFusion.volatility","text":"volatility(ts::VolatilityTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a volatility for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.volatility(\n    ts::DiffFusion.VolatilityTermstructure,\n    t::ModelTime,\n    x::ModelValue,\n    )","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.volatility-Tuple{DiffFusion.VolatilityTermstructure, Number, Number}","page":"Term Structures","title":"DiffFusion.volatility","text":"volatility(ts::VolatilityTermstructure, t::ModelTime, x::ModelValue)\n\nReturn a scalar volatility for a given observation time t and underlying or strike value x.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#Correlation-Term-Structures","page":"Term Structures","title":"Correlation Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.CorrelationHolder","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.CorrelationHolder","page":"Term Structures","title":"DiffFusion.CorrelationHolder","text":"struct CorrelationHolder <: CorrelationTermstructure\n    alias::String\n    correlations::Dict\n    sep::String\nend\n\nA container holding correlation values.\n\nA CorrelationHolder allows to calculate correlation matrices based on String alias keys (identifiers).\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation_holder","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation_holder","page":"Term Structures","title":"DiffFusion.correlation_holder","text":"correlation_holder(\n    alias::String,\n    sep = \"<>\",\n    )\n\nCreate an empty CorrelationHolder object.\n\n\n\n\n\ncorrelation_holder(m::AssetModel)\n\nReturn the correlation holder term structure.\n\n\n\n\n\nReturn the model's CorrelationHolder.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation_key","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation_key","page":"Term Structures","title":"DiffFusion.correlation_key","text":"correlation_key(ch::CorrelationHolder, alias1::String, alias2::String)\n\nDerive the key for correlation dictionary from two aliases.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.set_correlation!","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.set_correlation!","page":"Term Structures","title":"DiffFusion.set_correlation!","text":"set_correlation!(\n    ch::CorrelationHolder,\n    alias1::String,\n    alias2::String,\n    value::ModelValue\n    )\n\nInsert a new correlation value into CorrelationHolder. If a correlation already exists it is overwritten.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.get","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.get","page":"Term Structures","title":"DiffFusion.get","text":"get(ch::CorrelationHolder, alias1::String, alias2::String)\n\nImplement methodology to obtain a scalar correlation from a CorrelationHolder.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/#Parameter-Term-Structures","page":"Term Structures","title":"Parameter Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.PiecewiseFlatParameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.PiecewiseFlatParameter","page":"Term Structures","title":"DiffFusion.PiecewiseFlatParameter","text":"abstract type PiecewiseFlatParameter <: ParameterTermstructure end\n\nA generic vector-valued model parameter term structure with piece-wise constant interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.BackwardFlatParameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.BackwardFlatParameter","page":"Term Structures","title":"DiffFusion.BackwardFlatParameter","text":"struct BackwardFlatParameter <: PiecewiseFlatParameter\n    alias::String\n    times::AbstractVector\n    values::AbstractMatrix\nend\n\nA generic vector-valued model parameter term structure with piece-wise constant backward-flat interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.backward_flat_parameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.backward_flat_parameter","page":"Term Structures","title":"DiffFusion.backward_flat_parameter","text":"backward_flat_parameter(\n     alias::String,\n     times::AbstractVector,\n     values::AbstractMatrix,\n     )\n\nCreate a BackwardFlatParameter object for vector-valued parameters.\n\n\n\n\n\nbackward_flat_parameter(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a BackwardFlatParameter object for scalar parameters.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.flat_parameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.flat_parameter","page":"Term Structures","title":"DiffFusion.flat_parameter","text":"flat_parameter(value::ModelValue)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\nflat_parameter(alias::String, value::ModelValue)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\nflat_parameter(value::AbstractVector)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\nflat_parameter(alias::String, value::AbstractVector)\n\nCreate a constant BackwardFlatParameter object.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.ForwardFlatParameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.ForwardFlatParameter","page":"Term Structures","title":"DiffFusion.ForwardFlatParameter","text":"struct ForwardFlatParameter <: PiecewiseFlatParameter\n    alias::String\n    times::AbstractVector\n    values::AbstractMatrix\nend\n\nA generic vector-valued model parameter term structure with piece-wise constant forward-flat interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.forward_flat_parameter","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.forward_flat_parameter","page":"Term Structures","title":"DiffFusion.forward_flat_parameter","text":"forward_flat_parameter(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractMatrix,\n    )\n\nCreate a ForwardFlatParameter object for vector-valued parameters.\n\n\n\n\n\nforward_flat_parameter(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a ForwardFlatParameter object for scalar parameters.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.time_idx(ts::DiffFusion.BackwardFlatParameter, t)","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.time_idx-Tuple{DiffFusion.BackwardFlatParameter, Any}","page":"Term Structures","title":"DiffFusion.time_idx","text":"time_idx(ts::BackwardFlatParameter, t)\n\nFind the index such that T[idx-1] < t <= T[idx]. If t is larger than the last (or all) times T then return length(T)+1.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.time_idx(ts::DiffFusion.ForwardFlatParameter, t)","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.time_idx-Tuple{DiffFusion.ForwardFlatParameter, Any}","page":"Term Structures","title":"DiffFusion.time_idx","text":"time_idx(ts::ForwardFlatParameter, t)\n\nFind the index such that T[idx] >= t > T[idx+1]. If t is smaller than the first (or all) times T then return 0.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#Yield-Term-Structures","page":"Term Structures","title":"Yield Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.FlatForward","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.FlatForward","page":"Term Structures","title":"DiffFusion.FlatForward","text":"struct FlatForward <: YieldTermstructure\n    alias::String\n    rate\nend\n\nA constant yield term structure.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.flat_forward","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.flat_forward","page":"Term Structures","title":"DiffFusion.flat_forward","text":"flat_forward(alias::String, rate)\n\nCreate a FlatForward yield curve.\n\n\n\n\n\nflat_forward(rate)\n\nCreate a FlatForward yield curve without alias.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.ZeroCurve","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.ZeroCurve","page":"Term Structures","title":"DiffFusion.ZeroCurve","text":"struct ZeroCurve <: YieldTermstructure\n    alias::String\n    times::AbstractVector\n    values::AbstractVector\n    interpolation\nend\n\nA yield term structure based on interpolated continuous compounded zero rates.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.zero_curve","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.zero_curve","page":"Term Structures","title":"DiffFusion.zero_curve","text":"zero_curve(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    interp_method = (x,y) -> linear_interpolation(x, y, extrapolation_bc = Line()),\n    )\n\nCreate a ZeroCurve object.\n\n\n\n\n\nzero_curve(\n    times::AbstractVector,\n    values::AbstractVector,\n    interp_method = (x,y) -> linear_interpolation(x, y, extrapolation_bc = Line()),\n    )\n\nCreate a ZeroCurve object without alias.\n\n\n\n\n\nzero_curve(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    method_alias::String,\n    )\n\nCreate a ZeroCurve object using interpolation string.\n\n\n\n\n\nzero_curve(\n    times::AbstractVector,\n    values::AbstractVector,\n    method_alias::String,\n    )\n\nCreate a ZeroCurve object using interpolation string.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/#Volatility-Term-Structures","page":"Term Structures","title":"Volatility Term Structures","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.BackwardFlatVolatility","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.BackwardFlatVolatility","page":"Term Structures","title":"DiffFusion.BackwardFlatVolatility","text":"struct BackwardFlatVolatility <: VolatilityTermstructure\n    alias::String\n    times::AbstractVector\n    values::AbstractMatrix\nend\n\nA vector-valued volatility term structure with piece-wise constant (backward-flat) interpolation and constant extrapolation.\n\n\n\n\n\n","category":"type"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.backward_flat_volatility","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.backward_flat_volatility","page":"Term Structures","title":"DiffFusion.backward_flat_volatility","text":"backward_flat_volatility(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractMatrix,\n    )\n\nCreate a BackwardFlatVolatility object for vector-valued volatility.\n\nVolatility values are of size (nvols, ntimes).\n\n\n\n\n\nbackward_flat_volatility(\n    alias::String,\n    times::AbstractVector,\n    values::AbstractVector,\n    )\n\nCreate a BackwardFlatVolatility object for scalar volatility.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.flat_volatility","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.flat_volatility","page":"Term Structures","title":"DiffFusion.flat_volatility","text":"flat_volatility(alias::String, value)\n\nCreate a BackwardFlatVolatility object for a flat volatility.\n\n\n\n\n\nflat_volatility(alias::String, value)\n\nCreate a BackwardFlatVolatility object for a flat volatility.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.time_idx(ts::DiffFusion.BackwardFlatVolatility, t)","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.time_idx-Tuple{DiffFusion.BackwardFlatVolatility, Any}","page":"Term Structures","title":"DiffFusion.time_idx","text":"time_idx(ts::BackwardFlatVolatility, t)\n\nFind the index such that T[idx-1] < t <= T[idx]. If t is larger than the last (or all) times T then return length(T)+1.\n\n\n\n\n\n","category":"method"},{"location":"termstructures/termstructures/#Common-Methods-Overview","page":"Term Structures","title":"Common Methods Overview","text":"","category":"section"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.correlation","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.correlation","page":"Term Structures","title":"DiffFusion.correlation","text":"correlation(ts::CorrelationTermstructure, alias1::String, alias2::String)\n\nReturn a scalar instantaneous correlation.\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, aliases::AbstractVector{String})\n\nReturn a symmetric matrix of instantaneous correlations.\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, aliases2::AbstractVector{String})\n\nReturn a matrix of instantaneous correlations, each element of aliases1 versus each element of aliases2. The size of the resulting matrix is (length(aliases1), length(aliases2)).\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, alias1::String, aliases2::AbstractVector{String})\n\nReturn an (1,N) matrix of instantaneous correlations.\n\n\n\n\n\ncorrelation(ts::CorrelationTermstructure, aliases1::AbstractVector{String}, alias2::String)\n\nReturn an (N, 1) matrix of instantaneous correlations.\n\n\n\n\n\ncorrelation(ch::CorrelationHolder, alias1::String, alias2::String)\n\nReturn a scalar instantaneous correlation.\n\n\n\n\n\ncorrelation(ch::CorrelationHolder, aliases1::AbstractVector{String}, aliases2::AbstractVector{String})\n\nReturn a matrix of instantaneous correlations, each element of aliases1 versus each element  of aliases2. The size of the resulting matrix is (length(aliases1), length(aliases2)).\n\n\n\n\n\ncorrelation(ch::CorrelationHolder, aliases::AbstractVector{String})\n\nReturn a symmetric matrix of instantaneous correlations.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.discount","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.discount","page":"Term Structures","title":"DiffFusion.discount","text":"discount(ts::YieldTermstructure, t::ModelTime)\n\nReturn the discount factor with observation time t.\n\n\n\n\n\ndiscount(ts::FlatForward, t::ModelTime)\n\nCalculate discount factor.\n\n\n\n\n\ndiscount(ts::ZeroCurve, t::ModelTime)\n\nCalculate discount factor.\n\n\n\n\n\ndiscount(\n    t::ModelTime,\n    ts_dict::Dict{String,Termstructure},\n    first_alias::String,\n    second_alias::Union{String,Nothing} = nothing,\n    operation::Union{String,Nothing} = nothing,\n    )\n\nDerive the discount factor for one or two of curve alias and a curve operation.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.value","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.value-3","page":"Term Structures","title":"DiffFusion.value","text":"value(ts::ParameterTermstructure, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for constant/time-homogeneous parameters.\n\n\n\n\n\nvalue(ts::ParameterTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for a given observation time t.\n\n\n\n\n\nvalue(ts::PiecewiseFlatParameter, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for constant/time-homogeneous parameters.\n\n\n\n\n\nvalue(ts::PiecewiseFlatParameter, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a value for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.volatility","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.volatility-2","page":"Term Structures","title":"DiffFusion.volatility","text":"volatility(ts::VolatilityTermstructure, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a volatility for a given observation time t.\n\n\n\n\n\nvolatility(ts::VolatilityTermstructure, t::ModelTime, x::ModelValue)\n\nReturn a scalar volatility for a given observation time t and underlying or strike value x.\n\n\n\n\n\nvolatility(ts::BackwardFlatVolatility, t::ModelTime, result_size::TermstructureResultSize = TermstructureVector)\n\nReturn a vector of volatilities for a given observation time t.\n\n\n\n\n\n","category":"function"},{"location":"termstructures/termstructures/","page":"Term Structures","title":"Term Structures","text":"DiffFusion.survival","category":"page"},{"location":"termstructures/termstructures/#DiffFusion.survival","page":"Term Structures","title":"DiffFusion.survival","text":"survival(ts::CreditDefaultTermstructure, t::ModelTime)\n\nReturn the survival probability with observation time t.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"In this section we document commonly used utility structures methods.","category":"page"},{"location":"utils/utils/#Interpolation-Methods","page":"Utilities","title":"Interpolation Methods","text":"","category":"section"},{"location":"utils/utils/","page":"Utilities","title":"Utilities","text":"DiffFusion.interpolation_methods","category":"page"},{"location":"utils/utils/#DiffFusion.interpolation_methods","page":"Utilities","title":"DiffFusion.interpolation_methods","text":"const interpolation_methods = Dict{String, Function}(...)\n\nSpecify names for available interpolation methods.\n\nDictionary values are constructors with signature (x,y) -> interpolation\n\nAvailable interpolation strings (i.e. keys) are\n\nLINEAR,\nCUBIC,\nAKIMA,\nFRITSCHCARLSON,\nSTEFFEN.\n\nSee package Interpolations for details.\n\n\n\n\n\n","category":"constant"},{"location":"pages/additional_functions/#Additional-Functions","page":"Additional Functions","title":"Additional Functions","text":"","category":"section"},{"location":"pages/additional_functions/","page":"Additional Functions","title":"Additional Functions","text":"In this section we document additional functions.","category":"page"},{"location":"pages/additional_functions/","page":"Additional Functions","title":"Additional Functions","text":"DiffFusion.alias","category":"page"},{"location":"pages/additional_functions/#DiffFusion.alias","page":"Additional Functions","title":"DiffFusion.alias","text":"alias(ts::Termstructure)\n\nReturn the term structure's alias.\n\n\n\n\n\nalias(m::Model)\n\nReturn the model's own alias. This is the default implementation.\n\n\n\n\n\nalias(m::MarkovFutureModel)\n\nReturn the model's own alias. This is the default implementation.\n\n\n\n\n\nalias(c::Context)\n\nReturn the alias of a Context object.\n\n\n\n\n\nalias(leg::CashFlowLeg)\n\nReturn the leg alias\n\n\n\n\n\n","category":"function"},{"location":"pages/additional_functions/#Aliases-for-Common-Abstract-Data-Types","page":"Additional Functions","title":"Aliases for Common Abstract Data Types","text":"","category":"section"},{"location":"pages/additional_functions/","page":"Additional Functions","title":"Additional Functions","text":"DiffFusion.ModelTime","category":"page"},{"location":"pages/additional_functions/#DiffFusion.ModelTime","page":"Additional Functions","title":"DiffFusion.ModelTime","text":"A type alias for variables representing time.\n\n\n\n\n\n","category":"type"},{"location":"pages/additional_functions/","page":"Additional Functions","title":"Additional Functions","text":"DiffFusion.ModelValue","category":"page"},{"location":"pages/additional_functions/#DiffFusion.ModelValue","page":"Additional Functions","title":"DiffFusion.ModelValue","text":"A type alias for variables representing modelled quantities.\n\n\n\n\n\n","category":"type"},{"location":"products/products/#Products","page":"Products","title":"Products","text":"","category":"section"},{"location":"products/products/","page":"Products","title":"Products","text":"In this section we document product objects and methods.","category":"page"},{"location":"products/products/#Cash-Flow-and-Coupon-Types","page":"Products","title":"Cash Flow and Coupon Types","text":"","category":"section"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.CashFlow","category":"page"},{"location":"products/products/#DiffFusion.CashFlow","page":"Products","title":"DiffFusion.CashFlow","text":"abstract type CashFlow end\n\nA CashFlow represents a general payment in an unspecified currency.\n\nIn a simulation, we calculate discounted expected cash flows in a consistent numeraire currency.\n\nThe CashFlow object is inspired by QuantLib's CashFlow interface.\n\nWe apply the convention that cash flows are formulated for unit notionals. Actual notionals are applied at the level of legs. This design aims at simplifying MTM cross currency swap legs with notional exchange.\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.CombinedCashFlow","category":"page"},{"location":"products/products/#DiffFusion.CombinedCashFlow","page":"Products","title":"DiffFusion.CombinedCashFlow","text":"struct CombinedCashFlow <: CashFlow\n    first::CashFlow\n    second::CashFlow\n    op::Function\nend\n\nA composition of two cash flows in a single cash flow.\n\nThis CashFlow type is intended e.g. for spreads and caplets/floorlets.\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.combined_cashflow","category":"page"},{"location":"products/products/#DiffFusion.combined_cashflow","page":"Products","title":"DiffFusion.combined_cashflow","text":"combined_cashflow(\n    first::CashFlow,\n    second::CashFlow,\n    op::Function,\n    )\n\nCreate a CombinedCashFlow object.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"CombinedCashFlow","category":"page"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.Coupon","category":"page"},{"location":"products/products/#DiffFusion.Coupon","page":"Products","title":"DiffFusion.Coupon","text":"abstract type Coupon <: CashFlow end\n\nA Coupon is a payment that is composed of an (effective) coupon rate and a year fraction.\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.FixedCashFlow","category":"page"},{"location":"products/products/#DiffFusion.FixedCashFlow","page":"Products","title":"DiffFusion.FixedCashFlow","text":"struct FixedCashFlow <: CashFlow\n    pay_time::ModelTime\n    amount::ModelValue\nend\n\nA simple deterministic cash flow (normalised to one unit notional)\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.FixedRateCoupon","category":"page"},{"location":"products/products/#DiffFusion.FixedRateCoupon","page":"Products","title":"DiffFusion.FixedRateCoupon","text":"struct FixedRateCoupon <: Coupon\n    pay_time::ModelTime\n    fixed_rate::ModelValue\n    year_fraction::ModelValue\nend\n\nA fixed rate coupon.\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.SimpleRateCoupon","category":"page"},{"location":"products/products/#DiffFusion.SimpleRateCoupon","page":"Products","title":"DiffFusion.SimpleRateCoupon","text":"struct SimpleRateCoupon <: Coupon\n    fixing_time::ModelTime\n    start_time::ModelTime\n    end_time::ModelTime\n    pay_time::ModelTime\n    year_fraction::ModelValue\n    curve_key::String\n    fixing_key::Union{String, Nothing}\n    spread_rate::Union{ModelValue, Nothing}\nend\n\nA (legacy) Libor or Euribor rate coupon.\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.CompoundedRateCoupon","category":"page"},{"location":"products/products/#DiffFusion.CompoundedRateCoupon","page":"Products","title":"DiffFusion.CompoundedRateCoupon","text":"struct CompoundedRateCoupon <: Coupon\n    period_times::AbstractVector\n    period_year_fractions::AbstractVector\n    pay_time::ModelTime\n    curve_key::String\n    fixing_key::Union{String, Nothing}\n    spread_rate::Union{ModelValue, Nothing}\nend\n\nA backward-looking compounded RFR coupon.\n\n\n\n\n\n","category":"type"},{"location":"products/products/#Cash-Flow-and-Coupon-Methods","page":"Products","title":"Cash Flow and Coupon Methods","text":"","category":"section"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.pay_time(cf::DiffFusion.CashFlow)","category":"page"},{"location":"products/products/#DiffFusion.pay_time-Tuple{DiffFusion.CashFlow}","page":"Products","title":"DiffFusion.pay_time","text":"pay_time(cf::CashFlow)\n\nReturn the payment time for a CashFlow.\n\nThis represents a default implementation\n\nThis method is used to calculate discounted expected values.\n\n\n\n\n\n","category":"method"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.pay_time(cf::DiffFusion.CombinedCashFlow)","category":"page"},{"location":"products/products/#DiffFusion.pay_time-Tuple{DiffFusion.CombinedCashFlow}","page":"Products","title":"DiffFusion.pay_time","text":"pay_time(cf::CombinedCashFlow)\n\nReturn the payment time for a CombinedCashFlow.\n\n\n\n\n\n","category":"method"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.amount(cf::DiffFusion.CashFlow)","category":"page"},{"location":"products/products/#DiffFusion.amount-Tuple{DiffFusion.CashFlow}","page":"Products","title":"DiffFusion.amount","text":"amount(cf::CashFlow)\n\nReturn the payoff representing the simulated cash flow amount of the payment.\n\nThis method is intended to be used for general payoffs in conjunction with AMC.\n\n\n\n\n\n","category":"method"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.expected_amount(cf::DiffFusion.CashFlow, obs_time::ModelTime)","category":"page"},{"location":"products/products/#DiffFusion.expected_amount-Tuple{DiffFusion.CashFlow, Number}","page":"Products","title":"DiffFusion.expected_amount","text":"expected_amount(cf::CashFlow, obs_time::ModelTime)\n\nReturn the payoff representing the simulated expected amount of the payment.\n\nExpectation is calculated in T-forward measure of cash flow currency with T being the payment time and conditioning on observation time.\n\nThis method is intended to be used for analytical pricers.\n\n\n\n\n\n","category":"method"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.year_fraction(cf::DiffFusion.Coupon)","category":"page"},{"location":"products/products/#DiffFusion.year_fraction-Tuple{DiffFusion.Coupon}","page":"Products","title":"DiffFusion.year_fraction","text":"year_fraction(cf::Coupon)\n\nDerive the year fraction for a Coupon.\n\n\n\n\n\n","category":"method"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.coupon_rate(cf::DiffFusion.Coupon)","category":"page"},{"location":"products/products/#DiffFusion.coupon_rate-Tuple{DiffFusion.Coupon}","page":"Products","title":"DiffFusion.coupon_rate","text":"coupon_rate(cf::Coupon)\n\nReturn a payoff for the realised simulated effective coupon rate.\n\n\n\n\n\n","category":"method"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.forward_rate(cf::DiffFusion.Coupon, obs_time::ModelTime)","category":"page"},{"location":"products/products/#DiffFusion.forward_rate-Tuple{DiffFusion.Coupon, Number}","page":"Products","title":"DiffFusion.forward_rate","text":"forward_rate(cf::Coupon, obs_time::ModelTime)\n\nReturn a payoff for the effective forward rate of the coupon.\n\nExpectation is calculated in T-forward measure of cash flow currency with T being the payment time and conditioning on observation time.\n\nThis method is intended to be used for analytical pricers.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#Cash-Flow-Legs","page":"Products","title":"Cash Flow Legs","text":"","category":"section"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.CashFlowLeg","category":"page"},{"location":"products/products/#DiffFusion.CashFlowLeg","page":"Products","title":"DiffFusion.CashFlowLeg","text":"abstract type CashFlowLeg end\n\nA CashFlowLeg combines CashFlow objects in a single currency and adds notional and payer/receiver information and discounting.\n\nWe apply the convention that notionals are non-negative and cash flows are modelled from the receiving counter party perspective. This does include the exceptions of negative spread cash flows or negative notional exchange cash flows.\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.DeterministicCashFlowLeg","category":"page"},{"location":"products/products/#DiffFusion.DeterministicCashFlowLeg","page":"Products","title":"DiffFusion.DeterministicCashFlowLeg","text":"struct DeterministicCashFlowLeg <: CashFlowLeg\n    alias::String\n    cashflows::AbstractVector\n    notionals::AbstractVector\n    curve_key::String\n    fx_key::Union{String, Nothing}\n    payer_receiver::ModelValue\nend\n\nA DeterministicCashFlowLeg models legs with deterministic notionals.\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.cashflow_leg","category":"page"},{"location":"products/products/#DiffFusion.cashflow_leg","page":"Products","title":"DiffFusion.cashflow_leg","text":"cashflow_leg(\n    alias::String,\n    cashflows::AbstractVector,\n    notionals::AbstractVector,\n    curve_key::Union{String, Nothing} = nothing,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a DeterministicCashFlowLeg.\n\n\n\n\n\ncashflow_leg(\n    alias::String,\n    cashflows::AbstractVector,\n    notional::ModelValue,\n    curve_key::Union{String, Nothing} = nothing,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver = 1.0,\n    )\n\nCreate a constant notional CashFlowLeg.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.MtMCashFlowLeg","category":"page"},{"location":"products/products/#DiffFusion.MtMCashFlowLeg","page":"Products","title":"DiffFusion.MtMCashFlowLeg","text":"struct MtMCashFlowLeg <: CashFlowLeg\n    alias::String\n    cashflows::AbstractVector\n    intitial_notional::ModelValue\n    curve_key_dom::String\n    curve_key_for::String\n    fx_key_dom::Union{String, Nothing}\n    fx_key_for::Union{String, Nothing}\n    fx_reset_times::AbstractVector\n    fx_pay_times::AbstractVector\n    payer_receiver::ModelValue\nend\n\nA mark-to-market (MtM) cross currency cash flow leg adds notional resets to the cash flow payments.\n\nNotional resets are calculated from FX rates at reset times.\n\nWe consider a setting with numeraire currency, domestic currency and foreign currency.\n\nCash flows are denominated in domestic currency. Initial notional is expressed in foreign currency and simulation is modelled in numeraire currency.\n\nWe denote fx_key_for the FOR-NUM asset key and fx_key_dom the DOM-NUM asset key.\n\nFX rates for notional exchange are fixed at fx_reset_times and notional cash flows are exchanged at fx_pay_times. The very first notional exchange is not modelled because it is either in the past or foreign and domestic notional exchange offset each other.\n\nAs a consequence, we have one fx_reset_time and one fx_pay_time per cash flow. The fx_reset_time is at (or before) the start of the coupon period and fx_pay_time is at (or after) the end of the coupon period.\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.mtm_cashflow_leg","category":"page"},{"location":"products/products/#DiffFusion.mtm_cashflow_leg","page":"Products","title":"DiffFusion.mtm_cashflow_leg","text":"mtm_cashflow_leg(\n    alias::String,\n    cashflows::AbstractVector,\n    intitial_notional::ModelValue,\n    curve_key_dom::String,\n    curve_key_for::String,\n    fx_key_dom::Union{String, Nothing},\n    fx_key_for::Union{String, Nothing},\n    fx_reset_times::AbstractVector,\n    fx_pay_times::AbstractVector,\n    payer_receiver::ModelValue,\n    )\n\nCreate a MTM cash flow leg.\n\n\n\n\n\nmtm_cashflow_leg(\n    alias::String,\n    leg::DeterministicCashFlowLeg,\n    intitial_notional::ModelValue,  # in foreign currency\n    initial_reset_time::ModelValue,\n    curve_key_for::String,\n    fx_key_for::Union{String, Nothing},\n    )\n\nCreate a MtM cash flow leg from a deterministic leg.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.CashBalanceLeg","category":"page"},{"location":"products/products/#DiffFusion.CashBalanceLeg","page":"Products","title":"DiffFusion.CashBalanceLeg","text":"struct CashBalance <: CashFlowLeg\n    alias::String\n    notional::ModelValue\n    fx_key::Union{String, Nothing}\n    payer_receiver::ModelValue\n    maturity_time::Union{Nothing, ModelTime}\nend\n\nA CashLeg represents a constant cash balance in domestic or foreign corrency.\n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.cash_balance_leg","category":"page"},{"location":"products/products/#DiffFusion.cash_balance_leg","page":"Products","title":"DiffFusion.cash_balance_leg","text":"cash_balance_leg(\n    alias::String,\n    notional::ModelValue,\n    fx_key::Union{String, Nothing} = nothing,\n    payer_receiver::ModelValue = +1.0,\n    maturity_time::Union{Nothing, ModelTime} = nothing\n    )\n\nCreate a CashBalance object.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.AssetLeg","category":"page"},{"location":"products/products/#DiffFusion.AssetLeg","page":"Products","title":"DiffFusion.AssetLeg","text":"An AssetLeg represents a position in a tradeable asset. Such tradeable asset can be, e.g., a share price, index price or an (FOR-DOM) FX rate where DOM currency differs from numeraire currency. \n\n\n\n\n\n","category":"type"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.future_cashflows(leg::DiffFusion.CashFlowLeg, obs_time::ModelTime)","category":"page"},{"location":"products/products/#DiffFusion.future_cashflows-Tuple{DiffFusion.CashFlowLeg, Number}","page":"Products","title":"DiffFusion.future_cashflows","text":"future_cashflows(leg::CashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.discounted_cashflows(leg::DiffFusion.CashFlowLeg, obs_time::ModelTime)","category":"page"},{"location":"products/products/#DiffFusion.discounted_cashflows-Tuple{DiffFusion.CashFlowLeg, Number}","page":"Products","title":"DiffFusion.discounted_cashflows","text":"discounted_cashflows(leg::CashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"method"},{"location":"products/products/#Common-Methods-Overview","page":"Products","title":"Common Methods Overview","text":"","category":"section"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.amount","category":"page"},{"location":"products/products/#DiffFusion.amount","page":"Products","title":"DiffFusion.amount","text":"amount(cf::CashFlow)\n\nReturn the payoff representing the simulated cash flow amount of the payment.\n\nThis method is intended to be used for general payoffs in conjunction with AMC.\n\n\n\n\n\namount(cf::Coupon)\n\nCalculate payment amount for a Coupon.\n\n\n\n\n\namount(cf::FixedCashFlow)\n\nReturn FixedCashFlow amount.\n\n\n\n\n\namount(cf::CombinedCashFlow)\n\nReturn the payoff representing the simulated cash flow amount of the payment.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.coupon_rate","category":"page"},{"location":"products/products/#DiffFusion.coupon_rate","page":"Products","title":"DiffFusion.coupon_rate","text":"coupon_rate(cf::Coupon)\n\nReturn a payoff for the realised simulated effective coupon rate.\n\n\n\n\n\ncoupon_rate(cf::FixedRateCoupon)\n\nReturn FixedRateCoupon rate.\n\n\n\n\n\ncoupon_rate(cf::SimpleRateCoupon)\n\nReturn SimpleRateCoupon rate.\n\n\n\n\n\ncoupon_rate(cf::CompoundedRateCoupon)\n\nReturn CompoundedRateCoupon rate.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.discounted_cashflows","category":"page"},{"location":"products/products/#DiffFusion.discounted_cashflows","page":"Products","title":"DiffFusion.discounted_cashflows","text":"discounted_cashflows(leg::CashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\ndiscounted_cashflows(leg::DeterministicCashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\ndiscounted_cashflows(leg::MtMCashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\ndiscounted_cashflows(leg::CashBalanceLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\ndiscounted_cashflows(leg::AssetLeg, obs_time::ModelTime)\n\nCalculate the list of future discounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.expected_amount","category":"page"},{"location":"products/products/#DiffFusion.expected_amount","page":"Products","title":"DiffFusion.expected_amount","text":"expected_amount(cf::CashFlow, obs_time::ModelTime)\n\nReturn the payoff representing the simulated expected amount of the payment.\n\nExpectation is calculated in T-forward measure of cash flow currency with T being the payment time and conditioning on observation time.\n\nThis method is intended to be used for analytical pricers.\n\n\n\n\n\nexpected_amount(cf::Coupon, obs_time::ModelTime)\n\nCalculate expected payment amount for a Coupon.\n\n\n\n\n\nexpected_amount(cf::FixedCashFlow, obs_time::ModelTime)\n\nReturn FixedCashFlow expected amount.\n\n\n\n\n\nexpected_amount(cf::CombinedCashFlow, obs_time::ModelTime)\n\nReturn the payoff representing the simulated expected amount of the payment.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.forward_rate","category":"page"},{"location":"products/products/#DiffFusion.forward_rate","page":"Products","title":"DiffFusion.forward_rate","text":"forward_rate(ts::YieldTermstructure, t::ModelTime, dt=1.0e-6)\n\nReturn the instantaneous forward rate with observation time t.\n\n\n\n\n\nforward_rate(cf::Coupon, obs_time::ModelTime)\n\nReturn a payoff for the effective forward rate of the coupon.\n\nExpectation is calculated in T-forward measure of cash flow currency with T being the payment time and conditioning on observation time.\n\nThis method is intended to be used for analytical pricers.\n\n\n\n\n\nforward_rate(cf::FixedRateCoupon, obs_time::ModelTime)\n\nReturn FixedRateCoupon forward rate.\n\n\n\n\n\nforward_rate(cf::SimpleRateCoupon, obs_time::ModelTime)\n\nReturn SimpleRateCoupon forward rate.\n\n\n\n\n\nforward_rate(cf::CompoundedRateCoupon, obs_time::ModelTime)\n\nReturn CompoundedRateCoupon forward rate.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.future_cashflows","category":"page"},{"location":"products/products/#DiffFusion.future_cashflows","page":"Products","title":"DiffFusion.future_cashflows","text":"future_cashflows(leg::CashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\nfuture_cashflows(leg::DeterministicCashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\nfuture_cashflows(leg::MtMCashFlowLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\nfuture_cashflows(leg::CashBalanceLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\nfuture_cashflows(leg::AssetLeg, obs_time::ModelTime)\n\nCalculate the list of future undiscounted payoffs in numeraire currency.\n\n\n\n\n\n","category":"function"},{"location":"products/products/","page":"Products","title":"Products","text":"DiffFusion.year_fraction","category":"page"},{"location":"products/products/#DiffFusion.year_fraction","page":"Products","title":"DiffFusion.year_fraction","text":"year_fraction(cf::Coupon)\n\nDerive the year fraction for a Coupon.\n\n\n\n\n\nyear_fraction(cf::FixedRateCoupon)\n\nReturn FixedRateCoupon year_fraction.\n\n\n\n\n\nyear_fraction(cf::SimpleRateCoupon)\n\nReturn SimpleRateCoupon year_fraction.\n\n\n\n\n\nyear_fraction(cf::CompoundedRateCoupon)\n\nReturn CompoundedRateCoupon year_fraction.\n\n\n\n\n\n","category":"function"},{"location":"pages/function_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"pages/function_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#DiffFusion.jl-[F]","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"","category":"section"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"Documentation for DiffFusion.jl.","category":"page"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"The DiffFusion.jl package implements a framework for joint simulation of financial risk factors, risk-neutral valuation of financial instruments and calculation of portfolio risk measures.","category":"page"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"The intended purpose of the package is efficient exposure simulation for XVA and Counterparty Credit Risk (CCR).","category":"page"},{"location":"#Repository","page":"DiffFusion.jl [∂F]","title":"Repository","text":"","category":"section"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"The code for DiffFusion.jl is hosted at github.com/frame-consulting/DiffFusion.jl.","category":"page"},{"location":"#Installation","page":"DiffFusion.jl [∂F]","title":"Installation","text":"","category":"section"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"The most recent release of the package can be installed via","category":"page"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"using Pkg; Pkg.add(\"DiffFusion.jl\")","category":"page"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"Unit tests can be run via","category":"page"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"Pkg.test(\"DiffFusion\")","category":"page"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"For details on the functionality, see the Overview page.","category":"page"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"For questions please contact info@frame-consult.de.","category":"page"},{"location":"#Getting-Started","page":"DiffFusion.jl [∂F]","title":"Getting Started","text":"","category":"section"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"The best way of getting started with the DiffFusion framework is to have a look at the test suite.","category":"page"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"An example for exposure simulation of a Vanilla swap portfolio is implemented in the scenario generation component test.","category":"page"},{"location":"","page":"DiffFusion.jl [∂F]","title":"DiffFusion.jl [∂F]","text":"Individual examples on model, simulation and product setup can be found in the unit tests.","category":"page"}]
}
